<!doctype html>
<html lang="en-us">
  <head>
    <title>VMProtect 2 - Part Two, Complete Static Analysis // Back Engineering Blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.83.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />

    <meta name="description" content="The purpose of this article is to expound upon the prior work disclosed in the last article titled, VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture, as well as correct a few mistakes. In addition, this post will focus primarily on the creation of static analysis tools using the knowledge disclosed in the prior post..." />
    <meta name="theme-color" content="#57cc8a">
    
    <meta property="og:title" content="VMProtect 2 - Part Two, Complete Static Analysis">
    <meta property="og:image" content="https://blog.back.engineering/icon.png">
    <meta property="og:site_name" content="Private Group Of Back Engineers">
    
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.css" integrity="sha512-Woz+DqWYJ51bpVk5Fv0yES/edIMXjj3Ynda+KWTIkGoynAMHrqTcDUQltbipuiaD5ymEo9520lyoVOo9jCQOCA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.js" integrity="sha512-UHlZzRsMRK/ENyZqAJSmp/EwG8K/1X/SzErVgPc0c9pFyhUwUQmoKeEvv9X0uNw8x46FxgIJqlD2opSoH5fjug==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://blog.back.engineering/css/main.min.b50c5e74ca256bef95648b85b17023dda9b3c6ca2838d24d48ea78978bd1f333.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="VMProtect 2 - Part Two, Complete Static Analysis"/>
<meta name="twitter:description" content="The purpose of this article is to expound upon the prior work disclosed in the last article titled, VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture, as well as correct a few mistakes. In addition, this post will focus primarily on the creation of static analysis tools using the knowledge disclosed in the prior post..."/>

    <meta property="og:title" content="VMProtect 2 - Part Two, Complete Static Analysis" />
<meta property="og:description" content="The purpose of this article is to expound upon the prior work disclosed in the last article titled, VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture, as well as correct a few mistakes. In addition, this post will focus primarily on the creation of static analysis tools using the knowledge disclosed in the prior post..." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.back.engineering/21/06/2021/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-21T16:16:05-07:00" />
<meta property="article:modified_time" content="2021-06-21T16:16:05-07:00" />


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

  </head>
  <body>
    <nav class="app-container box">
      <div class="logo">
      	<a href="/">Home</a>
      </div>
	  <div class="links">
	  	<a href="https://git.back.engineering/explore/repos/">Git</a>
			<a href="https://docs.back.engineering/">Doxygen</a>
			<a href="/tags/">Tags</a>
			<a href="/researchers/">Researchers</a>
	  </div>
	</nav>
    <main class="app-container box">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">VMProtect 2 - Part Two, Complete Static Analysis</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 21, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          27 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://blog.back.engineering/tags/vmprotect-2/">VMProtect-2</a>
              <a class="tag" href="https://blog.back.engineering/tags/obfuscation/">Obfuscation</a>
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-codepen">
  <title>codepen</title>
  <polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>
</svg> Author(s):
              <a class="tag" href="https://blog.back.engineering/researchers/_xeroxz/">IDontCode</a>
        </div>
        
      </div>
    </header>
    <div class="post-content">
      <p>VMProtect 2 Project&rsquo;s Group: <a href="https://githacks.org/vmp2">githacks.org/vmp2</a></p>
<p><a href="#table-of-contents" id="table-of-contents"><h1>Table Of Contents</h1></a></p>
<hr>
<ul>
<li><a href="#purpose">Purpose</a></li>
<li><a href="#intentions">Intentions</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#projects-overview">VMProtect 2 - Project’s Overview</a>
<ul>
<li><a href="#vmhook-overview">VMHook - Overview</a>
<ul>
<li><a href="#um-hook-overview">VMHook - Example, um-hook</a></li>
</ul>
</li>
<li><a href="#vmprofiler-overview">VMProfiler - Overview</a>
<ul>
<li><a href="#vmprofiler-virtual-machine-handler-profiling">VMProfiler - Virtual Machine Handler Profiling</a></li>
<li><a href="#vmprofiler-virtual-branch-detection-algorithm">VMProfiler - Virtual Branch Detection Algorithm</a></li>
</ul>
</li>
<li><a href="#vmprofiler-qt-overview">VMProfiler Qt - Overview</a></li>
<li><a href="#vmprofiler-cli-overview">VMProfiler CLI - Overview</a></li>
<li><a href="#vmemu-overview">VMEmu - Overview</a>
<ul>
<li><a href="#vmemu-unicorn-engine-static-decryption-of-opcodes">VMEmu - Unicorn Engine, Static Decryption Of Opcodes</a></li>
<li><a href="#vmemu-virtual-branching">VMEmu - Virtual Branching</a></li>
</ul>
</li>
<li><a href="#vmassembler-overview">VMAssembler - Overview</a>
<ul>
<li><a href="#vmassembler-assembler-stages">VMAssembler - Assembler Stages</a></li>
<li><a href="#vmassembler-stage-one">VMAssembler - Stage One, Lexical Analysis and Parsing</a></li>
<li><a href="#vmassembler-stage-two">VMAssembler - Stage Two, Virtual Instruction Encoding</a></li>
<li><a href="#vmassembler-stage-three">VMAssembler - Stage Three, Virtual Instruction Encryption</a></li>
<li><a href="#vmassembler-stage-four">VMAssembler - Stage Four, C++ Header Generation</a></li>
<li><a href="#vmassembler-example">VMAssembler - Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#vtil-getting-started">VTIL - Getting Started</a>
<ul>
<li><a href="#vtil-the-basic-block">VTIL - The Basic Block</a></li>
<li><a href="#vtil-vmprofiler-lifting">VTIL - VMProfiler Lifting</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion - Final Words and Future Work</a>
<ul>
<li><a href="#conclusion-future-work">Conclusion - Future Work</a></li>
</ul>
</li>
</ul>
<p><a href="#purpose" id="purpose"><h1>Purpose</h1></a></p>
<hr>
<p>The purpose of this article is to expound upon the prior work disclosed in the last article titled <a href="https://blog.back.engineering/17/05/2021/">&ldquo;VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture”</a>, as well as correct a few mistakes. In addition, this post will focus primarily on the creation of static analysis tools using the knowledge disclosed in the prior post, and providing some detailed, albut unofficial, <a href="https://github.com/vtil-project/VTIL-Core">VTIL</a> documentation. This article will also showcase all projects on <a href="https://githacks.org/vmp2">githacks.org/vmp2</a>, however, these projects are subject to change.</p>
<p><a href="#intentions" id="intentions"><h1>Intentions</h1></a></p>
<hr>
<p>My intentions behind this research is to further my knowledge in the subject of software protection via native code virtualization, and code obfuscation, it is not to profit nor slander the name of VMProtect. Rather, the creator(s) of said software are to be respected as their work is clearly impressive and has arguably stood the test of time.</p>
<p><a href="#definitions" id="definitions"><h1>Definitions</h1></a></p>
<hr>
<p><code>Code Block</code>: A virtual instruction block, or code block, is a sequence of virtual instructions which are contained between virtual branching instructions. An example of this would be any instructions following a JMP instruction and the next JMP or VMEXIT instruction. A code block is represented in C++ as a structure (<a href="https://docs.back.engineering/vmprofiler/structvm_1_1instrs_1_1code__block__t.html">vm::instrs::code_block_t</a>) containing a vector of virtual instructions,  along with the beginning address of the code block contained in the structure itself. Other metadata about a given code block is also contained inside of this structure such as if the code block branches to two other code blocks, branches to only one code block, or exits the virtual machine.</p>
<p><code>VMProtect 2 IL</code>: Intermediate level of representation, or language. Consider the encoded and encrypted virtual instructions to be the usable, native form of virtual instructions. Then IL would be a higher level representation, typically IL representation refers to a representation of code used by compilers and assemblers. An example of VMProtect 2 IL is what VMAssembler does lexical analysis on, or a file containing the IL to be more specific.</p>
<p><a href="#projects-overview" id="projects-overview"><h1>VMProtect 2 - Project’s Overview</h1></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/projects-overview.png"/></center>
<center>Note: you can find the <a href="https://docs.back.engineering/vmprofiler/">doxygen for VMProfiler here</a></center>
<p>Although there may seem to be quite a handful of projects located at <a href="https://githacks.org/vmp2">githacks.org/vmp2</a>, there is really only a single large library project and smaller projects which inherit this library. <a href="https://githacks.org/vmp2/vmprofiler">VMProfiler</a> is the base library for <a href="https://githacks.org/vmp2/vmprofiler-qt">VMProfiler Qt</a>, <a href="https://githacks.org/vmp2/vmprofiler-cli">VMProfiler CLI</a>, <a href="https://githacks.org/vmp2/vmemu">VMEmu</a>, and <a href="https://githacks.org/vmp2/vmassembler">VMAssembler</a>. Each of these projects are static analysis based and thus <a href="https://githacks.org/vmp2/vmhook">VMHook</a> and <a href="https://githacks.org/vmp2/um-hook">um-hook</a> do not inherit <a href="https://githacks.org/vmp2/vmprofiler">VMProfiler</a>.</p>
<p><a href="#vmhook-overview" id="vmhook-overview"><h3>VMHook - Overview</h3></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/um-hook-overview.png"/></center>
<p><a href="https://githacks.org/vmp2/vmhook">VMHook</a> is a very small C++ framework for hooking into VMProtect 2 virtual machines, um-hook inherits this framework and provides a demonstration of how to use the framework. <a href="https://githacks.org/vmp2/vmhook">VMHook</a> is not used to uncover virtual instructions and their functionality, rather to alter them.</p>
<p><a href="#um-hook-overview" id="um-hook-overview"><h4>VMHook - Example, um-hook</h4></a></p>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">.data</span>
	<span style="color:#a6e22e">__mbase</span> dq <span style="color:#ae81ff">0h</span>
	<span style="color:#a6e22e">public</span> __mbase

<span style="color:#a6e22e">.code</span>
<span style="color:#a6e22e">__lconstbzx</span> proc
	<span style="color:#a6e22e">mov</span> al, [rsi]
	<span style="color:#a6e22e">lea</span> rsi, [rsi<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
	<span style="color:#a6e22e">xor</span> al, bl
	<span style="color:#a6e22e">dec</span> al
	<span style="color:#a6e22e">ror</span> al, <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">neg</span> al
	<span style="color:#a6e22e">xor</span> bl, al

	<span style="color:#a6e22e">pushfq</span>			<span style="color:#75715e">; save flags...</span>
	<span style="color:#a6e22e">cmp</span> ax, <span style="color:#ae81ff">01Ch</span>
	<span style="color:#a6e22e">je</span> swap_val

					<span style="color:#75715e">; the constant is not 0x1C</span>
	<span style="color:#a6e22e">popfq</span>			<span style="color:#75715e">; restore flags...	 </span>
	<span style="color:#a6e22e">sub</span> rbp, <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">mov</span> [rbp], ax
	<span style="color:#a6e22e">mov</span> rax, __mbase
	<span style="color:#a6e22e">add</span> rax, <span style="color:#ae81ff">059FEh</span>	<span style="color:#75715e">; calc jmp rva is 0x59FE...</span>
	<span style="color:#a6e22e">jmp</span> rax

swap_val:			<span style="color:#75715e">; the constant is 0x1C</span>
	<span style="color:#a6e22e">popfq</span>			<span style="color:#75715e">; restore flags...</span>
	<span style="color:#a6e22e">mov</span> ax, <span style="color:#ae81ff">5</span>		<span style="color:#75715e">; bit 5 is VMX in ECX after CPUID...</span>
	<span style="color:#a6e22e">sub</span> rbp, <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">mov</span> [rbp], ax
	<span style="color:#a6e22e">mov</span> rax, __mbase
	<span style="color:#a6e22e">add</span> rax, <span style="color:#ae81ff">059FEh</span>	<span style="color:#75715e">; calc jmp rva is 0x59FE...</span>
	<span style="color:#a6e22e">jmp</span> rax
<span style="color:#a6e22e">__lconstbzx</span> endp
<span style="color:#a6e22e">end</span>
</code></pre></div><p>um-hook is a project which inherits VMHook, it demonstrates <a href="https://githacks.org/vmp2/um-hook/-/blob/fbb3a7d0ebc54337cdacdb59f78bacf634783702/src/um-hook/lconstbzx.asm">hooking the LCONSTBZX virtual instruction</a> and spoofing its immediate value. This subsequently affects the later virtual shift functions result, which ultimately results in the virtual routine returning true instead of false.</p>
<p><a href="#vmprofiler-overview" id="vmprofiler-overview"><h3>VMProfiler - Overview</h3></a></p>
<hr>
<p><a href="https://githacks.org/vmp2/vmprofiler">VMProfiler</a> is a C++ library which is used for static analysis of VMProtect 2 binaries. This is the base project for <a href="https://githacks.org/vmp2/vmprofiler-qt">VMProfiler Qt</a>, <a href="https://githacks.org/vmp2/vmprofiler-cli">VMProfiler CLI</a>, <a href="https://githacks.org/vmp2/vmemu">VMEmu</a>, and <a href="https://githacks.org/vmp2/vmassembler">VMAssembler</a>. <a href="https://githacks.org/vmp2/vmprofiler">VMProfiler</a> also inherits <a href="https://github.com/vtil-project/VTIL-Core">VTIL</a> and contains virtual machine handler profiles and lifters.</p>
<p><a href="#vmprofiler-virtual-machine-handler-profiling" id="vmprofiler-virtual-machine-handler-profiling"><h4>VMProfiler - Virtual Machine Handler Profiling</h4></a></p>
<hr>
<p>Virtual machine handlers are found and categorized via a pattern matching algorithm. <a href="https://githacks.org/vmp2/vmprofiler/-/blob/cd8b79f28ba7e43d323cf6ad48596979dc57b881/include/vmprofiler.hpp#L23">The first iteration of this algorithm</a> simply compared the native instructions bytes. However this has proven to be ineffective as changes to the native instruction which don&rsquo;t result in a different outcome but do change the native instructions bytes will cause the algorithm to miscatagorize or even fail to recongnize virtual machine handlers. Consider the following instruction variants, all of which when executed have the same result but each has their own unique sequence of bytes.</p>
<pre><code>0:  36 48 8b 00             mov    rax,QWORD PTR ss:[rax]
4:  48 8b 00                mov    rax,QWORD PTR [rax] 
0:  36 48 8b 04 05 00 00    mov    rax,QWORD PTR ss:[rax*1+0x0]
7:  00 00 
</code></pre><p>In order to handle such cases, a <a href="https://githacks.org/vmp2/vmprofiler/-/blob/ebfc4f421e029af1b276c4caef47bee4c710ec3f/src/vmprofiles">new iteration of the profiling algorithm</a> has been designed and implemented. This new rendition still pattern matches, however for each instruction of a virtual machine handler a lambda is defined. This lambda takes in a <a href="https://zyantific.com/doc/zydis/struct_zydis_decoded_instruction__.html">ZydisDecodedInstruction</a> parameter, by reference, and returns a boolean. The result being true if a given decoded instruction meets all of the comparison cases. The usage of <a href="https://github.com/zyantific/zydis">zydis</a> for this purpose allows for one to compare operands at a much finer level. For example, operand two from both instructions in the figure above is of type <code>ZYDIS_OPERAND_TYPE_MEMORY</code>. In addition, the base of this memory operand for both instructions is <code>RAX</code>. The mnemonic of both instructions is the same. This sort of minimalist comparison thinking is what this rendition of the profiling algorithm is based off of.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>profile_t readq <span style="color:#f92672">=</span> {
    <span style="color:#75715e">// MOV RAX, [RAX]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// MOV [RBP], RAX
</span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;READQ&#34;</span>,
    READQ,
    NULL,
    { { <span style="color:#75715e">// MOV RAX, [RAX]
</span><span style="color:#75715e"></span>        []( <span style="color:#66d9ef">const</span> zydis_decoded_instr_t <span style="color:#f92672">&amp;</span>instr ) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
            <span style="color:#66d9ef">return</span> instr.mnemonic <span style="color:#f92672">==</span> ZYDIS_MNEMONIC_MOV <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">0</span> ].type <span style="color:#f92672">==</span> ZYDIS_OPERAND_TYPE_REGISTER <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">0</span> ].reg.value <span style="color:#f92672">==</span> ZYDIS_REGISTER_RAX <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">1</span> ].type <span style="color:#f92672">==</span> ZYDIS_OPERAND_TYPE_MEMORY <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">1</span> ].mem.base <span style="color:#f92672">==</span> ZYDIS_REGISTER_RAX;
        },
        <span style="color:#75715e">// MOV [RBP], RAX
</span><span style="color:#75715e"></span>        []( <span style="color:#66d9ef">const</span> zydis_decoded_instr_t <span style="color:#f92672">&amp;</span>instr ) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
            <span style="color:#66d9ef">return</span> instr.mnemonic <span style="color:#f92672">==</span> ZYDIS_MNEMONIC_MOV <span style="color:#f92672">&amp;&amp;</span> 
            	   instr.operands[ <span style="color:#ae81ff">0</span> ].type <span style="color:#f92672">==</span> ZYDIS_OPERAND_TYPE_MEMORY <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">0</span> ].mem.base <span style="color:#f92672">==</span> ZYDIS_REGISTER_RBP <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">1</span> ].type <span style="color:#f92672">==</span> ZYDIS_OPERAND_TYPE_REGISTER <span style="color:#f92672">&amp;&amp;</span>
                   instr.operands[ <span style="color:#ae81ff">1</span> ].reg.value <span style="color:#f92672">==</span> ZYDIS_REGISTER_RAX;
        } } } };
</code></pre></div><p>In the figure above, the <a href="https://blog.back.engineering/17/05/2021/#READQ">READQ</a> profile is displayed. Notice that not every single instruction for a virtual machine handler must have a zydis lambda for it. Only enough for a unique profile to be constructed for it. There are in fact additional native instructions for <a href="https://blog.back.engineering/17/05/2021/#READQ">READQ</a> which are not accounted for with zydis comparison lambdas.</p>
<p><a href="#vmprofiler-virtual-branch-detection-algorithm" id="vmprofiler-virtual-branch-detection-algorithm"><h4>VMProfiler - Virtual Branch Detection Algorithm</h4></a></p>
<hr>
<p>The most glaring consistency in a virtual branch is the usage of <a href="https://blog.back.engineering/17/05/2021/#PUSHVSP">PUSHVSP</a>. This virtual instruction is executed when two encrypted values are on the stack at <code>VSP + 0</code>, and <code>VSP + 8</code>. These encrypted values are decrypted using the last <a href="https://blog.back.engineering/17/05/2021/#LCONSTDW">LCONSTDW</a> value of a given block. Thus a trivially small algorithm can be created based upon these two consistencies. The first part of the algorithm will simply use <code>std::find_if</code> with reverse iterators to locate the last <a href="https://blog.back.engineering/17/05/2021/#LCONSTDW">LCONSTDW</a> in a given code block. This DWORD value will be interpreted as the XOR key used to decrypt the encrypted relative virtual addresses of both branches. A second <code>std::find_if</code> is now executed to locate a <a href="https://blog.back.engineering/17/05/2021/#PUSHVSP">PUSHVSP</a> virtual instruction that when executed, two encrypted relative virtual addresses will be located on the stack. The algorithm will interpret the top two stack values of every <a href="https://blog.back.engineering/17/05/2021/#PUSHVSP">PUSHVSP</a> instruction as encrypted relative virtual addresses and apply an XOR operation with the last <a href="https://blog.back.engineering/17/05/2021/#LCONSTDW">LCONSTDW</a> value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span> jcc_data <span style="color:#f92672">&gt;</span> get_jcc_data( vm<span style="color:#f92672">::</span>ctx_t <span style="color:#f92672">&amp;</span>vmctx, code_block_t <span style="color:#f92672">&amp;</span>code_block )
{
    <span style="color:#75715e">// there is no branch for this as this is a vmexit...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( code_block.vinstrs.back().mnemonic_t <span style="color:#f92672">==</span> vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>VMEXIT )
        <span style="color:#66d9ef">return</span> {};

    <span style="color:#75715e">// find the last LCONSTDW... the imm value is the JMP xor decrypt key...
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// we loop backwards here (using rbegin and rend)...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>find_if( code_block.vinstrs.rbegin(), code_block.vinstrs.rend(),
                                []( <span style="color:#66d9ef">const</span> vm<span style="color:#f92672">::</span>instrs<span style="color:#f92672">::</span>virt_instr_t <span style="color:#f92672">&amp;</span>vinstr ) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
                                    <span style="color:#66d9ef">auto</span> profile <span style="color:#f92672">=</span> vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>get_profile( vinstr.mnemonic_t );
                                    <span style="color:#66d9ef">return</span> profile <span style="color:#f92672">&amp;&amp;</span> profile<span style="color:#f92672">-&gt;</span>mnemonic <span style="color:#f92672">==</span> vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>LCONSTDW;
                                } );

    jcc_data jcc;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> xor_key <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">&gt;</span>( result<span style="color:#f92672">-&gt;</span>operand.imm.u );
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>last_trace <span style="color:#f92672">=</span> code_block.vinstrs.back().trace_data;

    <span style="color:#75715e">// since result is already a variable and is a reverse itr
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// i&#39;m going to be using rbegin and rend here again...
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// look for PUSHVSP virtual instructions with two encrypted virtual
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// instruction rva&#39;s ontop of the virtual stack...
</span><span style="color:#75715e"></span>    result <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>find_if(
        code_block.vinstrs.rbegin(), code_block.vinstrs.rend(),
        [ <span style="color:#f92672">&amp;</span> ]( <span style="color:#66d9ef">const</span> vm<span style="color:#f92672">::</span>instrs<span style="color:#f92672">::</span>virt_instr_t <span style="color:#f92672">&amp;</span>vinstr ) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
            <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">auto</span> profile <span style="color:#f92672">=</span> vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>get_profile( vinstr.mnemonic_t );
                 profile <span style="color:#f92672">&amp;&amp;</span> profile<span style="color:#f92672">-&gt;</span>mnemonic <span style="color:#f92672">==</span> vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>PUSHVSP )
            {
                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> possible_block_1 <span style="color:#f92672">=</span> code_block_addr( vmctx, 
                		vinstr.trace_data.vsp.qword[ <span style="color:#ae81ff">0</span> ] <span style="color:#f92672">^</span> xor_key ),
                           possible_block_2 <span style="color:#f92672">=</span> code_block_addr( vmctx, 
                        vinstr.trace_data.vsp.qword[ <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">^</span> xor_key );

                <span style="color:#75715e">// if this returns too many false positives we might have to get
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// our hands dirty and look into trying to emulate each branch
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// to see if the first instruction is an SREGQ...
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> possible_block_1 <span style="color:#f92672">&gt;</span> vmctx.module_base <span style="color:#f92672">&amp;&amp;</span>
                       possible_block_1 <span style="color:#f92672">&lt;</span> vmctx.module_base <span style="color:#f92672">+</span> vmctx.image_size <span style="color:#f92672">&amp;&amp;</span>
                       possible_block_2 <span style="color:#f92672">&gt;</span> vmctx.module_base <span style="color:#f92672">&amp;&amp;</span>
                       possible_block_2 <span style="color:#f92672">&lt;</span> vmctx.module_base <span style="color:#f92672">+</span> vmctx.image_size;
            }
            <span style="color:#66d9ef">return</span> false;
        } );

    <span style="color:#75715e">// if there are not two branches...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( result <span style="color:#f92672">==</span> code_block.vinstrs.rend() )
    {
        jcc.block_addr[ <span style="color:#ae81ff">0</span> ] <span style="color:#f92672">=</span> code_block_addr( vmctx, last_trace );
        jcc.has_jcc <span style="color:#f92672">=</span> false;
        jcc.type <span style="color:#f92672">=</span> jcc_type<span style="color:#f92672">::</span>absolute;
    }
    <span style="color:#75715e">// else there are two branches...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
    {
        jcc.block_addr[ <span style="color:#ae81ff">0</span> ] <span style="color:#f92672">=</span> code_block_addr( vmctx, 
        	result<span style="color:#f92672">-&gt;</span>trace_data.vsp.qword[ <span style="color:#ae81ff">0</span> ] <span style="color:#f92672">^</span> xor_key );
        jcc.block_addr[ <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">=</span> code_block_addr( vmctx, 
        	result<span style="color:#f92672">-&gt;</span>trace_data.vsp.qword[ <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">^</span> xor_key );

        jcc.has_jcc <span style="color:#f92672">=</span> true;
        jcc.type <span style="color:#f92672">=</span> jcc_type<span style="color:#f92672">::</span>branching;
    }

    <span style="color:#66d9ef">return</span> jcc;
}
</code></pre></div><p><em>Note: the underlying flag in which the virtual branch is dependent on is not extracted using this algorithm. This is one of the negative aspects of this algorithm as it stands.</em></p>
<p><a href="#vmprofiler-qt-overview" id="vmprofiler-qt-overview"><h3>VMProfiler Qt - Overview</h3></a></p>
<hr>
<img src="/vmprotect-2-part-two/vmprofiler-qt.png"/>
<p><a href="https://githacks.org/vmp2/vmprofiler-qt">VMProfiler Qt</a> is a small C++ Qt based GUI that allows for inspection of virtual instruction traces. These traces are generated via <a href="https://githacks.org/vmp2/vmemu">VMEmu</a> and contain all information for every virtual instruction. The GUI contains a window for virtual register values, native register values, the virtual stack, virtual instructions, expandable virtual branches, and lastly a tab containing all virtual machine handlers and their native instructions, and transformations.</p>
<p><a href="#vmprofiler-cli-overview" id="vmprofiler-cli-overview"><h3>VMProfiler CLI - Overview</h3></a></p>
<hr>
<p><a href="https://githacks.org/vmp2/vmprofiler-cli">VMProfiler CLI</a> is a command line project which is used to demonstrate all VMProfiler features. This project only consists of a single file (<a href="https://githacks.org/vmp2/vmprofiler-cli/-/blob/93b14609ed8a0ca72fa9a0ac3bd2589703780135/src/main.cpp">main.cpp</a>), however it&rsquo;s a good reference for those who are interested in inheriting VMProfiler as their code base.</p>
<pre><code>Usage: vmprofiler-cli [options...]
Options:
    --bin, --vmpbin        unpacked binary protected with VMProtect 2
    --vmentry, --entry     rva to push prior to a vm_entry
    --showhandlers         show all vm handlers...
    --showhandler          show a specific vm handler given its index...
    --vmp2file             path to .vmp2 file...
    --showblockinstrs      show the virtual instructions of a specific code block...
    --showallblocks        shows all information for all code blocks...
    --devirt               lift to VTIL IR and apply optimizations, then display the output...
    -h, --help             Shows this page
</code></pre><p><a href="#vmemu-overview" id="vmemu-overview"><h3>VMEmu - Overview</h3></a></p>
<hr>
<p><a href="https://githacks.org/vmp2/vmemu">VMEmu</a> is a <a href="https://github.com/unicorn-engine/unicorn">unicorn-engine</a> based project which emulates virtual machine handlers to subsequently decrypt virtual instruction operands. <a href="https://githacks.org/vmp2/vmemu">VMEmu</a> inherits <a href="https://githacks.org/vmp2/vmprofiler">VMProfiler</a> which aids in determining if a given code block has a virtual JCC in it. <a href="https://githacks.org/vmp2/vmemu">VMEmu</a> does not currently support dumped modules as “dumped modules” can take many forms. There is not one standard file format for a dumped module so support for dumped modules will come with another <a href="https://github.com/unicorn-engine/unicorn">unicorn-engine</a> based project to produce a standard dump format.</p>
<pre><code>Usage: vmemu [options...]
Options:
    --vmentry              relative virtual address to a vm entry... (Required)
    --vmpbin               path to unpacked virtualized binary... (Required)
    --out                  output file name for trace file... (Required)
    -h, --help             Shows this page
</code></pre><p><a href="#vmemu-unicorn-engine-static-decryption-of-opcodes" id="vmemu-unicorn-engine-static-decryption-of-opcodes"><h4>VMEmu - Unicorn Engine, Static Decryption Of Opcodes</h4></a></p>
<hr>
<p>In order to statically decrypt virtual instruction operands, one must first understand how these operands are encrypted in the first place. The algorithm VMProtect 2 uses to encrypt virtual instruction operands can be represented as a mathematical formula.</p>
<div style="overflow-x: scroll;" class="box">
$$\text{Let } F_n \text{ be an encryption function and } T_{m,F_n} \text{denote the } m\text{th transformation of function } F_n:$$
$$F_0(e, o) = T_{4, F_0} \circ T_{3, F_0}\circ T_{2, F_0} \circ T_{1, F_0} \circ T_{0, F_0}(e, o)$$
$$ G_0(e, o) = T_{1, F_0}(F_0(e, o), e) $$
$$\text{Thus:}$$
$$\text{key}_{n+1} = G_n(\text{key}_n, \text{operand}_n)$$
$$\text{operand}_{n+1} = F_n(\text{key}_n, \text{operand}_n)$$
$$\text{Furthermore:}$$
$$T_{m, F_n} \text{ maps to a given vm::transformation::type such that } T_{0, F_n} = \text {vm::transform::type::generic\textunderscore0},$$
$$T_{1, F_n} = \text{ vm::transform::type::rolling\textunderscore key }, …, T_{6, F_n} = \text{ vm::transform::type::update\textunderscore key }$$
</div>
<p>Considering the above figure, decryption of operands is merely the inverse of function $F$. This inverse is generated into native x86_64 instructions and embedded into each virtual machine handler as well as calc_jmp. One could simply emulate these instructions via reimplementation of them in C/C++, however my implementation of such instructions is merely for the purpose of encryption, not decryption. Instead, the usage of <a href="https://github.com/unicorn-engine/unicorn">unicorn-engine</a> is preferred in this situation as by simply emulating these virtual machine handlers, decrypted operands will be produced.</p>
<p>Understand that no runtime value can possibly affect the decryption of operands, thus invalid memory accesses can be ignored. However, runtime values can alter which virtual instruction blocks are decrypted, thus the need for saving the context of the emulated CPU prior to execution of a branching virtual instruction. This will allow for restoring the state of the emulated CPU prior to the branching instruction, but additionally altering which branch the emulated CPU will take, allowing for complete decryption of all virtual instruction blocks statically.</p>
<p>To reiterate, the usage of unicorn-engine is for computing $F(e, o)$ and $G(e, o)$ where $e$ takes the form of the native register $RBX$, $o$ takes the form of the native register $RAX$, and $T_{m, F_n}$ takes the form of transformation $m$th.</p>
<p>In addition, not only can decrypted operands be obtained using unicorn-engine, but views of the virtual stack can be snapshotted for every single virtual instruction. This allows for algorithms to take advantage of values that are on the stack. Calls to native WinAPI’s are done outside of the virtual machine, except for rare cases such as the VMProtect 2 packer virtual machine handler which calls <code>LoadLibrary</code> with a pointer to the string &ldquo;NTDLL.DLL&rdquo; in <code>RCX</code>.</p>
<p><a href="#vmemu-virtual-branching" id="vmemu-virtual-branching"><h4>VMEmu - Virtual Branching</h4></a></p>
<hr>
<p>Seeing all code paths is extremely important. Consider the most basic situation where a parameter is checked to see if it&rsquo;s a nullptr.</p>
<pre><code>auto demo(int* a)
{
    if (!a)
        return {};

    // more code down here
}
</code></pre><p>Analysis of the above code without being able to see all code paths would result in something useless. Thus seeing all branches inside of the virtual machine was the top priority. In this section I will detail how virtual branching works inside of the VMProtect 2 virtual machine, as well as the algorithms I’ve designed to recognize and analyze all paths.</p>
<p>To begin, not all code blocks end with a branching virtual instruction. Some end with virtual machine exit’s, or absolute jumps. Thus the need for an algorithm which can determine if a given virtual instruction block will branch or not. In order to produce such an algorithm, intimate knowledge of the virtual machine branching mechanism is required, specifically how <a href="https://www.felixcloutier.com/x86/jcc">native JCC’s</a> are translated to virtual instructions.</p>
<p>Consider the possible affected flag bits of the <a href="https://www.felixcloutier.com/x86/add">native ADD</a> instruction. Flags <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, <code>CF</code>, and <code>PF</code> can all be affected depending on the computation. Native branching is done via <a href="https://www.felixcloutier.com/x86/jcc">JCC instructions</a> which depend upon the state of a specific flag or flags.</p>
<pre><code>test rax, rax
jz branch_1
</code></pre><p><em>Figure 2.</em></p>
<p>Consider figure 2, understand that the <code>JZ</code> native instruction will jump to “branch_1” if the <code>ZF</code> flag is set. One could reimplement figure 2 in such a way that only the <a href="https://www.felixcloutier.com/x86/jmp">native JMP</a> instruction and a few other math and stack operations could be used. Reducing the number of branching instructions to a single <a href="https://www.felixcloutier.com/x86/jmp">native JMP</a> instruction.</p>
<p>Consider that the <a href="https://www.felixcloutier.com/x86/test">native TEST</a> instruction performs a bitwise <code>AND</code> on both operands, sets flags accordingly, and disregards the <code>AND</code> result. One could simply replace the <a href="https://www.felixcloutier.com/x86/test">native TEST</a> instruction with a few stack operations and the <a href="https://www.felixcloutier.com/x86/and">native AND</a> instruction.</p>
<pre><code>0:  50                      push   rax
1:  48 21 c0                and    rax,rax
4:  9c                      pushf
5:  48 83 24 24 40          and    QWORD PTR [rsp],0x40
a:  48 c1 2c 24 03          shr    QWORD PTR [rsp],0x3
f:  58                      pop    rax
10: ff 34 25 00 00 00 00    push   branch_1
17: ff 34 25 00 00 00 00    push   branch_2
1e: 48 8b 04 04             mov    rax,QWORD PTR [rsp+rax*1]
22: 48 83 c4 10             add    rsp,0x10
26: 48 89 44 24 f8          mov    QWORD PTR [rsp-0x8],rax
2b: 58                      pop    rax
2c: ff 64 24 f0             jmp    QWORD PTR [rsp-0x10]
</code></pre><p><em>Figure 3.</em>
<em>Note: bittest/test is not used here as it is implemented via AND, and SHR.</em></p>
<p>Although it may seem that converting a single instruction into multiple may be counterproductive and requiring more work in the end, this is not the case as these instructions will be reused in other orientations. Reimplementation of all JCC instructions could be done quite simply using the above assembly code template. Even such branching instructions as the <code>JRCXZ</code>, <code>JECXZ</code>, and <code>JCXZ</code> instructions could be implemented by simply swapping <code>RAX</code> with <code>RCX</code>/<code>EAX</code>/<code>CX</code> in the above example.</p>
<p>Figure 3, although in native x86_64, provides a solid example of how VMProtect 2 does branching inside of the virtual machine. However, VMProtect 2 adds additional obfuscation via math obfuscation. Firstly, both addresses pushed onto the stack are encrypted relative virtual addresses. These addresses are decrypted via XOR. Although XOR, SUB, and other math operations themselves are obfuscated into NAND operations.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#75715e">; push encrypted relative virtual addresses onto the stack...</span>
<span style="color:#a6e22e">LCONSTQ</span> <span style="color:#ae81ff">0x19edc194</span>
<span style="color:#a6e22e">LCONSTQ</span> <span style="color:#ae81ff">0x19ed8382</span>
<span style="color:#a6e22e">PUSHVSP</span>

<span style="color:#75715e">; calculate which branch will be executed, then read its encrypted address on the stack...</span>
<span style="color:#a6e22e">LCONSTBZXW</span> <span style="color:#ae81ff">0x3</span>
<span style="color:#a6e22e">LCONSTBSXQ</span> <span style="color:#ae81ff">0xbf</span>
<span style="color:#a6e22e">LREGQ</span> <span style="color:#ae81ff">0x80</span>
<span style="color:#a6e22e">NANDQ</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x68</span>
<span style="color:#a6e22e">SHRQ</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x70</span>
<span style="color:#a6e22e">ADDQ</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x48</span>
<span style="color:#a6e22e">READQ</span>

<span style="color:#75715e">; clear the stack of encrypted addresses...</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x68</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x70</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x90</span>

<span style="color:#75715e">; put the selected branch encrypted address back onto the stack...</span>
<span style="color:#a6e22e">LREGQ</span> <span style="color:#ae81ff">0x68</span>
<span style="color:#a6e22e">LREGQ</span> <span style="color:#ae81ff">0x68</span>

<span style="color:#75715e">; xor value on top of the stack with 59f6cb36</span>
<span style="color:#a6e22e">LCONSTDW</span> <span style="color:#ae81ff">0xa60934c9</span>
<span style="color:#a6e22e">NANDDW</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x48</span>
<span style="color:#a6e22e">LCONSTDW</span> <span style="color:#ae81ff">0x59f6cb36</span>
<span style="color:#a6e22e">LREGDW</span> <span style="color:#ae81ff">0x68</span>
<span style="color:#a6e22e">NANDDW</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x48</span>
<span style="color:#a6e22e">NANDDW</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x90</span>
<span style="color:#a6e22e">SREGQ</span> <span style="color:#ae81ff">0x70</span>

<span style="color:#75715e">; removed virtual instructions...</span>
<span style="color:#75715e">; …</span>

<span style="color:#75715e">; load the decrypted relative virtual address and jmp...</span>
<span style="color:#a6e22e">LREGQ</span> <span style="color:#ae81ff">0x70</span>
<span style="color:#a6e22e">JMP</span>
</code></pre></div><p><em>Figure 4.</em></p>
<p>As discussed prior, VMProtect 2 uses the XOR operation to decrypt and subsequently encrypt the relative virtual addresses pushed onto the stack. Selection of a specific encrypted relative virtual address is done by shifting a given flag to result in its value being either zero or eight. Then, adding <code>VSP</code> to the resulting shift computes the address in which the encrypted relative virtual address is located.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define FIRST_CONSTANT a60934c9
</span><span style="color:#75715e">#define SECOND_CONSTANT 59f6cb36
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">jcc_decrypt</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> encrypted_rva)
{
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>encrypted_rva <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>encrypted_rva;
    result <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>result <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>FIRST_CONSTANT;
    result <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>(<span style="color:#f92672">~</span>encrypted_rva <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>SECOND_CONSTANT) <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>result;
    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><p><em>Figure 5. Note: Notice that <code>FIRST_CONSTANT</code> and <code>SECOND_CONSTANT</code> are inverses of each other.</em></p>
<p><a href="#vmassembler-overview" id="vmassembler-overview"><h3>VMAssembler - Overview</h3></a></p>
<hr>
<p><a href="https://githacks.org/vmp2/vmassembler">VMAssembler</a> is a virtual instruction assembler project originally contemplated as a joke. Regardless of its significance to anything, it is a fun project that allows for an individual to become more acquainted with the features of VMProtect 2. <a href="https://githacks.org/vmp2/vmassembler">VMAssembler</a> uses <a href="https://en.wikipedia.org/wiki/Lex_(software)">LEX</a> and <a href="https://en.wikipedia.org/wiki/Yacc">YACC</a> to parse text files for labels and virtual instruction tokens. It then encodes and encrypts these virtual instructions based upon the specific virtual machine specified via the command line. Finally a C++ header file is generated which contains the assembled virtual instructions as well as the original VMProtect’ed binary.</p>
<p><a href="#vmassembler-assembler-stages" id="vmassembler-assembler-stages"><h4>VMAssembler - Assembler Stages</h4></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/vmassembler-overview.png"/></center>
<p><a href="https://githacks.org/vmp2/vmassembler">VMAssembler</a> uses <a href="https://en.wikipedia.org/wiki/Lex_(software)">LEX</a> and <a href="https://en.wikipedia.org/wiki/Yacc">YACC</a> to parse text files for virtual instruction names and immediate values. There are four main stages to VMAssembler, lexical analysis and parsing, virtual instruction encoding, virtual instruction encryption, and lastly C++ code generation.</p>
<p><a href="#vmassembler-stage-one" id="vmassembler-stage-one"><h4>VMAssembler - Stage One, Lexical Analysis and Parsing</h4></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/vmassembler-stage-one-overview.png"/></center>
<p>Lexical analysis and token parsing are two stages themselves, however I will be referring to these stages as one as the result of these is data structures manageable by C++.</p>
<p>The first stage of VMAssembler is almost entirely handled by <a href="https://en.wikipedia.org/wiki/Lex_(software)">LEX</a> and <a href="https://en.wikipedia.org/wiki/Yacc">YACC</a>. Text is converted into C++ structures representing virtual instructions. These structures are referred to as <a href="https://docs.back.engineering/vmassembler/struct__vinstr__meta.html">_vinstr_meta</a> and <a href="https://docs.back.engineering/vmassembler/struct__vlabel__meta.html">_vlable_meta</a>. These structures are then used by stage two to validate virtual instructions existence, as well as encoding these higher level representations of virtual instructions into decrypted virtual operands.</p>
<p><a href="#vmassembler-stage-two" id="vmassembler-stage-two"><h4>VMAssembler - Stage Two, Virtual Instruction Encoding</h4></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/vmassembler-stage-two-overview.png"/></center>
<p>Virtual instruction encoding stage of assembling also validates the existence of all virtual instructions for each virtual label. This is done by comparing profiled vm handler names with the virtual instruction name token. If a virtual instruction does not exist then assembling will cease.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>parse_t<span style="color:#f92672">::</span>get_instance()<span style="color:#f92672">-&gt;</span>for_each( [ <span style="color:#f92672">&amp;</span> ]( _vlabel_meta <span style="color:#f92672">*</span>label_data ) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
         std<span style="color:#f92672">::</span>printf( <span style="color:#e6db74">&#34;&gt; checking label %s for invalid instructions... number of instructions = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
                      label_data<span style="color:#f92672">-&gt;</span>label_name.c_str(), label_data<span style="color:#f92672">-&gt;</span>vinstrs.size() );

         <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>find_if(
             label_data<span style="color:#f92672">-&gt;</span>vinstrs.begin(), label_data<span style="color:#f92672">-&gt;</span>vinstrs.end(),
             [ <span style="color:#f92672">&amp;</span> ]( <span style="color:#66d9ef">const</span> _vinstr_meta <span style="color:#f92672">&amp;</span>vinstr ) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
                 std<span style="color:#f92672">::</span>printf( <span style="color:#e6db74">&#34;&gt; vinstr name = %s, has imm = %d, imm = 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, vinstr.name.c_str(),
                              vinstr.has_imm, vinstr.imm );

                 <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>vm_handler : vmctx<span style="color:#f92672">-&gt;</span>vm_handlers )
                     <span style="color:#66d9ef">if</span> ( vm_handler.profile <span style="color:#f92672">&amp;&amp;</span> vm_handler.profile<span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">==</span> vinstr.name )
                         <span style="color:#66d9ef">return</span> false;

                 std<span style="color:#f92672">::</span>printf( <span style="color:#e6db74">&#34;[!] this vm protected file does not have the vm handler for: %s...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
                              vinstr.name.c_str() );

                 <span style="color:#66d9ef">return</span> true;
             } );

         <span style="color:#66d9ef">return</span> result <span style="color:#f92672">==</span> label_data<span style="color:#f92672">-&gt;</span>vinstrs.end();
     } ) )
{
    std<span style="color:#f92672">::</span>printf( <span style="color:#e6db74">&#34;[!] binary does not have the required vm handlers...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> );
    exit( <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> );
}
</code></pre></div><p>Once all virtual instruction IL is validated, encoding of these virtual instructions can commence. The order in which the virtual instruction pointer advances is important to note throughout the process of encoding and encrypting. The direction dictates the ordering of operands and virtual instructions.</p>
<p><a href="#vmassembler-stage-three" id="vmassembler-stage-three"><h4>VMAssembler - Stage Three, Virtual Instruction Encryption</h4></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/vmassembler-stage-three-overview.png"/></center>
<p>Just like stage two of assembly, stage three must also take into consideration which way the virtual instruction pointer advances. This is because operands must be encrypted in an order based upon the direction of VIP’s advancement. The encryption key produced by the last operands encryption is used for the starting encryption key for the next as detailed in <a href="#vmemu-unicorn-engine-static-decryption-of-opcodes">“VMEmu - Unicorn Engine, Static Decryption Of Opcodes”</a>.</p>
<p>This stage will do $F^{-1}(e, o)$ and $G^{-1}(e, o)$ for each virtual instruction operand of each label. Lastly, the relative virtual address from vm_entry to the first operand of the first virtual instruction is calculated and then encrypted using the inverse transformations used to decrypt the relative virtual address to the virtual instructions themselves. You can find more details about these transformations inside of the <a href="https://blog.back.engineering/17/05/2021/#vm_entry">vm_entry section of the last article</a>.</p>
<p><a href="#vmassembler-stage-four" id="vmassembler-stage-four"><h4>VMAssembler - Stage Four, C++ Header Generation</h4></a></p>
<hr>
<center><img src="/vmprotect-2-part-two/vmassembler-stage-four-overview.png"/></center>
<p>Stage four is the final stage of virtual instruction assembly. In this stage C++ code is generated. The code is completely self contained and environment agnostic. However, there are a few limitations to the current implementation. Most glaring is the need for a RWX (read, write, and executable) section. If one were to use this generated C++ code in a Windows kernel driver then the driver would not support HVCI systems. Also, as of 6/19/2021, MSVC cannot compile the generated header as for whatever reason, the static initializer for the raw module causes the compiler to hang. You must use clang-cl if you want to compile with the generated header file from VMAssembler.</p>
<p><a href="#vmassembler-example" id="vmassembler-example"><h4>VMAssembler - Example</h4></a></p>
<hr>
<p>Once a C++ header has been generated using <a href="https://githacks.org/vmp2/vmassembler">VMAssembler</a> you can now include it into your project and compile using any compiler that is not MSVC as the MSVC compiler for some reason cannot handle such a large static initializer which the protected binary is contained in, clang-cl handles it however. Each label that you
define will be inserted into the <code>vm::calls</code> enum. The value for each enum entry is the encrypted relative virtual address to the virtual instructions of the label.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> vm
{
	<span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">calls</span> <span style="color:#f92672">:</span> u32
	{
		get_hello <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xbffd6fa5</span>,
		get_world <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xbffd6f49</span>,
	};
	
	<span style="color:#75715e">//
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span><span style="color:#75715e"></span>	
    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span> calls e_call, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Ts</span> <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">auto</span> call( <span style="color:#66d9ef">const</span> Ts... args ) <span style="color:#f92672">-&gt;</span> T
    {
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> __init_result <span style="color:#f92672">=</span> gen_data.init();

        __vmcall_t vmcall <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
        <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">auto</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0u</span>; idx <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">sizeof</span>( call_map ) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>( _pair_t<span style="color:#f92672">&lt;</span> u8, calls <span style="color:#f92672">&gt;</span> ); <span style="color:#f92672">++</span>idx )
            <span style="color:#66d9ef">if</span> ( call_map[ idx ].second <span style="color:#f92672">==</span> e_call )
                vmcall <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span> __vmcall_t <span style="color:#f92672">&gt;</span>( <span style="color:#f92672">&amp;</span>gen_data.__vmcall_shell_code[ idx ] );

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span> T <span style="color:#f92672">&gt;</span>( vmcall( args... ) );
    }
}
</code></pre></div><p>You can now call any label from your C++ code by simply specifying the <code>vm::calls</code> enum entry and the labels return type as templated params.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;test.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> hello <span style="color:#f92672">=</span> vm<span style="color:#f92672">::</span>call<span style="color:#f92672">&lt;</span> vm<span style="color:#f92672">::</span>calls<span style="color:#f92672">::</span>get_hello, vm<span style="color:#f92672">::</span>u64 <span style="color:#f92672">&gt;</span>();
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> world <span style="color:#f92672">=</span> vm<span style="color:#f92672">::</span>call<span style="color:#f92672">&lt;</span> vm<span style="color:#f92672">::</span>calls<span style="color:#f92672">::</span>get_world, vm<span style="color:#f92672">::</span>u64 <span style="color:#f92672">&gt;</span>();
	std<span style="color:#f92672">::</span>printf( <span style="color:#e6db74">&#34;&gt; %s %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ( <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> )<span style="color:#f92672">&amp;</span>hello, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>world );
}
</code></pre></div><p><em>Output</em></p>
<pre><code>&gt; hello world
</code></pre><p><a href="#vtil-getting-started" id="vtil-getting-started"><h1>VTIL - Getting Started</h1></a></p>
<hr>
<p><a href="https://github.com/vtil-project/VTIL-Core">The VTIL project</a> as it currently stands on github has some untold requirements and dependencies which are not submoduled. I have created a <a href="https://githacks.org/_xeroxz/vtil/">fork of VTIL</a> which submodule’s keystone and capstone, as well as describes the Visual Studios configurations that must be applied to a project which inherits VTIL. VTIL uses C++ 2020 features such as the <code>concept</code> keyword, thus the latest Visual Studios (2019) must be used, vs2017 is not supported. If you are compiling on a non-windows/non-visual studios environment you can ignore the last sentence.</p>
<pre><code>git clone --recursive https://githacks.org/_xeroxz/vtil.git
</code></pre><p><em>Note: maybe this will become a branch in VTIL-Core, if so, you should refer to the official VTIL-Core repository if/when that happens.</em></p>
<p>Another requirement to compile VTIL is that you must define the <code>NOMINMAX</code> macro prior to any inclusion of Windows.h as <a href="http://www.cplusplus.com/reference/limits/numeric_limits/">std::numeric_limits</a> has static member functions (max, and min). These static member function names are treated as min/max macros and thus cause compilation errors.</p>
<pre><code>#define NOMAXMIN
#include &lt;Windows.h&gt;
</code></pre><p>The last requirement has to do with dynamic initializers causing stack overflows. In order for your compiled executable containing VTIL to not crash instantly you must increase the initial stack size. I set mine to 4MB just for precaution as I have a large amount of dynamic initializers in VMProfiler.</p>
<pre><code>Linker-&gt;System-&gt;Stack Reserve Size/Stack Commit Size, set both to 4194304
</code></pre><p><a href="#vtil-the-basic-block" id="vtil-the-basic-block"><h3>VTIL - The Basic Block</h3></a></p>
<hr>
<p><a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Compiler/common/apply_all.hpp#L133">vtil::optimizer::apply_all</a> operates on the <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L61">vtil::basic_block</a> object which can be constructed by calling <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L285">vtil::basic_block::begin</a>. A <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L61">vtil::basic_block</a> contains a list of VTIL instructions which ends with a branching instruction or a <a href="https://docs.vtil.org/instruction-set/control-flow/vexit">vexit</a>. To add a new basic block linking to existing basic block’s you can call <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L290">vtil::basic_block::fork</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Creates a new block connected to this block at the given vip, if already explored returns nullptr,
</span><span style="color:#75715e">// should still be called if the caller knowns it is explored since this function creates the linkage.
</span><span style="color:#75715e">//
</span><span style="color:#75715e"></span>basic_block<span style="color:#f92672">*</span> basic_block<span style="color:#f92672">::</span>fork( vip_t entry_vip )
{
    <span style="color:#75715e">// Block cannot be forked before a branching instruction is hit.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    fassert( is_complete() );

    <span style="color:#75715e">// Caller must provide a valid virtual instruction pointer.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    fassert( entry_vip <span style="color:#f92672">!=</span> invalid_vip );

    <span style="color:#75715e">// Invoke create block.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> [blk, inserted] <span style="color:#f92672">=</span> owner<span style="color:#f92672">-&gt;</span>create_block( entry_vip, <span style="color:#66d9ef">this</span> );
    <span style="color:#66d9ef">return</span> inserted <span style="color:#f92672">?</span> blk : <span style="color:#66d9ef">nullptr</span>;
}
</code></pre></div><p><em>Note: <code>vtil::basic_block::fork</code> will assert <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/routine/basic_block.hpp#L331">is_complete</a> so ensure that your basic blocks end with a branching instruction prior to forking.</em></p>
<p>Once a basic block has been created, one can start appending VTIL instructions documented at <a href="https://docs.vtil.org/">https://docs.vtil.org/</a> to the basic block object. For every defined VTIL instruction a templated function is created using the “WRAP_LAZY” macro. You can now &ldquo;emplace_back&rdquo; any VTIL instruction with ease in your virtual machine handler lifters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">        <span style="color:#75715e">// Generate lazy wrappers for every instruction.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span><span style="color:#75715e">#define WRAP_LAZY(x)                                                     \
</span><span style="color:#75715e">        template&lt;typename... Tx&gt;                                         \
</span><span style="color:#75715e">        basic_block* x( Tx&amp;&amp;... operands )                               \
</span><span style="color:#75715e">        {                                                                \
</span><span style="color:#75715e">            emplace_back( &amp;ins:: x, std::forward&lt;Tx&gt;( operands )... );   \
</span><span style="color:#75715e">            return this;                                                 \
</span><span style="color:#75715e">        }
</span><span style="color:#75715e"></span>        WRAP_LAZY( mov );    WRAP_LAZY( movsx );    WRAP_LAZY( str );    WRAP_LAZY( ldd );
        WRAP_LAZY( ifs );    WRAP_LAZY( neg );      WRAP_LAZY( add );    WRAP_LAZY( sub );
        WRAP_LAZY( div );    WRAP_LAZY( idiv );     WRAP_LAZY( mul );    WRAP_LAZY( imul );
        WRAP_LAZY( mulhi );  WRAP_LAZY( imulhi );   WRAP_LAZY( rem );    WRAP_LAZY( irem );
        WRAP_LAZY( popcnt ); WRAP_LAZY( bsf );      WRAP_LAZY( bsr );    WRAP_LAZY( bnot );   
        WRAP_LAZY( bshr );   WRAP_LAZY( bshl );     WRAP_LAZY( bxor );   WRAP_LAZY( bor );    
        WRAP_LAZY( band );   WRAP_LAZY( bror );     WRAP_LAZY( brol );   WRAP_LAZY( tg );     
        WRAP_LAZY( tge );    WRAP_LAZY( te );       WRAP_LAZY( tne );    WRAP_LAZY( tle );    
        WRAP_LAZY( tl );     WRAP_LAZY( tug );      WRAP_LAZY( tuge );   WRAP_LAZY( tule );   
        WRAP_LAZY( tul );    WRAP_LAZY( js );       WRAP_LAZY( jmp );    WRAP_LAZY( vexit );  
        WRAP_LAZY( vemit );  WRAP_LAZY( vxcall );   WRAP_LAZY( nop );    WRAP_LAZY( sfence );
        WRAP_LAZY( lfence ); WRAP_LAZY( vpinr );    WRAP_LAZY( vpinw );  WRAP_LAZY( vpinrm );   
        WRAP_LAZY( vpinwm );
<span style="color:#75715e">#undef WRAP_LAZY
</span></code></pre></div><p><a href="#vtil-vmprofiler-lifting" id="vtil-vmprofiler-lifting"><h3>VTIL - VMProfiler Lifting</h3></a></p>
<hr>
<p>Take an example for the virtual machine handler lifter <a href="https://blog.back.engineering/17/05/2021/#LCONSTQ">LCONSTQ</a>. The lifter simply adds a VTIL push instruction which pushes a 64bit value onto the stack. Note the usage of <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Architecture/arch/operands.hpp#L40">vtil::operand</a> to create a 64bit immediate value operand.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vm<span style="color:#f92672">::</span>lifters<span style="color:#f92672">::</span>lifter_t lconstq <span style="color:#f92672">=</span> {
    <span style="color:#75715e">// push imm&lt;N&gt;
</span><span style="color:#75715e"></span>    vm<span style="color:#f92672">::</span>handler<span style="color:#f92672">::</span>LCONSTQ,
    []( vtil<span style="color:#f92672">::</span>basic_block <span style="color:#f92672">*</span>blk, vm<span style="color:#f92672">::</span>instrs<span style="color:#f92672">::</span>virt_instr_t <span style="color:#f92672">*</span>vinstr, vmp2<span style="color:#f92672">::</span>v3<span style="color:#f92672">::</span>code_block_t <span style="color:#f92672">*</span>code_blk ) {
        blk<span style="color:#f92672">-&gt;</span>push( vtil<span style="color:#f92672">::</span>operand( vinstr<span style="color:#f92672">-&gt;</span>operand.imm.u, <span style="color:#ae81ff">64</span> ) );
    } };
</code></pre></div><p>VMProfiler simply loops over all virtual instructions for a given block and applies lifters. Once all code blocks are exhausted, <a href="https://githacks.org/_xeroxz/vtil/-/blob/0d2b89a429ce5f82a9d5fbb75b4b039203cc214b/VTIL-Compiler/common/apply_all.hpp#L133">vtil::optimizer::apply_all</a> is called. This is the climax of VTIL currently as some of these optimization passes are targeted toward stack machined based obfuscation. The purpose of submodeling VTIL in vmprofiler is for these optimizations as programming these myself would take months of research. Compiler optimization is a field of its own, interesting, but not something I have the time to pursue at the moment so VTIL will suffice.</p>
<p><a href="#conclusion" id="conclusion"><h1>Conclusion - Final Words and Future Work</h1></a></p>
<hr>
<p>Although I have done much work on VMProtect 2, the main success of my endeavors has truly been statically uncovering all virtual branches and producing a legible IL. Additionally doing all of this in a, <a href="https://docs.back.engineering/vmprofiler/">well documented</a>, <a href="https://githacks.org/vmp2/vmprofiler">open source</a>, C++ library which can be inherited further by other researchers. I would not consider the work I’ve done anything close to a “finished product” or something that could be presented as such, it is merely a step in the right direction for devirtualization. The last word of the last sentence leads me to my next point.</p>
<p>Devirtualization has been avoided throughout all of my documentation and articles pertaining to my VMProtect 2 work as to me this is something that has always been out of the scope of the project. Considering I&rsquo;m a lone researcher, there are many aspects to the virtual machine architecture which could not be tackled by a single individual in a meaningful amount of time. For example, when an instruction is not virtualized by VMProtect 2, a vmexit happens and the original instruction is executed outside of the virtual machine. This means if I wanted to see an ENTIRE routine it would require me to follow code execution back out of the virtual machine and thus VMEmu would need many more months of development to support such a thing. The way that I have programmed these projects allows for multiple engineers working on the code base at a given time, except there seems to be little to no interest in open source development of these tools, even with such detailed documentation everyone wants to “make their own solution”, which is understandable, but not productive in the long run.</p>
<p>Additionally, devirtualization requires converting back to native x86_64. In order to do this, every single virtual machine handler must be profiled, every single virtual machine handler must have a VTIL lifter defined for it, and every single VTIL instruction must be mapped to a native instruction. At least this is what seems to be required with the level of knowledge I currently have, there may well be a much more elegant way of going about this that I am simply oblivious to at this time. Thus my conclusion to devirtualization: it is not a job for a single person, thus the goal of my project(s) has never been devirtualization, it&rsquo;s always been an IL view of the virtual instructions with VTIL providing deobfuscation pseudo code. The IL alone is enough for a dedicated individual to begin research, the VTIL pseudo code makes it easier for the rest of us. VMProfiler Qt combined with IDA Pro as it currently exists can be used to analyze binaries protected with VMProtect 2. It may not be a beginner friendly solution, but in my opinion, it will suffice.</p>
<p>I must note that it is not a far stretch of the mind to assume private entities have well rounded solutions for VMProtect 2. I can imagine what a team of individuals, much more skilled than myself, working on devirtualization day in and day out would produce. On top of this, considering the length of time VMProtect 2 has been public, there has been ample time for these private entities to create such tools.</p>
<p><a href="#conclusion-future-work" id="conclusion-future-work"><h3>Conclusion - Future Work</h3></a></p>
<hr>
<p>Lastly, during my research of VMProtect 2, there has been a subtle urge to reimplement some of the obfuscation and virtual machine features myself in an open source manner to better convey the features of VMProtect 2. However, after much thought, it would be more productive to create an obfuscation framework that would allow for these ideas to be created with relative ease. A framework that would handle code analysis as well as file format parsing, deconstruction, and reconstruction. Something that is lower level than an LLVM optimization pass, but high enough level that a programmer using this framework would only need to write the obfuscation algorithms themselves and would not have to even know the underlying file format. This framework would only support a single ISA, which would be x86. The details beyond this point are still being contemplated at: <a href="https://githacks.org/llo/">https://githacks.org/llo/</a></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
