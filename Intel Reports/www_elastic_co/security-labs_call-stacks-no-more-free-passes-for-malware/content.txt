<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Call Stacks: No More Free Passes For Malware — Elastic Security Labs</title><meta name="description" content="We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations."/><meta property="og:title" content="Call Stacks: No More Free Passes For Malware — Elastic Security Labs"/><meta property="og:description" content="We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/call-stacks-no-more-free-passes-for-malware/Security Labs Images 33.jpg?5c2fda8c1016768bc961f45ee623b5e2"/><meta property="og:image:alt" content="We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Call Stacks: No More Free Passes For Malware — Elastic Security Labs"/><meta name="twitter:description" content="We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/call-stacks-no-more-free-passes-for-malware/Security Labs Images 33.jpg?5c2fda8c1016768bc961f45ee623b5e2"/><meta name="twitter:image:alt" content="We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations."/><link rel="canonical" href="https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/8e9860b6e62d6359-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/0ea4f4df910e6120-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/739c2d8941231bb4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/a87fdfbf44b3f106.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/a87fdfbf44b3f106.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-e159b4ec612933fd.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-69b0767d28c674c7.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/NGlKos1fx5fmfImQxPg_q/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/NGlKos1fx5fmfImQxPg_q/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_d672da __variable_ead7f7 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-06-12T00:00:00.000Z">12 June 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/john-uhlmann">John Uhlmann</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Call Stacks: No More Free Passes For&nbsp;Malware</span></h1><p class="text-zinc-200 text-base md:text-xl">We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>19 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Call Stacks: No More Free Passes For Malware" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fcall-stacks-no-more-free-passes-for-malware%2FSecurity%20Labs%20Images%2033.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="call-stacks-provide-the-who" class="absolute -top-32"></span>Call stacks provide the who</h2>
<p>One of Elastic’s key Windows endpoint telemetry differentiators is <strong>call stacks</strong>.</p>
<p>Most detections rely on <em>what</em> is happening — and this is often insufficient as most behaviours are dual purpose. With call stacks, we add the fine-grained ability to also determine <em>who</em> is performing the activity. This combination gives us an unparalleled ability to uncover malicious activity. By feeding this deep telemetry to <a href="https://www.elastic.co/docs/reference/integrations/endpoint">Elastic Defend</a>’s on-host rule engine, we can quickly respond to emerging threats.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="call-stacks-are-a-beautiful-lie" class="absolute -top-32"></span>Call stacks are a beautiful lie</h2>
<p>In computer science, a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a> is a last-in, first-out data structure. Similar to a stack of physical items, it is only possible to add or remove the top element. A <a href="https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks">call stack</a> is a stack that contains information about the currently active subroutine calls.</p>
<p>On x64 hosts, this call stack can only be accurately generated using execution tracing features on the CPU, such as <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Pierce-Capturing-0days-With-PERFectly-Placed-Hardware-Traps-wp.pdf">Intel LBR</a>, Intel BTS, Intel AET, <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/griffin-asplos17.pdf">Intel IPT</a>, and <a href="https://lwn.net/Articles/824613/">x64 Architectural LBR</a>. These tracing features were designed for performance profiling and debugging purposes, but can be used in some security scenarios as well. However, what is more generally available is an <em>approximate</em> call stack that is recovered from a thread’s data stack via a mechanism called <a href="https://github.com/jdu2600/conference_talks/blob/main/2022-04-csidescbr-StackWalking.pdf">stack walking</a>.</p>
<p>In the <a href="https://codemachine.com/articles/x64_deep_dive.html">x64 architecture</a>, the “stack pointer register” (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rsp</code>) unsurprisingly points to a stack data structure, and there are efficient instructions to read and write the data on this stack. Additionally, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">call</code> instruction transfers control to a new subroutine but also saves a return address at the memory address referenced by the stack pointer. A <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ret</code> instruction will later retrieve this saved address so that execution can return to where it left off. Functions in most programming languages are typically implemented using these two instructions, and both function parameters and local function variables will typically be allocated on this stack for performance. The portion of the stack related to a single function is called a stack frame.</p>
<p></p>
<p>Stack walking is the recovery of just the return addresses from the heterogeneous data stored on the thread stack. Return addresses need to be stored somewhere for control flow — so stack walking co-opts this existing data to <strong>approximate</strong> a call stack. This is entirely suitable for most debugging and performance profiling scenarios, but slightly less helpful for security auditing. The main issue is that you can’t disassemble backwards. You can always determine the return address for a given call site, but not the converse. The best approach you can take is to check each of the 15 possible preceding instruction lengths and see which disassembles to exactly one call instruction. Even then, all you have recovered is a <em>previous</em> call site — not necessarily the exact <em>preceding</em> call site. This is because most compilers use <a href="https://en.wikipedia.org/wiki/Tail_call">tail call</a> optimisation to omit unnecessary stack frames. This creates <a href="https://youtu.be/9SqDY0wMmHE">annoying scenarios for security</a> like there being no guarantee that the Win32StartAddress function will be on the stack even though it was called.</p>
<p>So what we usually refer to as a call stack is actually a return address stack.</p>
<p>Malware authors use this ambiguity to lie. They either craft trampoline stack frames through legitimate modules to hide calls originating from malicious code, or they coerce stack walking into predicting different return addresses than those the CPU will execute. Of course, malware has always just been an attempt to lie, and antimalware is just the process of exposing that lie.</p>
<p>“... but at the length truth will out.”</p>
<ul>
<li>William Shakespeare, The Merchant of Venice, Act 2, Scene 2</li>
</ul>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="making-call-stacks-beautiful" class="absolute -top-32"></span>Making call stacks beautiful</h2>
<p>So far, a stack walk is just a list of numeric memory addresses. To make them useful for analysis we need to enrich them with context. (Note: we don’t currently include kernel stack frames.)</p>
<p>The minimum useful enrichment is to convert these addresses into offsets within modules (e.g. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll.dll+0x15c9c4</code>). This would only catch the most egregious malware though — we can go deeper. The most important modules on Windows are those that implement the Native and Win32 APIs. The application binary interface for these APIs requires that the name of each function be included in the <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#the-edata-section-image-only">Export Directory</a> of the containing module. This is the information that Elastic currently uses to enrich its endpoint call stacks.</p>
<p>A more accurate enrichment could be achieved by using the public symbols (if available) <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/microsoft-public-symbols">hosted</a> on the vendor’s infrastructure (especially Microsoft) While this method offers deeper fidelity, it comes with higher operational costs and isn’t feasible for our air-gapped customers.</p>
<p>A rule of thumb for Microsoft kernel and native symbols is that the exported interface of each component has a capitalised prefix such as Ldr, Tp or Rtl. Private functions extend this prefix with a p. By default, private functions with external linkage are included in the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/public-and-private-symbols">public symbol table</a>. A very large offset might indicate a very large function, but it could also just indicate an unnamed function that you don’t have symbols for. A general guideline would be to consider any triple-digit and larger offsets in an exported function as likely belonging to another function.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">Call Stack</th><th align="left">Stack Walk</th><th align="left">Stack Walk Modules</th><th align="left">Stack Walk Exports (Elastic approach)</th><th align="left">Stack Walk Public Symbols</th></tr></thead><tbody><tr><td align="left">0x7ffb8eb9c9c2 <strong>0x12d383f0046</strong> 0x7ffb8eb1a9d8 0x7ffb8eb1aaf4 0x7ffb8ea535ff 0x7ffb8da5e8cf 0x7ffb8eaf14eb</td><td align="left">0x7ffb8eb9c9c4 0x7ffb8c3c71d6 0x7ffb8eb1a9ed 0x7ffb8eb1aaf9 0x7ffb8ea53604 0x7ffb8da5e8d4 0x7ffb8eaf14f1</td><td align="left">ntdll.dll+0x15c9c4 kernelbase.dll+0xc71d6 ntdll.dll+0xda9ed ntdll.dll+0xdaaf9 ntdll.dll+0x13604 kernel32.dll+0x2e8d4 ntdll.dll+0xb14f1</td><td align="left">ntdll.dll!NtProtectVirtualMemory+0x14 kernelbase.dll!VirtualProtect+0x36 ntdll.dll!RtlAddRefActivationContext+0x40d ntdll.dll!RtlAddRefActivationContext+0x519 ntdll.dll!RtlAcquireSRWLockExclusive+0x974 kernel32.dll!BaseThreadInitThunk+0x14 ntdll.dll!RtlUserThreadStart+0x21</td><td align="left">ntdll.dll!NtProtectVirtualMemory+0x14 kernelbase.dll!VirtualProtect+0x36 ntdll.dll!RtlTpTimerCallback+0x7d ntdll.dll!TppTimerpExecuteCallback+0xa9 ntdll.dll!TppWorkerThread+0x644 kernel32.dll!BaseThreadInitThunk+0x14 ntdll.dll!RtlUserThreadStart+0x21</td></tr></tbody></table></div>
<p>Comparison of Call Stack Enrichment Levels</p>
<p>In the above example, the shellcode at 0x12d383f0000 deliberately used a tail call so that its address wouldn’t appear in the stack walk. This lie-by-omission is apparent even with only the stalk walk. Elastic reports this with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">proxy_call</code> heuristic as the malware registered a timer callback function to proxy the call to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">VirtualProtect</code> from a different thread.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="making-call-stacks-powerful" class="absolute -top-32"></span><strong>Making call stacks powerful</strong></h2>
<p>The call stacks of the system calls that we monitor with <a href="https://www.elastic.co/security-labs/kernel-etw-best-etw">Event Tracing for Windows</a> (ETW) have an expected structure. At the bottom of the stack is the thread StartAddress - typically ntdll.dll!RtlUserThreadStart. This is followed by the Win32 API thread entry - kernel32.dll!BaseThreadInitThunk and then the first user module. A user module is application code that is not part of the Win32 (or Native) API. This first user module should match the thread’s Win32StartAddress (unless that function used a tail call). More user modules will follow until the final user module makes a call into a Win32 API that makes a Native API call, which finally results in a system call to the kernel.</p>
<p>From a detection standpoint, the most important module in this call stack is the <a href="https://github.com/search?q=repo%3Aelastic%2Fprotections-artifacts+call_stack_final_user_module&amp;type=code">final user module</a>. Elastic shows this module, including its hash and any code signatures. These details aid in alert triage, but more importantly, they drastically improve the granularity at which we can baseline the behaviours of legitimate software that sometimes behaves like malware. The more accurately we can baseline normal, the harder it is for malware to blend in.</p>
<pre><code>{
  &quot;process.thread.Ext&quot;: {
    &quot;call_stack_summary&quot;: &quot;ntdll.dll|kernelbase.dll|file.dll|rundll32.exe|kernel32.dll|ntdll.dll&quot;,
    &quot;call_stack&quot;: [
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!NtAllocateVirtualMemory+0x14&quot; }, /* Native API */
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!VirtualAllocExNuma+0x62&quot; }, /* Win32 API */
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!VirtualAllocEx+0x16&quot; }, /* Win32 API */
      {
        &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.dll+0x160d8b&quot;, /* final user module */
        &quot;callsite_trailing_bytes&quot;: &quot;488bf0488d4d88e8197ee2ff488bc64883c4685b5e5f415c415d415e415f5dc390909090905541574156415541545756534883ec58488dac2490000000488b71&quot;,
        &quot;callsite_leading_bytes&quot;: &quot;088b4d38894c2420488bca48894db8498bd0488955b0458bc1448945c4448b4d3044894dc0488d4d88e8e77de2ff488b4db8488b55b0448b45c4448b4dc0ffd6&quot;
      },
      { &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.dll+0x7b429&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.dll+0x44a9&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.dll+0x5f58&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\rundll32.exe+0x3bcf&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\rundll32.exe+0x6309&quot; }, /* first user module - typically the ETHREAD.Win32StartAddress module */
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernel32.dll!BaseThreadInitThunk+0x14&quot; }, /* Win32 API */
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!RtlUserThreadStart+0x21&quot; /* Native API - the ETHREAD.StartAddress module */
      }
    ],
    &quot;call_stack_final_user_module&quot;: {
      &quot;path&quot;: &quot;c:\\users\\user\\desktop\\file.dll&quot;,
      &quot;code_signature&quot;: [ { &quot;exists&quot;: false } ],
      &quot;name&quot;: &quot;file.dll&quot;,
      &quot;hash&quot;: { &quot;sha256&quot;: &quot;0240cc89d4a76bafa9dcdccd831a263bf715af53e46cac0b0abca8116122d242&quot; }
    }
  }
}</code></pre>
<p>Sample enriched call stack</p>
<p>Call stack final user module enrichments:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">name</th><th align="left">The file name of the call_stack_final_user_module. Can also be &quot;Unbacked&quot; indicating private executable memory, or &quot;Undetermined&quot; indicating a suspicious call stack.</th></tr></thead><tbody><tr><td align="left">path</td><td align="left">The file path of the call_stack_final_user_module.</td></tr><tr><td align="left">hash.sha256</td><td align="left">The sha256 of the call_stack_final_user_module, or the protection_provenance module if any.</td></tr><tr><td align="left">code_signature</td><td align="left">Code signature of the call_stack_final_user_module, or the protection_provenance module if any.</td></tr><tr><td align="left">allocation_private_bytes</td><td align="left">The number of bytes in this memory region that are both +X and non-shareable. Non-zero values can indicate code hooking, patching, or hollowing.</td></tr><tr><td align="left">protection</td><td align="left">The memory protection for the acting region of pages is included if it is not RX. Corresponds to MEMORY_BASIC_INFORMATION.Protect.</td></tr><tr><td align="left">protection_provenance</td><td align="left">The name of the memory region that caused the last modification of the protection of this page. &quot;Unbacked&quot; may indicate shellcode.</td></tr><tr><td align="left">protection_provenance_path</td><td align="left">The path of the module that caused the last modification of the protection of this page.</td></tr><tr><td align="left">reason</td><td align="left">The anomalous call_stack_summary that led to an &quot;Undetermined&quot; protection_provenance.</td></tr></tbody></table></div>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="a-quick-call-stack-glossary" class="absolute -top-32"></span>A quick call stack glossary</h2>
<p>When examining call stacks, there are some Native API functions that are helpful to be familiar with. Ken Johnson, now of Microsoft, has provided us with a <a href="http://www.nynaeve.net/?p=200">catalog of NTDLL kernel mode to user mode callbacks</a> to get us started. Seriously, you should pause here and go read that first.</p>
<p>We met RtlUserThreadStart earlier. Both it and its sibling RtlUserFiberStart should only ever appear at the bottom of a call stack. These are the entrypoints for user threads and <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/fibers">fibers</a>, respectively. The first instruction on every thread, however, is actually LdrInitializeThunk. After performing the user-mode component of thread initialisation (and process, if required), this function transfers control to the entrypoint via NtContinue, which updates the instruction pointer directly. This means that it does not appear in any future stack walks.</p>
<p>So if you see a call stack that includes LdrInitializeThunk then this means you are at the very start of a thread’s execution. This is where the application compatibility <a href="https://techcommunity.microsoft.com/blog/askperf/demystifying-shims---or---using-the-app-compat-toolkit-to-make-your-old-stuff-wo/374947">Shim Engine</a> operates, where hook-based security products prefer to install themselves, and where malware tries to gain execution <em>before</em> those other security products. <a href="https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html">Marcus Hutchins</a> and <a href="https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection/">Guido Miggelenbrink</a> have both written excellent blogs on this topic. This startup race does not exist for security products that utilise <a href="https://www.elastic.co/security-labs/kernel-etw-best-etw">kernel ETW</a> for telemetry.</p>
<pre><code>{
  &quot;process.thread.Ext&quot;: {
    &quot;call_stack_summary&quot;: &quot;ntdll.dll|file.exe|ntdll.dll&quot;,
    &quot;call_stack&quot;: [
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!ZwProtectVirtualMemory+0x14&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.exe+0x1bac8&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!RtlAnsiStringToUnicodeString+0x3cb&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!LdrInitShimEngineDynamic+0x394d&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!LdrInitializeThunk+0x1db&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!LdrInitializeThunk+0x63&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!LdrInitializeThunk+0xe&quot; }
    ],
    &quot;call_stack_final_user_module&quot;: {
      &quot;path&quot;: &quot;c:\\users\\user\\desktop\\file.exe&quot;,
      &quot;code_signature&quot;: [ { &quot;exists&quot;: false } ],
      &quot;name&quot;: &quot;file.exe&quot;,
      &quot;hash&quot;: { &quot;sha256&quot;: &quot;a59a7b56f695845ce185ddc5210bcabce1fff909bac3842c2fb325c60db15df7&quot; }
    }
  }
}</code></pre>
<p>Pre-entrypoint execution example</p>
<p>The next pair is KiUserExceptionDispatcher and KiRaiseUserExceptionDispatcher. The kernel uses the former to pass execution to a registered user-mode structured exception handler after a user-mode exception condition has occurred. The latter also raises an exception, but on behalf of the kernel instead. This second variant is usually only caught by debuggers, including <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier">Application Verifier</a>, and helps identify when user-mode code is not sufficiently checking return codes from syscalls. These functions will usually be seen in call stacks related to application-specific crash handling or <a href="https://learn.microsoft.com/en-us/windows/win32/wer/windows-error-reporting">Windows Error Reporting</a>. However, sometimes malware will use it as a pseudo-breakpoint — for example, if they want to <a href="https://github.com/elastic/protections-artifacts/blob/3537aa4ed9c7ed9dcd04da2efafbad38af47a017/behavior/rules/windows/defense_evasion_virtualprotect_via_vectored_exception_handling.toml">fluctuate memory protections</a> to rehide their shellcode immediately after making a system call.</p>
<pre><code>{
  &quot;process.thread.Ext&quot;: {
    &quot;call_stack_summary&quot;: &quot;ntdll.dll|file.exe|ntdll.dll|file.exe|kernel32.dll|ntdll.dll&quot;,
    &quot;call_stack&quot;: [
      {
        &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!ZwProtectVirtualMemory+0x14&quot;,
        &quot;protection_provenance&quot;: &quot;file.exe&quot;, /* another vendor&#x27;s hooks were unhooked */
        &quot;allocation_private_bytes&quot;: 8192
      },
      { &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.exe+0xd99c&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!RtlInitializeCriticalSectionAndSpinCount+0x1c6&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!RtlWalkFrameChain+0x1119&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!KiUserExceptionDispatcher+0x2e&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.exe+0x12612&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernel32.dll!BaseThreadInitThunk+0x14&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!RtlUserThreadStart+0x21&quot; }
    ],
    &quot;call_stack_final_user_module&quot;: {
      &quot;name&quot;: &quot;file.exe&quot;,
      &quot;path&quot;: &quot;c:\\users\\user\\desktop\\file.exe&quot;,
      &quot;code_signature&quot;: [ { &quot;exists&quot;: false }],
      &quot;hash&quot;:   { &quot;sha256&quot;: &quot;0e5a62c0bd9f4596501032700bb528646d6810b16d785498f23ef81c18683c74&quot; }
    }
  }
}</code></pre>
<p>Protection fluctuation via exception handler example</p>
<p>Next is KiUserApcDispatcher, which is used to deliver <a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">user APCs</a>. These are one of the favourite tools of malware authors, as Microsoft only provides limited visibility into its use.</p>
<pre><code>{
  &quot;process.thread.Ext&quot;: {
    &quot;call_stack_summary&quot;: &quot;ntdll.dll|kernelbase.dll|ntdll.dll|kernelbase.dll|cronos.exe&quot;,
    &quot;call_stack&quot;: [
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!NtProtectVirtualMemory+0x14&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!VirtualProtect+0x36&quot; }, /* tail call */
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!KiUserApcDispatcher+0x2e&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!ZwDelayExecution+0x14&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!SleepEx+0x9e&quot; },
      {
        &quot;symbol_info&quot;: &quot;c:\\users\\user\\desktop\\file.exe+0x107d&quot;,
        &quot;allocation_private_bytes&quot;: 147456, /* stomped */
        &quot;protection&quot;: &quot;RW-&quot;, /* fluctuation */
        &quot;protection_provenance&quot;: &quot;Undetermined&quot;, /* proxied call */
        &quot;callsite_leading_bytes&quot;: &quot;010000004152524c8d520141524883ec284150415141baffffffff41525141ba010000004152524c8d520141524883ec284150b9ffffffffba0100000041ffe1&quot;,
        &quot;callsite_trailing_bytes&quot;: &quot;4883c428c3cccccccccccccccccccccccccccc894c240857b820190000e8a10c0000482be0488b052fd101004833c44889842410190000488d84243014000048&quot;
      }
    ],
    &quot;call_stack_final_user_module&quot;: {
      &quot;name&quot;: &quot;Undetermined&quot;,
      &quot;reason&quot;: &quot;ntdll.dll|kernelbase.dll|ntdll.dll|kernelbase.dll|file.exe&quot;
    }
  }
}</code></pre>
<p>Protection fluctuation via APC example</p>
<p>The Windows window manager is implemented in a kernel-mode device driver (win32k.sys). Mostly. Sometimes the window manager needs to do something from user-mode, and KiUserCallbackDispatcher is the mechanism to achieve that. It’s basically a reverse syscall that targets user32.dll functions. Overwriting an entry in a process’s <a href="https://attack.mitre.org/techniques/T1574/013/">KernelCallbackTable</a> is an easy way to hijack a GUI thread, so any other module following this call is suspicious.</p>
<p>Knowledge of the purpose of each of these kernel-mode to user-mode entry points greatly assists in determining if a given call stack is natural or if it has been misappropriated to achieve alternative goals.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="making-call-stacks-understandable" class="absolute -top-32"></span>Making call stacks understandable</h2>
<p>To aid understandability, we also tag the event with various process.Ext.api.behaviors that we identify. These behaviours aren’t necessarily malicious, but they highlight aspects that are relevant to alert triage or threat hunting. For call stacks, these include:</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">native_api</th><th align="left">A call was made directly to the Native API rather than the Win32 API.</th></tr></thead><tbody><tr><td align="left">direct_syscall</td><td align="left">A syscall instruction originated outside of the Native API layer.</td></tr><tr><td align="left">proxy_call</td><td align="left">The call stack may indicate a proxied API call to mask the true source.</td></tr><tr><td align="left">shellcode</td><td align="left">Second generation executable non-image memory called a sensitive API.</td></tr><tr><td align="left">image_indirect_call</td><td align="left">An entry in the call stack was preceded by a call to a dynamically resolved function.</td></tr><tr><td align="left">image_rop</td><td align="left">No call instruction preceded an entry in the call stack.</td></tr><tr><td align="left">image_rwx</td><td align="left">An entry in the call stack is writable. Code should be read-only.</td></tr><tr><td align="left">unbacked_rwx</td><td align="left">An entry in the call stack is non-image and writable. Even JIT code should be read-only.</td></tr><tr><td align="left">truncated_stack</td><td align="left">The call stack seems to be unexpectedly truncated. This may be due to malicious tampering or system load.</td></tr></tbody></table></div>
<p>In some contexts, these behaviours alone may be sufficient to detect malware.</p>
<p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="spoofing--bypass-or-liability" class="absolute -top-32"></span>Spoofing — bypass or liability?</h2>
<p>Return address spoofing has been a staple <a href="https://www.unknowncheats.me/forum/assembly/88648-spoofing-return-address.html">game hacking</a> and <a href="https://www.welivesecurity.com/2013/08/26/nymaim-obfuscation-chronicles/">malware</a> technique for many, many years. This simple trick allows injected code to borrow the reputation of a legitimate module with few consequences. The goal of deep call stack inspection and behaviour baselines is to stop giving malware this free pass.</p>
<p>Offensive researchers have been assisting this effort by looking into approaches for full call stack spoofing. Most notably:</p>
<ul>
<li><a href="https://labs.withsecure.com/publications/spoofing-call-stacks-to-confuse-edrs">Spoofing Call Stacks To Confuse EDRs</a> by William Burgess</li>
<li><a href="https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/">SilentMoonwalk: Implementing a dynamic Call Stack Spoofer</a> by Alessandro Magnosi, Arash Parsa and Athanasios Tserpelis</li>
</ul>
<p><a href="https://media.defcon.org/DEF%20CON%2031/DEF%20CON%2031%20presentations/Alessandro%20klezVirus%20Magnosi%20Arash%20waldoirc%20Parsa%20Athanasios%20trickster0%20Tserpelis%20-%20StackMoonwalk%20A%20Novel%20approach%20to%20stack%20spoofing%20on%20Windows%20x64.pdf">SilentMoonwalk</a>, in addition to being superb offensive research, is an excellent example of how lying can get you into twice the amount of trouble — but only if you get caught. Many Defense Evasion techniques rely on security-by-obscurity — and once exposed by researchers, they can become a liability. In this case, the research included advice on the detection opportunities <strong>introduced</strong> by the evasion attempt.</p>
<pre><code>{
  &quot;process.thread.Ext&quot;: {
    &quot;call_stack_summary&quot;: &quot;ntdll.dll|kernelbase.dll|kernel32.dll|ntdll.dll&quot;,
    &quot;call_stack&quot;: [
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!NtAllocateVirtualMemory+0x14&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!VirtualAlloc+0x48&quot; },
      {
        &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!CreatePrivateObjectSecurity+0x31&quot;,
        /* 4883c438 stack desync gadget - add rsp 0x38 */
        &quot;callsite_trailing_bytes&quot;: &quot;4883c438c3cccccccccccccccccccc48895c241057498bd8448bd2488bf94885c90f84660609004885db0f845d060900418bd14585c97411418bc14803c383ea&quot;,
        &quot;callsite_leading_bytes&quot;: &quot;cccccccccccccccccccccccccccccc4883ec38488b4424684889442428488b442460488944242048ff15d9b21b000f1f44000085c00f8830300900b801000000&quot;
      },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!Internal_EnumSystemLocales+0x406&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!SystemTimeToTzSpecificLocalTimeEx+0x2d1&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernelbase.dll!WaitForMultipleObjectsEx+0x982&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\kernel32.dll!BaseThreadInitThunk+0x14&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!RtlUserThreadStart+0x21&quot; }
    ],
    &quot;call_stack_final_user_module&quot;: {
      &quot;name&quot;: &quot;Undetermined&quot;, /* gadget module resulted in suspicious call stack */
      &quot;reason&quot;: &quot;ntdll.dll|kernelbase.dll|kernel32.dll|ntdll.dll&quot;
    }
  }
}</code></pre>
<p>SilentMoonwalk call stack example</p>
<p>A standard technique for unearthing hidden artifacts is to enumerate them using multiple techniques and compare the results for discrepancies. This is <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/rootkit-revealer#how-rootkitrevealer-works">how RootkitRevealer works</a>. This approach was also used in <a href="https://github.com/jdu2600/conference_talks/blob/main/2023-09-bsidescbr-GetInjectedThreadEx.pdf">Get-InjectedThreadEx.exe</a>, which <a href="https://github.com/jdu2600/Get-InjectedThreadEx/blob/edbff70fc286a3f1c32c6249b3b913d84d70259b/Get-InjectedThreadEx.cpp#L419-L445">climbs up the thread stack</a> as well as walking down it.</p>
<p>In certain circumstances, we may be able to recover a call stack in two ways. If there are discrepancies, then you will see the less reliable call stack emitted as call_stack_summary_original.</p>
<pre><code>{
  &quot;process.thread.Ext&quot;: {
    &quot;call_stack_summary&quot;: &quot;ntdll.dll&quot;,
    &quot;call_stack_summary_original&quot;: &quot;ntdll.dll|kernelbase.dll|version.dll|kernel32.dll|ntdll.dll&quot;,
    &quot;call_stack&quot;: [
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!NtContinue+0x12&quot; },
      { &quot;symbol_info&quot;: &quot;c:\\windows\\system32\\ntdll.dll!LdrInitializeThunk+0x13&quot; }
    ],
    &quot;call_stack_final_user_module&quot;: {
      &quot;name&quot;: &quot;Undetermined&quot;,
      &quot;reason&quot;: &quot;ntdll.dll&quot;
    }
  }
}</code></pre>
<p>Call Stack summary original example</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="call-stacks-are-for-everyone" class="absolute -top-32"></span>Call Stacks are for everyone</h2>
<p>By default you will only find call stacks in our alerts, but this is configurable through advanced policy.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th align="left">events.callstacks.emit_in_events</th><th align="left">If set, call stacks will be included in regular events where they are collected. Otherwise, they are only included in events that trigger behavioral protection rules. Note that setting this may significantly increase data volumes. Default: false</th></tr></thead></table></div>
<p>Further insights into Windows call stacks is available in the following Elastic Security Labs articles:</p>
<ul>
<li><a href="https://www.elastic.co/security-labs/upping-the-ante-detecting-in-memory-threats-with-kernel-call-stacks">Upping the Ante: Detecting In-Memory Threats with Kernel Call Stacks</a></li>
<li><a href="https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks">Peeling back the curtain with call stacks</a></li>
<li><a href="https://www.elastic.co/security-labs/doubling-down-etw-callstacks">Doubling Down: Detecting In-Memory Threats with Kernel ETW Call Stacks</a></li>
<li><a href="https://www.elastic.co/security-labs/itw-windows-lpe-0days-insights-and-detection-strategies">In-the-Wild Windows LPE 0-days: Insights &amp; Detection Strategies</a></li>
<li><a href="https://www.elastic.co/security-labs/misbehaving-modalities">Misbehaving Modalities: Detecting Tools, not Techniques</a></li>
<li><a href="https://www.elastic.co/security-labs/finding-truth-in-the-shadows">Finding Truth in the Shadows</a></li>
</ul></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#call-stacks-provide-the-who"><span>Call stacks provide the&nbsp;who</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#call-stacks-are-a-beautiful-lie"><span>Call stacks are a beautiful&nbsp;lie</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#making-call-stacks-beautiful"><span>Making call stacks&nbsp;beautiful</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#making-call-stacks-powerful"><span>**Making call stacks&nbsp;powerful**</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#a-quick-call-stack-glossary"><span>A quick call stack&nbsp;glossary</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#making-call-stacks-understandable"><span>Making call stacks&nbsp;understandable</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#spoofing--bypass-or-liability"><span>Spoofing — bypass or&nbsp;liability?</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/call-stacks-no-more-free-passes-for-malware#call-stacks-are-for-everyone"><span>Call Stacks are for&nbsp;everyone</span></a></li></ul></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Call Stacks: No More Free Passes For Malware&amp;url=https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware&amp;title=Call Stacks: No More Free Passes For Malware" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware&amp;title=Call Stacks: No More Free Passes For Malware" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Call Stacks: No More Free Passes For Malware","slug":"call-stacks-no-more-free-passes-for-malware","date":"2025-06-12","description":"We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations.","image":"Security Labs Images 33.jpg","body":{"raw":"\n## Call stacks provide the who\n\nOne of Elastic’s key Windows endpoint telemetry differentiators is **call stacks**.\n\nMost detections rely on *what* is happening — and this is often insufficient as most behaviours are dual purpose. With call stacks, we add the fine-grained ability to also determine *who* is performing the activity. This combination gives us an unparalleled ability to uncover malicious activity. By feeding this deep telemetry to [Elastic Defend](https://www.elastic.co/docs/reference/integrations/endpoint)’s on-host rule engine, we can quickly respond to emerging threats.\n\n## Call stacks are a beautiful lie\n\nIn computer science, a [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is a last-in, first-out data structure. Similar to a stack of physical items, it is only possible to add or remove the top element. A [call stack](https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks) is a stack that contains information about the currently active subroutine calls.\n\nOn x64 hosts, this call stack can only be accurately generated using execution tracing features on the CPU, such as [Intel LBR](https://www.blackhat.com/docs/us-16/materials/us-16-Pierce-Capturing-0days-With-PERFectly-Placed-Hardware-Traps-wp.pdf), Intel BTS, Intel AET, [Intel IPT](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/griffin-asplos17.pdf), and [x64 Architectural LBR](https://lwn.net/Articles/824613/). These tracing features were designed for performance profiling and debugging purposes, but can be used in some security scenarios as well. However, what is more generally available is an *approximate* call stack that is recovered from a thread’s data stack via a mechanism called [stack walking](https://github.com/jdu2600/conference_talks/blob/main/2022-04-csidescbr-StackWalking.pdf).\n\nIn the [x64 architecture](https://codemachine.com/articles/x64_deep_dive.html), the “stack pointer register” (`rsp`) unsurprisingly points to a stack data structure, and there are efficient instructions to read and write the data on this stack. Additionally, the `call` instruction transfers control to a new subroutine but also saves a return address at the memory address referenced by the stack pointer. A `ret` instruction will later retrieve this saved address so that execution can return to where it left off. Functions in most programming languages are typically implemented using these two instructions, and both function parameters and local function variables will typically be allocated on this stack for performance. The portion of the stack related to a single function is called a stack frame.\n\n![Windows x64 Calling Convention: Stack Frame](/assets/images/call-stacks-no-more-free-passes-for-malware/image2.png)\n\nStack walking is the recovery of just the return addresses from the heterogeneous data stored on the thread stack. Return addresses need to be stored somewhere for control flow — so stack walking co-opts this existing data to **approximate** a call stack. This is entirely suitable for most debugging and performance profiling scenarios, but slightly less helpful for security auditing. The main issue is that you can’t disassemble backwards. You can always determine the return address for a given call site, but not the converse. The best approach you can take is to check each of the 15 possible preceding instruction lengths and see which disassembles to exactly one call instruction. Even then, all you have recovered is a *previous* call site — not necessarily the exact *preceding* call site. This is because most compilers use [tail call](https://en.wikipedia.org/wiki/Tail_call) optimisation to omit unnecessary stack frames. This creates [annoying scenarios for security](https://youtu.be/9SqDY0wMmHE) like there being no guarantee that the Win32StartAddress function will be on the stack even though it was called.\n\nSo what we usually refer to as a call stack is actually a return address stack.\n\nMalware authors use this ambiguity to lie. They either craft trampoline stack frames through legitimate modules to hide calls originating from malicious code, or they coerce stack walking into predicting different return addresses than those the CPU will execute. Of course, malware has always just been an attempt to lie, and antimalware is just the process of exposing that lie.\n\n“... but at the length truth will out.”\n     - William Shakespeare, The Merchant of Venice, Act 2, Scene 2\n\n## Making call stacks beautiful\n\nSo far, a stack walk is just a list of numeric memory addresses. To make them useful for analysis we need to enrich them with context. (Note: we don’t currently include kernel stack frames.)\n\nThe minimum useful enrichment is to convert these addresses into offsets within modules (e.g. `ntdll.dll+0x15c9c4`). This would only catch the most egregious malware though — we can go deeper. The most important modules on Windows are those that implement the Native and Win32 APIs. The application binary interface for these APIs requires that the name of each function be included in the [Export Directory](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#the-edata-section-image-only) of the containing module. This is the information that Elastic currently uses to enrich its endpoint call stacks. \n\nA more accurate enrichment could be achieved by using the public symbols (if available) [hosted](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/microsoft-public-symbols) on the vendor’s infrastructure (especially Microsoft) While this method offers deeper fidelity, it comes with higher operational costs and isn’t feasible for our air-gapped customers. \n\nA rule of thumb for Microsoft kernel and native symbols is that the exported interface of each component has a capitalised prefix such as Ldr, Tp or Rtl. Private functions extend this prefix with a p. By default, private functions with external linkage are included in the [public symbol table](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/public-and-private-symbols). A very large offset might indicate a very large function, but it could also just indicate an unnamed function that you don’t have symbols for. A general guideline would be to consider any triple-digit and larger offsets in an exported function as likely belonging to another function.\n\n| Call Stack | Stack Walk | Stack Walk Modules | Stack Walk Exports (Elastic approach) | Stack Walk Public Symbols |\n| :---- | :---- | :---- | :---- | :---- |\n| 0x7ffb8eb9c9c2 **0x12d383f0046** 0x7ffb8eb1a9d8 0x7ffb8eb1aaf4 0x7ffb8ea535ff 0x7ffb8da5e8cf 0x7ffb8eaf14eb | 0x7ffb8eb9c9c4 0x7ffb8c3c71d6 0x7ffb8eb1a9ed 0x7ffb8eb1aaf9 0x7ffb8ea53604 0x7ffb8da5e8d4 0x7ffb8eaf14f1 | ntdll.dll+0x15c9c4 kernelbase.dll+0xc71d6 ntdll.dll+0xda9ed ntdll.dll+0xdaaf9 ntdll.dll+0x13604 kernel32.dll+0x2e8d4 ntdll.dll+0xb14f1 | ntdll.dll!NtProtectVirtualMemory+0x14 kernelbase.dll!VirtualProtect+0x36 ntdll.dll!RtlAddRefActivationContext+0x40d ntdll.dll!RtlAddRefActivationContext+0x519 ntdll.dll!RtlAcquireSRWLockExclusive+0x974 kernel32.dll!BaseThreadInitThunk+0x14 ntdll.dll!RtlUserThreadStart+0x21 | ntdll.dll!NtProtectVirtualMemory+0x14 kernelbase.dll!VirtualProtect+0x36 ntdll.dll!RtlTpTimerCallback+0x7d ntdll.dll!TppTimerpExecuteCallback+0xa9 ntdll.dll!TppWorkerThread+0x644 kernel32.dll!BaseThreadInitThunk+0x14 ntdll.dll!RtlUserThreadStart+0x21 |\n\nComparison of Call Stack Enrichment Levels\n\nIn the above example, the shellcode at 0x12d383f0000 deliberately used a tail call so that its address wouldn’t appear in the stack walk. This lie-by-omission is apparent even with only the stalk walk. Elastic reports this with the `proxy_call` heuristic as the malware registered a timer callback function to proxy the call to `VirtualProtect` from a different thread.\n\n## **Making call stacks powerful**\n\nThe call stacks of the system calls that we monitor with [Event Tracing for Windows](https://www.elastic.co/security-labs/kernel-etw-best-etw) (ETW) have an expected structure. At the bottom of the stack is the thread StartAddress - typically ntdll.dll!RtlUserThreadStart. This is followed by the Win32 API thread entry - kernel32.dll!BaseThreadInitThunk and then the first user module. A user module is application code that is not part of the Win32 (or Native) API. This first user module should match the thread’s Win32StartAddress (unless that function used a tail call). More user modules will follow until the final user module makes a call into a Win32 API that makes a Native API call, which finally results in a system call to the kernel.\n\nFrom a detection standpoint, the most important module in this call stack is the [final user module](https://github.com/search?q=repo%3Aelastic%2Fprotections-artifacts+call_stack_final_user_module\u0026type=code). Elastic shows this module, including its hash and any code signatures. These details aid in alert triage, but more importantly, they drastically improve the granularity at which we can baseline the behaviours of legitimate software that sometimes behaves like malware. The more accurately we can baseline normal, the harder it is for malware to blend in.\n\n```json\n{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|kernelbase.dll|file.dll|rundll32.exe|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!NtAllocateVirtualMemory+0x14\" }, /* Native API */\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!VirtualAllocExNuma+0x62\" }, /* Win32 API */\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!VirtualAllocEx+0x16\" }, /* Win32 API */\n      {\n        \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.dll+0x160d8b\", /* final user module */\n        \"callsite_trailing_bytes\": \"488bf0488d4d88e8197ee2ff488bc64883c4685b5e5f415c415d415e415f5dc390909090905541574156415541545756534883ec58488dac2490000000488b71\",\n        \"callsite_leading_bytes\": \"088b4d38894c2420488bca48894db8498bd0488955b0458bc1448945c4448b4d3044894dc0488d4d88e8e77de2ff488b4db8488b55b0448b45c4448b4dc0ffd6\"\n      },\n      { \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.dll+0x7b429\" },\n      { \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.dll+0x44a9\" },\n      { \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.dll+0x5f58\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\rundll32.exe+0x3bcf\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\rundll32.exe+0x6309\" }, /* first user module - typically the ETHREAD.Win32StartAddress module */\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernel32.dll!BaseThreadInitThunk+0x14\" }, /* Win32 API */\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!RtlUserThreadStart+0x21\" /* Native API - the ETHREAD.StartAddress module */\n      }\n    ],\n    \"call_stack_final_user_module\": {\n      \"path\": \"c:\\\\users\\\\user\\\\desktop\\\\file.dll\",\n      \"code_signature\": [ { \"exists\": false } ],\n      \"name\": \"file.dll\",\n      \"hash\": { \"sha256\": \"0240cc89d4a76bafa9dcdccd831a263bf715af53e46cac0b0abca8116122d242\" }\n    }\n  }\n}\n```\n \nSample enriched call stack\n\nCall stack final user module enrichments:\n\n| name | The file name of the call_stack_final_user_module. Can also be \"Unbacked\" indicating private executable memory, or \"Undetermined\" indicating a suspicious call stack. |\n| :---- | :---- |\n| path | The file path of the call_stack_final_user_module. |\n| hash.sha256 | The sha256 of the call_stack_final_user_module, or the protection_provenance module if any. |\n| code_signature | Code signature of the call_stack_final_user_module, or the protection_provenance module if any. |\n| allocation_private_bytes | The number of bytes in this memory region that are both +X and non-shareable. Non-zero values can indicate code hooking, patching, or hollowing. |\n| protection | The memory protection for the acting region of pages is included if it is not RX. Corresponds to MEMORY_BASIC_INFORMATION.Protect. |\n| protection_provenance | The name of the memory region that caused the last modification of the protection of this page. \"Unbacked\" may indicate shellcode. |\n| protection_provenance_path | The path of the module that caused the last modification of the protection of this page. |\n| reason | The anomalous call_stack_summary that led to an \"Undetermined\" protection_provenance. |\n\n\n## A quick call stack glossary\n\nWhen examining call stacks, there are some Native API functions that are helpful to be familiar with. Ken Johnson, now of Microsoft, has provided us with a [catalog of NTDLL kernel mode to user mode callbacks](http://www.nynaeve.net/?p=200) to get us started. Seriously, you should pause here and go read that first.\n\nWe met RtlUserThreadStart earlier. Both it and its sibling RtlUserFiberStart should only ever appear at the bottom of a call stack. These are the entrypoints for user threads and [fibers](https://learn.microsoft.com/en-us/windows/win32/procthread/fibers), respectively. The first instruction on every thread, however, is actually LdrInitializeThunk. After performing the user-mode component of thread initialisation (and process, if required), this function transfers control to the entrypoint via NtContinue, which updates the instruction pointer directly. This means that it does not appear in any future stack walks.\n\nSo if you see a call stack that includes LdrInitializeThunk then this means you are at the very start of a thread’s execution. This is where the application compatibility [Shim Engine](https://techcommunity.microsoft.com/blog/askperf/demystifying-shims---or---using-the-app-compat-toolkit-to-make-your-old-stuff-wo/374947) operates, where hook-based security products prefer to install themselves, and where malware tries to gain execution *before* those other security products. [Marcus Hutchins](https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html) and [Guido Miggelenbrink](https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection/) have both written excellent blogs on this topic. This startup race does not exist for security products that utilise [kernel ETW](https://www.elastic.co/security-labs/kernel-etw-best-etw) for telemetry.\n\n```json\n{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|file.exe|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!ZwProtectVirtualMemory+0x14\" },\n      { \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.exe+0x1bac8\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!RtlAnsiStringToUnicodeString+0x3cb\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!LdrInitShimEngineDynamic+0x394d\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!LdrInitializeThunk+0x1db\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!LdrInitializeThunk+0x63\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!LdrInitializeThunk+0xe\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"path\": \"c:\\\\users\\\\user\\\\desktop\\\\file.exe\",\n      \"code_signature\": [ { \"exists\": false } ],\n      \"name\": \"file.exe\",\n      \"hash\": { \"sha256\": \"a59a7b56f695845ce185ddc5210bcabce1fff909bac3842c2fb325c60db15df7\" }\n    }\n  }\n}\n```\n\nPre-entrypoint execution example\n\nThe next pair is KiUserExceptionDispatcher and KiRaiseUserExceptionDispatcher. The kernel uses the former to pass execution to a registered user-mode structured exception handler after a user-mode exception condition has occurred. The latter also raises an exception, but on behalf of the kernel instead. This second variant is usually only caught by debuggers, including [Application Verifier](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier), and helps identify when user-mode code is not sufficiently checking return codes from syscalls. These functions will usually be seen in call stacks related to application-specific crash handling or [Windows Error Reporting](https://learn.microsoft.com/en-us/windows/win32/wer/windows-error-reporting). However, sometimes malware will use it as a pseudo-breakpoint — for example, if they want to [fluctuate memory protections](https://github.com/elastic/protections-artifacts/blob/3537aa4ed9c7ed9dcd04da2efafbad38af47a017/behavior/rules/windows/defense_evasion_virtualprotect_via_vectored_exception_handling.toml) to rehide their shellcode immediately after making a system call.\n\n```json\n{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|file.exe|ntdll.dll|file.exe|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      {\n        \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!ZwProtectVirtualMemory+0x14\",\n        \"protection_provenance\": \"file.exe\", /* another vendor's hooks were unhooked */\n        \"allocation_private_bytes\": 8192\n      },\n      { \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.exe+0xd99c\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!RtlInitializeCriticalSectionAndSpinCount+0x1c6\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!RtlWalkFrameChain+0x1119\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!KiUserExceptionDispatcher+0x2e\" },\n      { \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.exe+0x12612\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernel32.dll!BaseThreadInitThunk+0x14\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!RtlUserThreadStart+0x21\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"file.exe\",\n      \"path\": \"c:\\\\users\\\\user\\\\desktop\\\\file.exe\",\n      \"code_signature\": [ { \"exists\": false }],\n      \"hash\":   { \"sha256\": \"0e5a62c0bd9f4596501032700bb528646d6810b16d785498f23ef81c18683c74\" }\n    }\n  }\n}\n```\n\nProtection fluctuation via exception handler example\n\nNext is KiUserApcDispatcher, which is used to deliver [user APCs](https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls). These are one of the favourite tools of malware authors, as Microsoft only provides limited visibility into its use. \n\n```json\n{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|kernelbase.dll|ntdll.dll|kernelbase.dll|cronos.exe\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!NtProtectVirtualMemory+0x14\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!VirtualProtect+0x36\" }, /* tail call */\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!KiUserApcDispatcher+0x2e\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!ZwDelayExecution+0x14\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!SleepEx+0x9e\" },\n      {\n        \"symbol_info\": \"c:\\\\users\\\\user\\\\desktop\\\\file.exe+0x107d\",\n        \"allocation_private_bytes\": 147456, /* stomped */\n        \"protection\": \"RW-\", /* fluctuation */\n        \"protection_provenance\": \"Undetermined\", /* proxied call */\n        \"callsite_leading_bytes\": \"010000004152524c8d520141524883ec284150415141baffffffff41525141ba010000004152524c8d520141524883ec284150b9ffffffffba0100000041ffe1\",\n        \"callsite_trailing_bytes\": \"4883c428c3cccccccccccccccccccccccccccc894c240857b820190000e8a10c0000482be0488b052fd101004833c44889842410190000488d84243014000048\"\n      }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"Undetermined\",\n      \"reason\": \"ntdll.dll|kernelbase.dll|ntdll.dll|kernelbase.dll|file.exe\"\n    }\n  }\n}\n```\n\nProtection fluctuation via APC example\n\nThe Windows window manager is implemented in a kernel-mode device driver (win32k.sys). Mostly. Sometimes the window manager needs to do something from user-mode, and KiUserCallbackDispatcher is the mechanism to achieve that. It’s basically a reverse syscall that targets user32.dll functions. Overwriting an entry in a process’s [KernelCallbackTable](https://attack.mitre.org/techniques/T1574/013/) is an easy way to hijack a GUI thread, so any other module following this call is suspicious.  \n\nKnowledge of the purpose of each of these kernel-mode to user-mode entry points greatly assists in determining if a given call stack is natural or if it has been misappropriated to achieve alternative goals.\n\n## Making call stacks understandable\n\nTo aid understandability, we also tag the event with various process.Ext.api.behaviors that we identify. These behaviours aren’t necessarily malicious, but they highlight aspects that are relevant to alert triage or threat hunting. For call stacks, these include:\n\n| native_api | A call was made directly to the Native API rather than the Win32 API. |\n| :---- | :---- |\n| direct_syscall | A syscall instruction originated outside of the Native API layer. |\n| proxy_call | The call stack may indicate a proxied API call to mask the true source. |\n| shellcode | Second generation executable non-image memory called a sensitive API. |\n| image_indirect_call | An entry in the call stack was preceded by a call to a dynamically resolved function. |\n| image_rop | No call instruction preceded an entry in the call stack. |\n| image_rwx | An entry in the call stack is writable. Code should be read-only. |\n| unbacked_rwx | An entry in the call stack is non-image and writable. Even JIT code should be read-only. |\n| truncated_stack | The call stack seems to be unexpectedly truncated. This may be due to malicious tampering or system load. |\n\nIn some contexts, these behaviours alone may be sufficient to detect malware.\n\n![SilentMoonwalk variant alerts](/assets/images/call-stacks-no-more-free-passes-for-malware/image1.png)  \n\n## Spoofing — bypass or liability?\n\nReturn address spoofing has been a staple [game hacking](https://www.unknowncheats.me/forum/assembly/88648-spoofing-return-address.html) and [malware](https://www.welivesecurity.com/2013/08/26/nymaim-obfuscation-chronicles/) technique for many, many years. This simple trick allows injected code to borrow the reputation of a legitimate module with few consequences. The goal of deep call stack inspection and behaviour baselines is to stop giving malware this free pass.\n\nOffensive researchers have been assisting this effort by looking into approaches for full call stack spoofing. Most notably:\n\n* [Spoofing Call Stacks To Confuse EDRs](https://labs.withsecure.com/publications/spoofing-call-stacks-to-confuse-edrs) by William Burgess   \n* [SilentMoonwalk: Implementing a dynamic Call Stack Spoofer](https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/) by Alessandro Magnosi, Arash Parsa and Athanasios Tserpelis\n\n[SilentMoonwalk](https://media.defcon.org/DEF%20CON%2031/DEF%20CON%2031%20presentations/Alessandro%20klezVirus%20Magnosi%20Arash%20waldoirc%20Parsa%20Athanasios%20trickster0%20Tserpelis%20-%20StackMoonwalk%20A%20Novel%20approach%20to%20stack%20spoofing%20on%20Windows%20x64.pdf), in addition to being superb offensive research, is an excellent example of how lying can get you into twice the amount of trouble — but only if you get caught. Many Defense Evasion techniques rely on security-by-obscurity — and once exposed by researchers, they can become a liability. In this case, the research included advice on the detection opportunities **introduced** by the evasion attempt.\n\n```json\n{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|kernelbase.dll|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!NtAllocateVirtualMemory+0x14\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!VirtualAlloc+0x48\" },\n      {\n        \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!CreatePrivateObjectSecurity+0x31\",\n        /* 4883c438 stack desync gadget - add rsp 0x38 */\n        \"callsite_trailing_bytes\": \"4883c438c3cccccccccccccccccccc48895c241057498bd8448bd2488bf94885c90f84660609004885db0f845d060900418bd14585c97411418bc14803c383ea\",\n        \"callsite_leading_bytes\": \"cccccccccccccccccccccccccccccc4883ec38488b4424684889442428488b442460488944242048ff15d9b21b000f1f44000085c00f8830300900b801000000\"\n      },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!Internal_EnumSystemLocales+0x406\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!SystemTimeToTzSpecificLocalTimeEx+0x2d1\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernelbase.dll!WaitForMultipleObjectsEx+0x982\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\kernel32.dll!BaseThreadInitThunk+0x14\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!RtlUserThreadStart+0x21\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"Undetermined\", /* gadget module resulted in suspicious call stack */\n      \"reason\": \"ntdll.dll|kernelbase.dll|kernel32.dll|ntdll.dll\"\n    }\n  }\n}\n```\n\nSilentMoonwalk call stack example\n\nA standard technique for unearthing hidden artifacts is to enumerate them using multiple techniques and compare the results for discrepancies. This is [how RootkitRevealer works](https://learn.microsoft.com/en-us/sysinternals/downloads/rootkit-revealer#how-rootkitrevealer-works). This approach was also used in [Get-InjectedThreadEx.exe](https://github.com/jdu2600/conference_talks/blob/main/2023-09-bsidescbr-GetInjectedThreadEx.pdf), which [climbs up the thread stack](https://github.com/jdu2600/Get-InjectedThreadEx/blob/edbff70fc286a3f1c32c6249b3b913d84d70259b/Get-InjectedThreadEx.cpp#L419-L445) as well as walking down it.\n\nIn certain circumstances, we may be able to recover a call stack in two ways. If there are discrepancies, then you will see the less reliable call stack emitted as call_stack_summary_original.\n\n```json\n{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll\",\n    \"call_stack_summary_original\": \"ntdll.dll|kernelbase.dll|version.dll|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!NtContinue+0x12\" },\n      { \"symbol_info\": \"c:\\\\windows\\\\system32\\\\ntdll.dll!LdrInitializeThunk+0x13\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"Undetermined\",\n      \"reason\": \"ntdll.dll\"\n    }\n  }\n}\n```\n\nCall Stack summary original example\n\n## Call Stacks are for everyone\n\nBy default you will only find call stacks in our alerts, but this is configurable through advanced policy.\n\n| events.callstacks.emit_in_events | If set, call stacks will be included in regular events where they are collected. Otherwise, they are only included in events that trigger behavioral protection rules. Note that setting this may significantly increase data volumes. Default: false |\n| :---- | :---- |\n\nFurther insights into Windows call stacks is available in the following Elastic Security Labs articles: \n\n* [Upping the Ante: Detecting In-Memory Threats with Kernel Call Stacks](https://www.elastic.co/security-labs/upping-the-ante-detecting-in-memory-threats-with-kernel-call-stacks)  \n* [Peeling back the curtain with call stacks](https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks)  \n* [Doubling Down: Detecting In-Memory Threats with Kernel ETW Call Stacks](https://www.elastic.co/security-labs/doubling-down-etw-callstacks)  \n* [In-the-Wild Windows LPE 0-days: Insights \u0026 Detection Strategies](https://www.elastic.co/security-labs/itw-windows-lpe-0days-insights-and-detection-strategies)  \n* [Misbehaving Modalities: Detecting Tools, not Techniques](https://www.elastic.co/security-labs/misbehaving-modalities)  \n* [Finding Truth in the Shadows](https://www.elastic.co/security-labs/finding-truth-in-the-shadows)","code":"var Component=(()=\u003e{var h=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(l,e)=\u003e()=\u003e(e||l((e={exports:{}}).exports,e),e.exports),w=(l,e)=\u003e{for(var n in e)i(l,n,{get:e[n],enumerable:!0})},r=(l,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!p.call(l,a)\u0026\u0026a!==n\u0026\u0026i(l,a,{get:()=\u003ee[a],enumerable:!(s=f(e,a))||s.enumerable});return l};var y=(l,e,n)=\u003e(n=l!=null?h(m(l)):{},r(e||!l||!l.__esModule?i(n,\"default\",{value:l,enumerable:!0}):n,l)),g=l=\u003er(i({},\"__esModule\",{value:!0}),l);var c=b((A,o)=\u003e{o.exports=_jsx_runtime});var v={};w(v,{default:()=\u003e_,frontmatter:()=\u003ek});var t=y(c()),k={title:\"Call Stacks: No More Free Passes For Malware\",slug:\"call-stacks-no-more-free-passes-for-malware\",date:\"2025-06-12\",description:\"We explore the immense value that call stacks bring to malware detection and why Elastic considers them to be vital Windows endpoint telemetry despite the architectural limitations.\",author:[{slug:\"john-uhlmann\"}],image:\"Security Labs Images 33.jpg\",category:[{slug:\"security-research\"}]};function d(l){let e=Object.assign({h2:\"h2\",p:\"p\",strong:\"strong\",em:\"em\",a:\"a\",code:\"code\",img:\"img\",ul:\"ul\",li:\"li\",div:\"div\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",pre:\"pre\"},l.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:\"call-stacks-provide-the-who\",children:\"Call stacks provide the who\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"One of Elastic\\u2019s key Windows endpoint telemetry differentiators is \",(0,t.jsx)(e.strong,{children:\"call stacks\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Most detections rely on \",(0,t.jsx)(e.em,{children:\"what\"}),\" is happening \\u2014 and this is often insufficient as most behaviours are dual purpose. With call stacks, we add the fine-grained ability to also determine \",(0,t.jsx)(e.em,{children:\"who\"}),\" is performing the activity. This combination gives us an unparalleled ability to uncover malicious activity. By feeding this deep telemetry to \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/docs/reference/integrations/endpoint\",rel:\"nofollow\",children:\"Elastic Defend\"}),\"\\u2019s on-host rule engine, we can quickly respond to emerging threats.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"call-stacks-are-a-beautiful-lie\",children:\"Call stacks are a beautiful lie\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In computer science, a \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\",rel:\"nofollow\",children:\"stack\"}),\" is a last-in, first-out data structure. Similar to a stack of physical items, it is only possible to add or remove the top element. A \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks\",rel:\"nofollow\",children:\"call stack\"}),\" is a stack that contains information about the currently active subroutine calls.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"On x64 hosts, this call stack can only be accurately generated using execution tracing features on the CPU, such as \",(0,t.jsx)(e.a,{href:\"https://www.blackhat.com/docs/us-16/materials/us-16-Pierce-Capturing-0days-With-PERFectly-Placed-Hardware-Traps-wp.pdf\",rel:\"nofollow\",children:\"Intel LBR\"}),\", Intel BTS, Intel AET, \",(0,t.jsx)(e.a,{href:\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/griffin-asplos17.pdf\",rel:\"nofollow\",children:\"Intel IPT\"}),\", and \",(0,t.jsx)(e.a,{href:\"https://lwn.net/Articles/824613/\",rel:\"nofollow\",children:\"x64 Architectural LBR\"}),\". These tracing features were designed for performance profiling and debugging purposes, but can be used in some security scenarios as well. However, what is more generally available is an \",(0,t.jsx)(e.em,{children:\"approximate\"}),\" call stack that is recovered from a thread\\u2019s data stack via a mechanism called \",(0,t.jsx)(e.a,{href:\"https://github.com/jdu2600/conference_talks/blob/main/2022-04-csidescbr-StackWalking.pdf\",rel:\"nofollow\",children:\"stack walking\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.a,{href:\"https://codemachine.com/articles/x64_deep_dive.html\",rel:\"nofollow\",children:\"x64 architecture\"}),\", the \\u201Cstack pointer register\\u201D (\",(0,t.jsx)(e.code,{children:\"rsp\"}),\") unsurprisingly points to a stack data structure, and there are efficient instructions to read and write the data on this stack. Additionally, the \",(0,t.jsx)(e.code,{children:\"call\"}),\" instruction transfers control to a new subroutine but also saves a return address at the memory address referenced by the stack pointer. A \",(0,t.jsx)(e.code,{children:\"ret\"}),\" instruction will later retrieve this saved address so that execution can return to where it left off. Functions in most programming languages are typically implemented using these two instructions, and both function parameters and local function variables will typically be allocated on this stack for performance. The portion of the stack related to a single function is called a stack frame.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/call-stacks-no-more-free-passes-for-malware/image2.png\",alt:\"Windows x64 Calling Convention: Stack Frame\",width:\"1590\",height:\"581\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Stack walking is the recovery of just the return addresses from the heterogeneous data stored on the thread stack. Return addresses need to be stored somewhere for control flow \\u2014 so stack walking co-opts this existing data to \",(0,t.jsx)(e.strong,{children:\"approximate\"}),\" a call stack. This is entirely suitable for most debugging and performance profiling scenarios, but slightly less helpful for security auditing. The main issue is that you can\\u2019t disassemble backwards. You can always determine the return address for a given call site, but not the converse. The best approach you can take is to check each of the 15 possible preceding instruction lengths and see which disassembles to exactly one call instruction. Even then, all you have recovered is a \",(0,t.jsx)(e.em,{children:\"previous\"}),\" call site \\u2014 not necessarily the exact \",(0,t.jsx)(e.em,{children:\"preceding\"}),\" call site. This is because most compilers use \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Tail_call\",rel:\"nofollow\",children:\"tail call\"}),\" optimisation to omit unnecessary stack frames. This creates \",(0,t.jsx)(e.a,{href:\"https://youtu.be/9SqDY0wMmHE\",rel:\"nofollow\",children:\"annoying scenarios for security\"}),\" like there being no guarantee that the Win32StartAddress function will be on the stack even though it was called.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"So what we usually refer to as a call stack is actually a return address stack.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Malware authors use this ambiguity to lie. They either craft trampoline stack frames through legitimate modules to hide calls originating from malicious code, or they coerce stack walking into predicting different return addresses than those the CPU will execute. Of course, malware has always just been an attempt to lie, and antimalware is just the process of exposing that lie.\"}),`\n`,(0,t.jsx)(e.p,{children:\"\\u201C... but at the length truth will out.\\u201D\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"William Shakespeare, The Merchant of Venice, Act 2, Scene 2\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{id:\"making-call-stacks-beautiful\",children:\"Making call stacks beautiful\"}),`\n`,(0,t.jsx)(e.p,{children:\"So far, a stack walk is just a list of numeric memory addresses. To make them useful for analysis we need to enrich them with context. (Note: we don\\u2019t currently include kernel stack frames.)\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The minimum useful enrichment is to convert these addresses into offsets within modules (e.g. \",(0,t.jsx)(e.code,{children:\"ntdll.dll+0x15c9c4\"}),\"). This would only catch the most egregious malware though \\u2014 we can go deeper. The most important modules on Windows are those that implement the Native and Win32 APIs. The application binary interface for these APIs requires that the name of each function be included in the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#the-edata-section-image-only\",rel:\"nofollow\",children:\"Export Directory\"}),\" of the containing module. This is the information that Elastic currently uses to enrich its endpoint call stacks.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A more accurate enrichment could be achieved by using the public symbols (if available) \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/microsoft-public-symbols\",rel:\"nofollow\",children:\"hosted\"}),\" on the vendor\\u2019s infrastructure (especially Microsoft) While this method offers deeper fidelity, it comes with higher operational costs and isn\\u2019t feasible for our air-gapped customers.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A rule of thumb for Microsoft kernel and native symbols is that the exported interface of each component has a capitalised prefix such as Ldr, Tp or Rtl. Private functions extend this prefix with a p. By default, private functions with external linkage are included in the \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/public-and-private-symbols\",rel:\"nofollow\",children:\"public symbol table\"}),\". A very large offset might indicate a very large function, but it could also just indicate an unnamed function that you don\\u2019t have symbols for. A general guideline would be to consider any triple-digit and larger offsets in an exported function as likely belonging to another function.\"]}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{align:\"left\",children:\"Call Stack\"}),(0,t.jsx)(e.th,{align:\"left\",children:\"Stack Walk\"}),(0,t.jsx)(e.th,{align:\"left\",children:\"Stack Walk Modules\"}),(0,t.jsx)(e.th,{align:\"left\",children:\"Stack Walk Exports (Elastic approach)\"}),(0,t.jsx)(e.th,{align:\"left\",children:\"Stack Walk Public Symbols\"})]})}),(0,t.jsx)(e.tbody,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsxs)(e.td,{align:\"left\",children:[\"0x7ffb8eb9c9c2 \",(0,t.jsx)(e.strong,{children:\"0x12d383f0046\"}),\" 0x7ffb8eb1a9d8 0x7ffb8eb1aaf4 0x7ffb8ea535ff 0x7ffb8da5e8cf 0x7ffb8eaf14eb\"]}),(0,t.jsx)(e.td,{align:\"left\",children:\"0x7ffb8eb9c9c4 0x7ffb8c3c71d6 0x7ffb8eb1a9ed 0x7ffb8eb1aaf9 0x7ffb8ea53604 0x7ffb8da5e8d4 0x7ffb8eaf14f1\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"ntdll.dll+0x15c9c4 kernelbase.dll+0xc71d6 ntdll.dll+0xda9ed ntdll.dll+0xdaaf9 ntdll.dll+0x13604 kernel32.dll+0x2e8d4 ntdll.dll+0xb14f1\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"ntdll.dll!NtProtectVirtualMemory+0x14 kernelbase.dll!VirtualProtect+0x36 ntdll.dll!RtlAddRefActivationContext+0x40d ntdll.dll!RtlAddRefActivationContext+0x519 ntdll.dll!RtlAcquireSRWLockExclusive+0x974 kernel32.dll!BaseThreadInitThunk+0x14 ntdll.dll!RtlUserThreadStart+0x21\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"ntdll.dll!NtProtectVirtualMemory+0x14 kernelbase.dll!VirtualProtect+0x36 ntdll.dll!RtlTpTimerCallback+0x7d ntdll.dll!TppTimerpExecuteCallback+0xa9 ntdll.dll!TppWorkerThread+0x644 kernel32.dll!BaseThreadInitThunk+0x14 ntdll.dll!RtlUserThreadStart+0x21\"})]})})]})}),`\n`,(0,t.jsx)(e.p,{children:\"Comparison of Call Stack Enrichment Levels\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the above example, the shellcode at 0x12d383f0000 deliberately used a tail call so that its address wouldn\\u2019t appear in the stack walk. This lie-by-omission is apparent even with only the stalk walk. Elastic reports this with the \",(0,t.jsx)(e.code,{children:\"proxy_call\"}),\" heuristic as the malware registered a timer callback function to proxy the call to \",(0,t.jsx)(e.code,{children:\"VirtualProtect\"}),\" from a different thread.\"]}),`\n`,(0,t.jsx)(e.h2,{id:\"making-call-stacks-powerful\",children:(0,t.jsx)(e.strong,{children:\"Making call stacks powerful\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The call stacks of the system calls that we monitor with \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/kernel-etw-best-etw\",rel:\"nofollow\",children:\"Event Tracing for Windows\"}),\" (ETW) have an expected structure. At the bottom of the stack is the thread StartAddress - typically ntdll.dll!RtlUserThreadStart. This is followed by the Win32 API thread entry - kernel32.dll!BaseThreadInitThunk and then the first user module. A user module is application code that is not part of the Win32 (or Native) API. This first user module should match the thread\\u2019s Win32StartAddress (unless that function used a tail call). More user modules will follow until the final user module makes a call into a Win32 API that makes a Native API call, which finally results in a system call to the kernel.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"From a detection standpoint, the most important module in this call stack is the \",(0,t.jsx)(e.a,{href:\"https://github.com/search?q=repo%3Aelastic%2Fprotections-artifacts+call_stack_final_user_module\u0026type=code\",rel:\"nofollow\",children:\"final user module\"}),\". Elastic shows this module, including its hash and any code signatures. These details aid in alert triage, but more importantly, they drastically improve the granularity at which we can baseline the behaviours of legitimate software that sometimes behaves like malware. The more accurately we can baseline normal, the harder it is for malware to blend in.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-json\",children:`{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|kernelbase.dll|file.dll|rundll32.exe|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!NtAllocateVirtualMemory+0x14\" }, /* Native API */\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!VirtualAllocExNuma+0x62\" }, /* Win32 API */\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!VirtualAllocEx+0x16\" }, /* Win32 API */\n      {\n        \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.dll+0x160d8b\", /* final user module */\n        \"callsite_trailing_bytes\": \"488bf0488d4d88e8197ee2ff488bc64883c4685b5e5f415c415d415e415f5dc390909090905541574156415541545756534883ec58488dac2490000000488b71\",\n        \"callsite_leading_bytes\": \"088b4d38894c2420488bca48894db8498bd0488955b0458bc1448945c4448b4d3044894dc0488d4d88e8e77de2ff488b4db8488b55b0448b45c4448b4dc0ffd6\"\n      },\n      { \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.dll+0x7b429\" },\n      { \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.dll+0x44a9\" },\n      { \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.dll+0x5f58\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\rundll32.exe+0x3bcf\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\rundll32.exe+0x6309\" }, /* first user module - typically the ETHREAD.Win32StartAddress module */\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernel32.dll!BaseThreadInitThunk+0x14\" }, /* Win32 API */\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!RtlUserThreadStart+0x21\" /* Native API - the ETHREAD.StartAddress module */\n      }\n    ],\n    \"call_stack_final_user_module\": {\n      \"path\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.dll\",\n      \"code_signature\": [ { \"exists\": false } ],\n      \"name\": \"file.dll\",\n      \"hash\": { \"sha256\": \"0240cc89d4a76bafa9dcdccd831a263bf715af53e46cac0b0abca8116122d242\" }\n    }\n  }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Sample enriched call stack\"}),`\n`,(0,t.jsx)(e.p,{children:\"Call stack final user module enrichments:\"}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{align:\"left\",children:\"name\"}),(0,t.jsx)(e.th,{align:\"left\",children:'The file name of the call_stack_final_user_module. Can also be \"Unbacked\" indicating private executable memory, or \"Undetermined\" indicating a suspicious call stack.'})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"path\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The file path of the call_stack_final_user_module.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"hash.sha256\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The sha256 of the call_stack_final_user_module, or the protection_provenance module if any.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"code_signature\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"Code signature of the call_stack_final_user_module, or the protection_provenance module if any.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"allocation_private_bytes\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The number of bytes in this memory region that are both +X and non-shareable. Non-zero values can indicate code hooking, patching, or hollowing.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"protection\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The memory protection for the acting region of pages is included if it is not RX. Corresponds to MEMORY_BASIC_INFORMATION.Protect.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"protection_provenance\"}),(0,t.jsx)(e.td,{align:\"left\",children:'The name of the memory region that caused the last modification of the protection of this page. \"Unbacked\" may indicate shellcode.'})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"protection_provenance_path\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The path of the module that caused the last modification of the protection of this page.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"reason\"}),(0,t.jsx)(e.td,{align:\"left\",children:'The anomalous call_stack_summary that led to an \"Undetermined\" protection_provenance.'})]})]})]})}),`\n`,(0,t.jsx)(e.h2,{id:\"a-quick-call-stack-glossary\",children:\"A quick call stack glossary\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When examining call stacks, there are some Native API functions that are helpful to be familiar with. Ken Johnson, now of Microsoft, has provided us with a \",(0,t.jsx)(e.a,{href:\"http://www.nynaeve.net/?p=200\",rel:\"nofollow\",children:\"catalog of NTDLL kernel mode to user mode callbacks\"}),\" to get us started. Seriously, you should pause here and go read that first.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We met RtlUserThreadStart earlier. Both it and its sibling RtlUserFiberStart should only ever appear at the bottom of a call stack. These are the entrypoints for user threads and \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/procthread/fibers\",rel:\"nofollow\",children:\"fibers\"}),\", respectively. The first instruction on every thread, however, is actually LdrInitializeThunk. After performing the user-mode component of thread initialisation (and process, if required), this function transfers control to the entrypoint via NtContinue, which updates the instruction pointer directly. This means that it does not appear in any future stack walks.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"So if you see a call stack that includes LdrInitializeThunk then this means you are at the very start of a thread\\u2019s execution. This is where the application compatibility \",(0,t.jsx)(e.a,{href:\"https://techcommunity.microsoft.com/blog/askperf/demystifying-shims---or---using-the-app-compat-toolkit-to-make-your-old-stuff-wo/374947\",rel:\"nofollow\",children:\"Shim Engine\"}),\" operates, where hook-based security products prefer to install themselves, and where malware tries to gain execution \",(0,t.jsx)(e.em,{children:\"before\"}),\" those other security products. \",(0,t.jsx)(e.a,{href:\"https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html\",rel:\"nofollow\",children:\"Marcus Hutchins\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection/\",rel:\"nofollow\",children:\"Guido Miggelenbrink\"}),\" have both written excellent blogs on this topic. This startup race does not exist for security products that utilise \",(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/kernel-etw-best-etw\",rel:\"nofollow\",children:\"kernel ETW\"}),\" for telemetry.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-json\",children:`{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|file.exe|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!ZwProtectVirtualMemory+0x14\" },\n      { \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.exe+0x1bac8\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!RtlAnsiStringToUnicodeString+0x3cb\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!LdrInitShimEngineDynamic+0x394d\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!LdrInitializeThunk+0x1db\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!LdrInitializeThunk+0x63\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!LdrInitializeThunk+0xe\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"path\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.exe\",\n      \"code_signature\": [ { \"exists\": false } ],\n      \"name\": \"file.exe\",\n      \"hash\": { \"sha256\": \"a59a7b56f695845ce185ddc5210bcabce1fff909bac3842c2fb325c60db15df7\" }\n    }\n  }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Pre-entrypoint execution example\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The next pair is KiUserExceptionDispatcher and KiRaiseUserExceptionDispatcher. The kernel uses the former to pass execution to a registered user-mode structured exception handler after a user-mode exception condition has occurred. The latter also raises an exception, but on behalf of the kernel instead. This second variant is usually only caught by debuggers, including \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier\",rel:\"nofollow\",children:\"Application Verifier\"}),\", and helps identify when user-mode code is not sufficiently checking return codes from syscalls. These functions will usually be seen in call stacks related to application-specific crash handling or \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/wer/windows-error-reporting\",rel:\"nofollow\",children:\"Windows Error Reporting\"}),\". However, sometimes malware will use it as a pseudo-breakpoint \\u2014 for example, if they want to \",(0,t.jsx)(e.a,{href:\"https://github.com/elastic/protections-artifacts/blob/3537aa4ed9c7ed9dcd04da2efafbad38af47a017/behavior/rules/windows/defense_evasion_virtualprotect_via_vectored_exception_handling.toml\",rel:\"nofollow\",children:\"fluctuate memory protections\"}),\" to rehide their shellcode immediately after making a system call.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-json\",children:`{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|file.exe|ntdll.dll|file.exe|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      {\n        \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!ZwProtectVirtualMemory+0x14\",\n        \"protection_provenance\": \"file.exe\", /* another vendor's hooks were unhooked */\n        \"allocation_private_bytes\": 8192\n      },\n      { \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.exe+0xd99c\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!RtlInitializeCriticalSectionAndSpinCount+0x1c6\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!RtlWalkFrameChain+0x1119\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!KiUserExceptionDispatcher+0x2e\" },\n      { \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.exe+0x12612\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernel32.dll!BaseThreadInitThunk+0x14\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!RtlUserThreadStart+0x21\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"file.exe\",\n      \"path\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.exe\",\n      \"code_signature\": [ { \"exists\": false }],\n      \"hash\":   { \"sha256\": \"0e5a62c0bd9f4596501032700bb528646d6810b16d785498f23ef81c18683c74\" }\n    }\n  }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Protection fluctuation via exception handler example\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Next is KiUserApcDispatcher, which is used to deliver \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls\",rel:\"nofollow\",children:\"user APCs\"}),\". These are one of the favourite tools of malware authors, as Microsoft only provides limited visibility into its use.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-json\",children:`{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|kernelbase.dll|ntdll.dll|kernelbase.dll|cronos.exe\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!NtProtectVirtualMemory+0x14\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!VirtualProtect+0x36\" }, /* tail call */\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!KiUserApcDispatcher+0x2e\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!ZwDelayExecution+0x14\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!SleepEx+0x9e\" },\n      {\n        \"symbol_info\": \"c:\\\\\\\\users\\\\\\\\user\\\\\\\\desktop\\\\\\\\file.exe+0x107d\",\n        \"allocation_private_bytes\": 147456, /* stomped */\n        \"protection\": \"RW-\", /* fluctuation */\n        \"protection_provenance\": \"Undetermined\", /* proxied call */\n        \"callsite_leading_bytes\": \"010000004152524c8d520141524883ec284150415141baffffffff41525141ba010000004152524c8d520141524883ec284150b9ffffffffba0100000041ffe1\",\n        \"callsite_trailing_bytes\": \"4883c428c3cccccccccccccccccccccccccccc894c240857b820190000e8a10c0000482be0488b052fd101004833c44889842410190000488d84243014000048\"\n      }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"Undetermined\",\n      \"reason\": \"ntdll.dll|kernelbase.dll|ntdll.dll|kernelbase.dll|file.exe\"\n    }\n  }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Protection fluctuation via APC example\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The Windows window manager is implemented in a kernel-mode device driver (win32k.sys). Mostly. Sometimes the window manager needs to do something from user-mode, and KiUserCallbackDispatcher is the mechanism to achieve that. It\\u2019s basically a reverse syscall that targets user32.dll functions. Overwriting an entry in a process\\u2019s \",(0,t.jsx)(e.a,{href:\"https://attack.mitre.org/techniques/T1574/013/\",rel:\"nofollow\",children:\"KernelCallbackTable\"}),\" is an easy way to hijack a GUI thread, so any other module following this call is suspicious.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Knowledge of the purpose of each of these kernel-mode to user-mode entry points greatly assists in determining if a given call stack is natural or if it has been misappropriated to achieve alternative goals.\"}),`\n`,(0,t.jsx)(e.h2,{id:\"making-call-stacks-understandable\",children:\"Making call stacks understandable\"}),`\n`,(0,t.jsx)(e.p,{children:\"To aid understandability, we also tag the event with various process.Ext.api.behaviors that we identify. These behaviours aren\\u2019t necessarily malicious, but they highlight aspects that are relevant to alert triage or threat hunting. For call stacks, these include:\"}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{align:\"left\",children:\"native_api\"}),(0,t.jsx)(e.th,{align:\"left\",children:\"A call was made directly to the Native API rather than the Win32 API.\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"direct_syscall\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"A syscall instruction originated outside of the Native API layer.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"proxy_call\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The call stack may indicate a proxied API call to mask the true source.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"shellcode\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"Second generation executable non-image memory called a sensitive API.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"image_indirect_call\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"An entry in the call stack was preceded by a call to a dynamically resolved function.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"image_rop\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"No call instruction preceded an entry in the call stack.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"image_rwx\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"An entry in the call stack is writable. Code should be read-only.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"unbacked_rwx\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"An entry in the call stack is non-image and writable. Even JIT code should be read-only.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{align:\"left\",children:\"truncated_stack\"}),(0,t.jsx)(e.td,{align:\"left\",children:\"The call stack seems to be unexpectedly truncated. This may be due to malicious tampering or system load.\"})]})]})]})}),`\n`,(0,t.jsx)(e.p,{children:\"In some contexts, these behaviours alone may be sufficient to detect malware.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/assets/images/call-stacks-no-more-free-passes-for-malware/image1.png\",alt:\"SilentMoonwalk variant alerts\",width:\"1999\",height:\"1016\"})}),`\n`,(0,t.jsx)(e.h2,{id:\"spoofing--bypass-or-liability\",children:\"Spoofing \\u2014 bypass or liability?\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Return address spoofing has been a staple \",(0,t.jsx)(e.a,{href:\"https://www.unknowncheats.me/forum/assembly/88648-spoofing-return-address.html\",rel:\"nofollow\",children:\"game hacking\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://www.welivesecurity.com/2013/08/26/nymaim-obfuscation-chronicles/\",rel:\"nofollow\",children:\"malware\"}),\" technique for many, many years. This simple trick allows injected code to borrow the reputation of a legitimate module with few consequences. The goal of deep call stack inspection and behaviour baselines is to stop giving malware this free pass.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Offensive researchers have been assisting this effort by looking into approaches for full call stack spoofing. Most notably:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://labs.withsecure.com/publications/spoofing-call-stacks-to-confuse-edrs\",rel:\"nofollow\",children:\"Spoofing Call Stacks To Confuse EDRs\"}),\" by William Burgess\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/\",rel:\"nofollow\",children:\"SilentMoonwalk: Implementing a dynamic Call Stack Spoofer\"}),\" by Alessandro Magnosi, Arash Parsa and Athanasios Tserpelis\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://media.defcon.org/DEF%20CON%2031/DEF%20CON%2031%20presentations/Alessandro%20klezVirus%20Magnosi%20Arash%20waldoirc%20Parsa%20Athanasios%20trickster0%20Tserpelis%20-%20StackMoonwalk%20A%20Novel%20approach%20to%20stack%20spoofing%20on%20Windows%20x64.pdf\",rel:\"nofollow\",children:\"SilentMoonwalk\"}),\", in addition to being superb offensive research, is an excellent example of how lying can get you into twice the amount of trouble \\u2014 but only if you get caught. Many Defense Evasion techniques rely on security-by-obscurity \\u2014 and once exposed by researchers, they can become a liability. In this case, the research included advice on the detection opportunities \",(0,t.jsx)(e.strong,{children:\"introduced\"}),\" by the evasion attempt.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-json\",children:`{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll|kernelbase.dll|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!NtAllocateVirtualMemory+0x14\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!VirtualAlloc+0x48\" },\n      {\n        \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!CreatePrivateObjectSecurity+0x31\",\n        /* 4883c438 stack desync gadget - add rsp 0x38 */\n        \"callsite_trailing_bytes\": \"4883c438c3cccccccccccccccccccc48895c241057498bd8448bd2488bf94885c90f84660609004885db0f845d060900418bd14585c97411418bc14803c383ea\",\n        \"callsite_leading_bytes\": \"cccccccccccccccccccccccccccccc4883ec38488b4424684889442428488b442460488944242048ff15d9b21b000f1f44000085c00f8830300900b801000000\"\n      },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!Internal_EnumSystemLocales+0x406\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!SystemTimeToTzSpecificLocalTimeEx+0x2d1\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernelbase.dll!WaitForMultipleObjectsEx+0x982\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\kernel32.dll!BaseThreadInitThunk+0x14\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!RtlUserThreadStart+0x21\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"Undetermined\", /* gadget module resulted in suspicious call stack */\n      \"reason\": \"ntdll.dll|kernelbase.dll|kernel32.dll|ntdll.dll\"\n    }\n  }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"SilentMoonwalk call stack example\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A standard technique for unearthing hidden artifacts is to enumerate them using multiple techniques and compare the results for discrepancies. This is \",(0,t.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/sysinternals/downloads/rootkit-revealer#how-rootkitrevealer-works\",rel:\"nofollow\",children:\"how RootkitRevealer works\"}),\". This approach was also used in \",(0,t.jsx)(e.a,{href:\"https://github.com/jdu2600/conference_talks/blob/main/2023-09-bsidescbr-GetInjectedThreadEx.pdf\",rel:\"nofollow\",children:\"Get-InjectedThreadEx.exe\"}),\", which \",(0,t.jsx)(e.a,{href:\"https://github.com/jdu2600/Get-InjectedThreadEx/blob/edbff70fc286a3f1c32c6249b3b913d84d70259b/Get-InjectedThreadEx.cpp#L419-L445\",rel:\"nofollow\",children:\"climbs up the thread stack\"}),\" as well as walking down it.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"In certain circumstances, we may be able to recover a call stack in two ways. If there are discrepancies, then you will see the less reliable call stack emitted as call_stack_summary_original.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-json\",children:`{\n  \"process.thread.Ext\": {\n    \"call_stack_summary\": \"ntdll.dll\",\n    \"call_stack_summary_original\": \"ntdll.dll|kernelbase.dll|version.dll|kernel32.dll|ntdll.dll\",\n    \"call_stack\": [\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!NtContinue+0x12\" },\n      { \"symbol_info\": \"c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\ntdll.dll!LdrInitializeThunk+0x13\" }\n    ],\n    \"call_stack_final_user_module\": {\n      \"name\": \"Undetermined\",\n      \"reason\": \"ntdll.dll\"\n    }\n  }\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Call Stack summary original example\"}),`\n`,(0,t.jsx)(e.h2,{id:\"call-stacks-are-for-everyone\",children:\"Call Stacks are for everyone\"}),`\n`,(0,t.jsx)(e.p,{children:\"By default you will only find call stacks in our alerts, but this is configurable through advanced policy.\"}),`\n`,(0,t.jsx)(e.div,{className:\"table-container\",children:(0,t.jsx)(e.table,{children:(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{align:\"left\",children:\"events.callstacks.emit_in_events\"}),(0,t.jsx)(e.th,{align:\"left\",children:\"If set, call stacks will be included in regular events where they are collected. Otherwise, they are only included in events that trigger behavioral protection rules. Note that setting this may significantly increase data volumes. Default: false\"})]})})})}),`\n`,(0,t.jsx)(e.p,{children:\"Further insights into Windows call stacks is available in the following Elastic Security Labs articles:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/upping-the-ante-detecting-in-memory-threats-with-kernel-call-stacks\",rel:\"nofollow\",children:\"Upping the Ante: Detecting In-Memory Threats with Kernel Call Stacks\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks\",rel:\"nofollow\",children:\"Peeling back the curtain with call stacks\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/doubling-down-etw-callstacks\",rel:\"nofollow\",children:\"Doubling Down: Detecting In-Memory Threats with Kernel ETW Call Stacks\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/itw-windows-lpe-0days-insights-and-detection-strategies\",rel:\"nofollow\",children:\"In-the-Wild Windows LPE 0-days: Insights \u0026 Detection Strategies\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/misbehaving-modalities\",rel:\"nofollow\",children:\"Misbehaving Modalities: Detecting Tools, not Techniques\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.elastic.co/security-labs/finding-truth-in-the-shadows\",rel:\"nofollow\",children:\"Finding Truth in the Shadows\"})}),`\n`]})]})}function x(l={}){let{wrapper:e}=l.components||{};return e?(0,t.jsx)(e,Object.assign({},l,{children:(0,t.jsx)(d,l)})):d(l)}var _=x;return g(v);})();\n;return Component;"},"_id":"articles/call-stacks-no-more-free-passes-for-malware.mdx","_raw":{"sourceFilePath":"articles/call-stacks-no-more-free-passes-for-malware.mdx","sourceFileName":"call-stacks-no-more-free-passes-for-malware.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/call-stacks-no-more-free-passes-for-malware"},"type":"Article","imageUrl":"/assets/images/call-stacks-no-more-free-passes-for-malware/Security Labs Images 33.jpg","readingTime":"19 min read","series":"","url":"/call-stacks-no-more-free-passes-for-malware","headings":[{"level":2,"title":"Call stacks provide the who","href":"#call-stacks-provide-the-who"},{"level":2,"title":"Call stacks are a beautiful lie","href":"#call-stacks-are-a-beautiful-lie"},{"level":2,"title":"Making call stacks beautiful","href":"#making-call-stacks-beautiful"},{"level":2,"title":"**Making call stacks powerful**","href":"#making-call-stacks-powerful"},{"level":2,"title":"A quick call stack glossary","href":"#a-quick-call-stack-glossary"},{"level":2,"title":"Making call stacks understandable","href":"#making-call-stacks-understandable"},{"level":2,"title":"Spoofing — bypass or liability?","href":"#spoofing--bypass-or-liability"},{"level":2,"title":"Call Stacks are for everyone","href":"#call-stacks-are-for-everyone"}],"author":[{"title":"John Uhlmann","slug":"john-uhlmann","description":"Principal Security Research Engineer, Elastic","image":"john-uhlmann.jpg","body":{"raw":"","code":"var Component=(()=\u003e{var l=Object.create;var o=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var p=(n,t)=\u003e()=\u003e(t||n((t={exports:{}}).exports,t),t.exports),f=(n,t)=\u003e{for(var e in t)o(n,e,{get:t[e],enumerable:!0})},c=(n,t,e,i)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let a of g(t))!x.call(n,a)\u0026\u0026a!==e\u0026\u0026o(n,a,{get:()=\u003et[a],enumerable:!(i=h(t,a))||i.enumerable});return n};var _=(n,t,e)=\u003e(e=n!=null?l(j(n)):{},c(t||!n||!n.__esModule?o(e,\"default\",{value:n,enumerable:!0}):e,n)),d=n=\u003ec(o({},\"__esModule\",{value:!0}),n);var m=p((F,s)=\u003e{s.exports=_jsx_runtime});var D={};f(D,{default:()=\u003eC,frontmatter:()=\u003eM});var r=_(m()),M={title:\"John Uhlmann\",description:\"Principal Security Research Engineer, Elastic\",slug:\"john-uhlmann\",image:\"john-uhlmann.jpg\"};function u(n){return(0,r.jsx)(r.Fragment,{})}function y(n={}){let{wrapper:t}=n.components||{};return t?(0,r.jsx)(t,Object.assign({},n,{children:(0,r.jsx)(u,n)})):u(n)}var C=y;return d(D);})();\n;return Component;"},"_id":"authors/john-uhlmann.mdx","_raw":{"sourceFilePath":"authors/john-uhlmann.mdx","sourceFileName":"john-uhlmann.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/john-uhlmann"},"type":"Author","imageUrl":"/assets/images/authors/john-uhlmann.jpg","url":"/authors/john-uhlmann"}],"category":[{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!j.call(t,o)\u0026\u0026o!==r\u0026\u0026s(t,o,{get:()=\u003ee[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var h=(t,e,r)=\u003e(r=t!=null?x(g(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),p=t=\u003ec(s({},\"__esModule\",{value:!0}),t);var i=l((X,u)=\u003e{u.exports=_jsx_runtime});var D={};d(D,{default:()=\u003eC,frontmatter:()=\u003ey});var n=h(i()),y={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"call-stacks-no-more-free-passes-for-malware"},"buildId":"NGlKos1fx5fmfImQxPg_q","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>