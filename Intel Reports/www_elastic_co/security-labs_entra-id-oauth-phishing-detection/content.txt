<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Microsoft Entra ID OAuth Phishing and Detections — Elastic Security Labs</title><meta name="description" content="This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse."/><meta property="og:title" content="Microsoft Entra ID OAuth Phishing and Detections — Elastic Security Labs"/><meta property="og:description" content="This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/entra-id-oauth-phishing-detection/Security Labs Images 22.jpg?4a772e16eae27c1f214996feaabf6497"/><meta property="og:image:alt" content="This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Microsoft Entra ID OAuth Phishing and Detections — Elastic Security Labs"/><meta name="twitter:description" content="This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/entra-id-oauth-phishing-detection/Security Labs Images 22.jpg?4a772e16eae27c1f214996feaabf6497"/><meta name="twitter:image:alt" content="This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse."/><link rel="canonical" href="https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/8e9860b6e62d6359-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/0ea4f4df910e6120-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/739c2d8941231bb4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/a87fdfbf44b3f106.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/a87fdfbf44b3f106.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/1007ff9e696f6f88.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-e159b4ec612933fd.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/877-34f408271ef44c22.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/683-a5053c37fe5bd0c9.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-af957902318b223d.js" defer=""></script><script src="/security-labs/_next/static/chunks/616-0b017b9cfa597392.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-b0c191de1a3710e4.js" defer=""></script><script src="/security-labs/_next/static/4A8XvBW8obAxlgMkcFpOB/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/4A8XvBW8obAxlgMkcFpOB/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_d672da __variable_ead7f7 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><nav class="fixed w-full z-40" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kpm:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R59m:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-06-25T00:00:00.000Z">25 June 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/terrance-dejesus">Terrance DeJesus</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Microsoft Entra ID OAuth Phishing and&nbsp;Detections</span></h1><p class="text-zinc-200 text-base md:text-xl">A crash course on in-the-wild (ItW) Entra ID OAuth phishing and detection strategies</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>40 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Microsoft Entra ID OAuth Phishing and Detections" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fentra-id-oauth-phishing-detection%2FSecurity%20Labs%20Images%2022.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="preamble" class="absolute -top-32"></span>Preamble</h1>
<p>Members of the Threat Research and Detection Engineering (TRADE) team at Elastic have recently turned their attention to an emerging class of threats targeting OAuth workflows in Microsoft Entra ID (previously Azure AD). This research was inspired by Volexity&#x27;s recent blog, <a href="https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/">Phishing for Codes: Russian Threat Actors Target Microsoft 365 OAuth Workflows</a>, which attributes a sophisticated OAuth phishing campaign against NGOs to the threat actor designated <a href="https://malpedia.caad.fkie.fraunhofer.de/actor/uta0352">UTA0352</a>.</p>
<p>Volexity&#x27;s investigation presents compelling forensic evidence of how attackers abused trusted first-party Microsoft applications to bypass traditional defenses. Using legitimate OAuth flows and the open-source tool <a href="https://github.com/dirkjanm/ROADtools">ROADtools</a>, the actors crafted customized Microsoft authentication URLs, harvested security tokens and leveraged them to impersonate users, elevate privilege, and exfiltrate data via Microsoft Graph — including downloading Outlook emails and accessing SharePoint sites.</p>
<p>While their report thoroughly documents the <strong>what</strong> of the attack, our team at Elastic focused on understanding the <strong>how</strong>. We emulated the attack chain in a controlled environment to explore the mechanics of token abuse, device registration, and token enrichment firsthand. This hands-on experimentation yielded deeper insights into the inner workings of Microsoft&#x27;s OAuth implementation, the practical use of ROADtools, recommended mitigations, and most importantly, effective detection strategies to identify and respond to similar activity.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="oauth-in-microsoft-entra-id" class="absolute -top-32"></span>OAuth in Microsoft Entra ID</h1>
<p>Microsoft Entra ID implements OAuth 2.0 to enable delegated access to Microsoft 365 services like Outlook, SharePoint, and Graph API. While the OAuth specification is standardized (<a href="https://datatracker.ietf.org/doc/html/rfc6749">RFC6749</a>), Entra ID introduces unique behaviors and token types that influence how delegated access works and how adversaries exploit them.</p>
<p>In delegated access, an application is authorized to act on behalf of a signed-in user, constrained by scopes (permissions) the app requests and the user or admin consents to. This model is common in enterprise environments where apps retrieve a user&#x27;s emails, files, or directory data without prompting for credentials each time.</p>
<p>A typical delegated authorization flow includes:</p>
<p><strong>Authorization request (OAuth 2.0 Authorization Code Grant)</strong>: The app requests access to a resource (e.g., Graph) with specific scopes (e.g., Mail.Read, offline_access). These are added as parameters to the URI.</p>
<ul>
<li><em>client_id</em>: The application’s ID (e.g., VSCode)</li>
<li><em>Response_type</em>: Determines the grant type OAuth workflow (e.g. device code, auth code)</li>
<li><em>Scope</em>: Permissions requested for the target resource (e.g. <em>Mail.Read, offline_access)</em></li>
<li><em>Redirect_uri</em>: Where to send our authorization codes</li>
<li><em>State</em>: CSRF protection</li>
<li><em>Login_hint</em>: Pre-fills username</li>
</ul>
<p><strong>User authentication (OpenID Connect)</strong>: Entra ID authenticates the user via policy (password, MFA, device trust).</p>
<ul>
<li>Single-Factor Authentication (SFA)</li>
<li>Multi-factor Authentication (MFA)</li>
<li>Device Trust (Hybrid Join, Intune compliance)</li>
<li>Conditional Access Policies (CAP)</li>
<li>Single Sign-On (SSO)</li>
</ul>
<p><strong>Consent:</strong> Consent governs whether the app can receive an authorization code and what scopes are permitted.</p>
<ul>
<li>User-consentable scopes (e.g. <em>Mail.Read, offline_access)</em></li>
<li>Admin-Consent required scopes (e.g. <em>Directory.ReadWrite</em>) requires elevated approval.</li>
</ul>
<p><strong>Token issuance</strong>: The app receives an authorization code, then redeems it for :</p>
<ul>
<li>Access Token – short-lived token used to call APIs like Graph.</li>
<li>Refresh Token (RT) – longer-lived token to obtain new access tokens silently.</li>
<li>Identity Token - Describes authenticated user; present in OpenID flows.</li>
<li>(Optional) Primary Refresh Token: If the user is on a domain-joined or registered device, a Primary Refresh Token (PRT) may enable silent SSO and additional token flows without user interaction.</li>
<li><strong>Token claims:</strong> Claims are key-value pairs embedded in JWT tokens that describe the user, app, device, scopes and context of the authentication.</li>
</ul>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="what-defines-an-msft-oauth-phishing-url" class="absolute -top-32"></span>What Defines an MSFT OAuth Phishing URL</h1>
<p>Before diving into key findings from Volexity&#x27;s report that help shape our detection strategy, it&#x27;s important to break down what exactly defines a Microsoft OAuth phishing URL.</p>
<p>As described earlier, Microsoft Entra ID relies on these URLs to determine which application (client) is requesting access, on behalf of which user principal, to what resource, and with what permissions. Much of this context is embedded directly in the query parameters of the OAuth authorization request,  making them a critical source of metadata for both adversaries and defenders.</p>
<p>Here&#x27;s an example of a phishing URL aligned with the authorization code grant flow, adapted from Volexity&#x27;s blog:</p>
<pre><code>https://login.microsoftonline[.]com/organizations/oauth2/v2.0/authorize?state=https://mae.gov[.]ro/[REMOVED]&amp;client_id=aebc6443-996d-45c2-90f0-388ff96faa56&amp;scope=https://graph.microsoft.com/.default&amp;response_type=code&amp;redirect_uri=https://insiders.vscode.dev/redirect&amp;login_hint=&lt;EMAIL HERE&gt;</code></pre>
<p>Let&#x27;s break down some of the key components:</p>
<ul>
<li>login.microsoftonline.com – The global Microsoft Entra ID authentication endpoint.</li>
<li>/oauth2/v2.0/authorize - MSFT Entra ID OAuth v2.0 endpoint for authorization workflows</li>
<li>state – Optional value used to prevent CSRF and maintain application state. Sometimes abused to obfuscate phishing redirections.</li>
<li>client_id – The application ID making the request. This could belong to Microsoft first-party apps (like VSCode, Teams) or malicious third-party apps registered by adversaries.</li>
<li>scope – Defines the permissions the application is requesting (e.g., Mail.Read, offline_access). The .default scope is often used for client credential flows to get pre-consented permissions.</li>
<li>response_type=code – Indicates the flow is requesting an authorization code, which can later be exchanged for an access and/or refresh token.</li>
<li>redirect_uri – Where Entra ID will send the response after the user authenticates. If an attacker controls this URI, they gain the code or it is a MSFT-managed URI that is valid.</li>
<li>login_hint – Specifies the target user (e.g., alice @ tenant.onmicrosoft.com). Often pre-filled to lower friction during phishing.</li>
</ul>
<p>Note: While this example illustrates a common Microsoft Entra ID OAuth phishing URL, there are many variations. Adversaries may adjust parameters such as the client ID, scopes, grant types or redirect URIs depending on their specific objectives, whether it&#x27;s to gain persistent access, exfiltrate emails, or escalate privileges via broader consent grants.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="why-does-this-matter" class="absolute -top-32"></span>Why Does This Matter?</h2>
<p>Because these parameters are customizable, adversaries can easily swap out values to suit their operation. For example:</p>
<ul>
<li>They might use a legitimate Microsoft client ID to blend in with benign applications.</li>
<li>They may use a .default scope to bypass specific consent prompts.</li>
<li>They’ll point the redirect_uri to a site under their control to collect the authorization code.</li>
<li>They can target specific user principals they may have identified during reconnaissance.</li>
<li>They can adjust permissions to target resources based on their operational needs.</li>
</ul>
<p>Once a target authenticates, the goal is simple – obtain an authorization code. This code is then exchanged (often using tools like ROADtools) for a refresh token and/or access token, enabling the attacker to make Graph API calls or pivot into other Microsoft 365 services, all without further user interaction.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="abstraction-of-volexitys-key-findings" class="absolute -top-32"></span>Abstraction of Volexity&#x27;s Key Findings</h1>
<p>For threat detection, it is critical to understand the protocols like OAuth, workflow implementation in Microsoft Entra ID, and contextual metadata about the behaviors and/or steps taken by the adversary regarding this operation.</p>
<p>From Volexity&#x27;s investigation and research, we can key in the different variations of OAuth phishing reported. We decided to break these down for easier understanding:</p>
<p><strong>OAuth Phishing To Access Graph API as VSCode Client On-Behalf-Of Target User Principal</strong>: These URLs are similar to our example “What Defines an MSFT OAuth Phishing URL” – the end game goal being an access token to Graph API with default permissions.</p>
<ul>
<li>OAuth phishing URLs were custom, pointing to &quot;authorize&quot; endpoint</li>
<li>Client IDs were specifically VSCode (&quot;aebc6443-996d-45c2-90f0-388ff96faa56&quot;)</li>
<li>Resource/Scope was MSFT Graph (&quot;<a href="https://graph.microsoft.com/.default">https://graph.microsoft.com/.default</a>&quot;) with .default permissions</li>
<li>Token grant flows were auth code (response_type=code)</li>
<li>Redirect URIs were for legitimate MSFT domains (insiders[.]vscode[.]dev or vscode-redirect[.]azurewebsites[.]net)</li>
<li>Login hints were the specific user principal being targeted (not service principals)</li>
<li>Adversary required the target to open the URL, authenticate and share the authorization code (1.AXg….)</li>
</ul>
<p>From here, the adversary would be able to make a request to MSFT&#x27;s OAuth token endpoint (<em><a href="https://login.microsoftonline.com/%5Btenant_id%5D/oauth2/v2.0/token">https://login.microsoftonline.com/[tenant_id]/oauth2/v2.0/token</a></em>) and exchange the refresh token for an access token. This is enough to allow the adversary to access Graph API and access resources normally available to the user. These indicators will be crucial to factoring our detection and hunting strategies later on in this blog.</p>
<p><strong>OAuth Phishing for Device Registration as MSFT Auth Broker</strong>: These URLs are unique as they are chained with subsequence ROADtools usage to register a virtual device, exchange an RT for a PRT, and require PRT enrichment to accomplish email access via Graph API and Sharepoint access.</p>
<ul>
<li>OAuth phishing URLs were custom, pointing to authorize (<em><a href="https://login.microsoftonline.com/%5Btenant_id%5D/oauth2/v2.0/authorize">https://login.microsoftonline.com/[tenant_id]/oauth2/v2.0/authorize</a></em>) endpoint</li>
<li>Client IDs were specifically MSFT Authentication Broker (&quot;29d9ed98-a469-4536-ade2-f981bc1d605e&quot;)</li>
<li>Resource/Scope was Device Registration Service (DRS) (&quot;01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9&quot;)</li>
<li>Token grant flows were auth code (response_type=code)</li>
<li>Redirect URI includes cloud-based domain join endpoint (typically used during Windows setup or Autopilot)</li>
<li>Login hint contains user principal email address (Target)</li>
<li>Request is ultimately for an ADRS token</li>
</ul>
<p>If the user is phished and opens the URL, authenticating will provide an ADRS token that is required for the adversary to register a device and subsequently obtain a PRT with the device’s private key and PEM file.</p>
<p>Volexity&#x27;s blog also includes additional information about tracking the activity of the compromise identity via the device ID registered as well as post-compromise activity following an approved 2FA request was identified, allowing the adversary to download the target&#x27;s email with a session tied to the newly registered device.</p>
<p>With this understanding of each phishing attempt, our next goal is to replicate this in our own MSFT tenant as accurately as possible to gather data for plausible detections.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="our-emulation-efforts" class="absolute -top-32"></span>Our Emulation Efforts</h1>
<p>Alright – so at this point, we’ve covered the fundamentals of OAuth and how Microsoft Entra ID implements it. We broke down what defines a Microsoft OAuth phishing URL, decoded its critical parameters, and pulled key insights from Volexity&#x27;s excellent investigation to identify indicators aligned with these phishing workflows.</p>
<p>But theory and a glimpse into Volexity&#x27;s notebook only takes us so far.</p>
<p>To truly understand the attacker&#x27;s perspective, the full chain of execution, tooling quirks, subtle pitfalls, and opportunities for abuse,  we decided to go hands-on with whitebox testing. We recreated the OAuth phishing process in our own tenant, emulating everything from token harvesting to resource access. The goal? Go beyond static indicators and surface the behavioral breadcrumbs that defenders can reliably detect.</p>
<p>Let&#x27;s get into it.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="prerequisites" class="absolute -top-32"></span>Prerequisites</h2>
<p>For starters, it is good to share some details about our threat research and detection environment in Azure.</p>
<ul>
<li>Established Azure tenant: TENANT.onmicrosoft.com</li>
<li>Established Sharepoint Domain: DOMAIN.sharepoint.com</li>
<li>Native IdP Microsoft Entra ID – Enabling our IAM</li>
<li>Microsoft 365 Licenses (P2) for All Users</li>
<li>Azure Activity Logs Streaming to EventHub</li>
<li>Microsoft Entra ID Sign-In Logs Streaming to EventHub</li>
<li>Microsoft Entra ID Audit Logs Streaming to EventHub</li>
<li>Microsoft Graph Audit Logs Streaming to EventHub</li>
<li>Microsoft 365 Audit Logs Streaming to EventHub</li>
<li>Elastic Azure and M365 Integration Enabled for Log Digestion from EventHub</li>
<li>Basic Admin User Enabled with CAP Requiring MFA</li>
<li>MSFT Authenticator App on Mobile for 2FA Emulation</li>
<li>Windows 10 Desktop with NordVPN (Adversary Box)</li>
<li>macOS endpoint (Victim box)</li>
</ul>
<p>Note that while we could follow the workflows from a single endpoint, often we need data that reflects separate source addresses to developer detection variations of impossible travel.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="scenario-1-oauth-phishing-as-vscode-client" class="absolute -top-32"></span>Scenario 1: OAuth Phishing as VSCode Client</h1>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="emulation" class="absolute -top-32"></span>Emulation</h2>
<p>To emulate the phishing technique documented by Volexity, we built a Python script to generate an OAuth 2.0 authorization URL using Microsoft Entra ID. The URL initiates an authorization code grant flow, impersonating the first-party Visual Studio Code app to request delegated access to the Microsoft Graph API.</p>
<p>We configured the URL with the following parameters:</p>
<pre><code>{
  &quot;client_id&quot;: &quot;aebc6443-996d-45c2-90f0-388ff96faa56&quot;,
  &quot;response_type&quot;: &quot;code&quot;,
  &quot;redirect_uri&quot;: &quot;insiders.vscode.dev/redirect&quot;,
  &quot;scope&quot;: &quot;https://graph.microsoft.com/.default&quot;,
  &quot;login_hint&quot;: &quot;user @ tenant.onmicrosoft.com&quot;,
  &quot;prompt&quot;: &quot;select_account&quot;,
  &quot;state&quot;: &quot;nothingtoseehere&quot;
}</code></pre>
<p><em>Figure 1: Parameters for OAuth Phishing URL</em></p>
<p>This URL is shared with the target (in our case, a MacOS test user). When opened, it authenticates the user and completes the OAuth workflow. Using browser developer tools, we capture the authorization code returned in the redirect URI,  exactly what the attackers asked their victims to send back.</p>
<p></p>
<p></p>
<p>After receiving the code, we issue a POST request to:</p>
<pre><code>{token_url: &quot;https://login.microsoftonline.com/organizations/oauth2/v2.0/token&quot;}</code></pre>
<p>This exchange uses the authorization_code grant type, passing the code, client ID, and redirect URI. Microsoft returns an access token, but no refresh token. You might ask why that is?</p>
<p>The scope <a href="https://graph.microsoft.com/.default">https://graph.microsoft.com/.default</a> instructs Microsoft to issue a bearer token for all Graph permissions already granted to the VSCode app on behalf of the user. This is a static scope, pulling from the app registration,  it does not include dynamic scopes like Mail.Read or offline_access.</p>
<p>Microsoft&#x27;s documentation states:</p>
<p>““<em>Clients can’t combine static (.default) consent and dynamic consent in a single request.</em>””</p>
<p>Therefore, trying to include offline_access alongside <em>.default</em> results in an error. If the attacker wants a refresh token, they must avoid <em>.default</em> and instead explicitly request <em>offline_access</em> and the required delegated scopes (e.g., Mail.Read) – Assuming the app registration supports those.</p>
<p>With the access token in hand, we pivoted to a second script to interact with the Microsoft Graph API. The goal – extract email messages from the victim’s account — just as the attacker would.</p>
<p>To do this, we included the access token as a Bearer JWT in the authorization header and made a GET request to the following endpoint:</p>
<pre><code>{graph_url: &quot;https://graph.microsoft.com/v1.0/me/messages&quot;}</code></pre>
<p>The response returns a JSON array of email objects. From here, we simply iterate through the results and parse out useful metadata such as sender, subject, and received time.</p>
<p></p>
<p>To test the token’s broader privileges, we also attempted to enumerate SharePoint sites using:</p>
<pre><code>{graph_search_url: &quot;https://graph.microsoft.com/v1.0/sites?search=*&quot;}</code></pre>
<p>The request failed with an access denied error – which leads us to an important question: why did email access work, but SharePoint access did not? The reason is that the first-party client (VSCode: aebc6443-996d-45c2-90f0-388ff96faa56) does not have default delegated permissions with Graph for Sharepoint – as predefined by Microsoft. Therefore, we know the adversary is limited on what they can access.</p>
<p>To ensure this was accurate, we decoded the access token to identify the SCP associated with VSCode with <em>.default</em> permissions to Graph – Verifying no <em>Sites.</em>* permissioned by Microsoft.</p>
<p></p>
<p>This is one of the variations described by Volexity, but does help us understand more about the processes behind the scenes for the adversary – as well as resources, OAuth, and more for Microsoft Entra ID.</p>
<p>With the emulation complete, we now turn to identifying high-fidelity signals that are viable for SIEM detection and threat hunting. Our focus is on behavior observables in Microsoft Entra ID and Microsoft Graph logs.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="detection" class="absolute -top-32"></span>Detection</h2>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="signal-1---microsoft-entra-id-oauth-phishing-as-visual-studio-code-client" class="absolute -top-32"></span>Signal 1 - Microsoft Entra ID OAuth Phishing as Visual Studio Code Client</h4>
<p>A successful OAuth 2.0 (authorization) and OpenID Connect (authentication) flow was completed using the first-party Microsoft application Visual Studio Code (VSCode). The sign-in occurred on behalf of the phished user principal, resulting in delegated access to Microsoft Graph with <em>.default</em> permissions.</p>
<pre><code>event.dataset: &quot;azure.signinlogs&quot; and
event.action: &quot;Sign-in activity&quot; and
event.outcome: &quot;success&quot; and
azure.signinlogs.properties.user_type: &quot;Member&quot; and
azure.signinlogs.properties.authentication_processing_details: *Oauth* and
azure.signinlogs.category: &quot;NonInteractiveUserSignInLogs&quot; and
(
  azure.signinlogs.properties.resource_display_name: &quot;Microsoft Graph&quot; or
  azure.signinlogs.properties.resource_id: &quot;00000003-0000-0000-c000-000000000000&quot;
) and (
  azure.signinlogs.properties.app_id: &quot;aebc6443-996d-45c2-90f0-388ff96faa56&quot; or
  azure.signinlogs.properties.app_display_name: &quot;Visual Studio Code&quot;
)</code></pre>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="signal-2---microsoft-entra-session-reuse-with-suspicious-graph-access" class="absolute -top-32"></span>Signal 2 - Microsoft Entra Session Reuse with Suspicious Graph Access</h4>
<p>While traditional query languages like KQL are excellent for filtering and visualizing individual log events, they struggle when a detection relies on correlating multiple records across datasets, time, and identifiers. This is where ES|QL (Elasticsearch Query Language) becomes essential. These types of multi-event correlations, temporal logic, and field normalization are difficult or entirely impossible in static filter-based query languages like KQL without writing multiple disjointed queries and manually correlating them after the fact.</p>
<p>This detection relies on correlating multiple events that happen close together but from different data sources,  namely sign-in logs and Microsoft Graph activity. The goal is to find suspicious reuse of the same session ID across multiple IPs, potentially indicating session hijacking or token abuse. For the sake of space regarding this publication, you can view the actual detection rule in the Detection Rules section. To better illustrate the flow of the query and meaning, below is a diagram to illustrate at a higher level.</p>
<pre><code>[ FROM logs-azure.* ]
        |
        |  ← Pulls events from all relevant Microsoft Cloud datasets:
        |     - azure.signinlogs (authentication)
        |     - azure.graphactivitylogs (resource access)
        ↓
[ WHERE session_id IS NOT NULL AND IP NOT MICROSOFT ASN ]
        |
        |  ← Filters out Microsoft-owned infrastructure (e.g., internal proxy,
        |     Graph API relays) using ASN checks.
        |  ← Ensures session ID exists so events can be correlated together.
        ↓
[ EVAL session_id, event_type, time_window, etc. ]
        |
        |  ← Normalizes key fields across datasets:
        |     - session_id (from signin or Graph)
        |     - user ID, app ID, event type (&quot;signin&quot; or &quot;graph&quot;)
        |  ← Buckets events into 5-minute windows using DATE_TRUNC()
        ↓
[ KEEP selected fields ]
        |
        |  ← Retains only what&#x27;s needed:
        |     session_id, timestamp, IP, user, client ID, etc.
        ↓
[ STATS BY session_id + time_window ]
        |
        |  ← Groups by session and time window to compute:
        |     - unique IPs used
        |     - apps involved
        |     - first and last timestamps
        |     - whether both signin and graph occurred
        ↓
[ EVAL time_diff + signin_to_graph_delay ]
        |
        |  ← Calculates:
        |     - time_diff: full session duration
        |     - delay: gap between signin and Graph access
        ↓
[ WHERE types_count &gt; 1 AND unique_ips &gt; 1 AND delay &lt;= 5 ]
        |
        |  ← Flags sessions where:
        |     - multiple event types (signin + graph)
        |     - multiple IPs used
        |     - all occurred within 5 minutes
        ↓
[ Output = Suspicious Session Reuse Detected ]</code></pre>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="signal-3---microsoft-entra-id-concurrent-sign-ins-with-suspicious-properties" class="absolute -top-32"></span>Signal 3 - Microsoft Entra ID Concurrent Sign-Ins with Suspicious Properties</h4>
<p>This detection identifies suspicious sign-ins in Microsoft Entra ID where a user authenticates using the device code flow without MFA or sign-ins using the VSCode client. When the same identity signs in from two or more distinct IPs within a short time window using either method, it may indicate token replay, OAuth phishing, or adversary-in-the-middle (AitM) activity.</p>
<pre><code>[ FROM logs-azure.signinlogs* ]
        |
        |  ← Pulls only Microsoft Entra ID sign-in logs
        ↓
[ WHERE @timestamp &gt; NOW() - 1h AND event.outcome == &quot;success&quot; ]
        |
        |  ← Filters to the last hour and keeps only successful sign-ins
        ↓
[ WHERE source.ip IS NOT NULL AND identity IS NOT NULL ]
        |
        |  ← Ensures the sign-in is tied to a user and IP for correlation
        ↓
[ KEEP fields: identity, app_id, auth_protocol, IP, etc. ]
        |
        |  ← Retains app/client, IP, auth method, and resource info
        ↓
[ EVAL detection flags ]
        |
        |  ← Labels events as:
        |     - device_code: if MFA not required
        |     - visual_studio: if VS Code client used
        |     - other: everything else
        ↓
[ STATS BY identity ]
        |
        |  ← Aggregates all sign-ins per user, calculates:
        |     - IP count
        |     - Device Code or VSCode usage
        |     - App/client/resource details
        ↓
[ WHERE src_ip &gt;= 2 AND (device_code_count &gt; 0 OR vsc &gt; 0) ]
        |
        |  ← Flags users with:
        |     - Sign-ins from multiple IPs
        |     - And either:
        |         - Device Code w/o MFA
        |         - Visual Studio Code app
        ↓
[ Output = Potential OAuth Phishing or Token Misuse ]</code></pre>
<p>While this variation of OAuth phishing lacks the full persistence offered by refresh tokens or PRTs, it still provides adversaries with valuable one-time access to sensitive user data – such as emails – through legitimate channels. This exercise helps us understand the limitations and capabilities of static <em>.default</em> scopes, the influence of app registrations, and how Microsoft Graph plays a pivotal role in post-authentication. It also reinforces a broader lesson: not all OAuth phishing attacks are created equal. Some aim for longevity (as we will see later) through refresh tokens or device registration, while others focus on immediate data theft via first-party clients. Understanding the nuances is essential for accurate detection logic.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="scenario-2-oauth-phishing-for-device-registration" class="absolute -top-32"></span>Scenario 2: OAuth Phishing for Device Registration</h1>
<p>As we stated earlier – Volexity also reported a separate phishing playbook targeting victims, this time with the goal of registering a virtual device and obtaining a PRT. While this approach requires more steps from the adversary, the payoff is a token-granting token that offers far more utility for completing their operations. For our emulation efforts, we needed to expand our toolset and rely on ROADtools, just as the adversary did to remain accurate, however, several other python scripts were made for initial phishing and post-compromise actions.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="emulation-1" class="absolute -top-32"></span>Emulation</h2>
<p>Starting with the initial phishing, we adjusted our Python script to craft a different OAuth URL that would be sent to our victim. This time, the focus was on our first-party client ID being the Microsoft Authentication Broker, requesting a refresh token with <em>offline_access</em> and redirecting to Entra ID’s cloud domain device joining endpoint URI.</p>
<pre><code>{
  &quot;client_id&quot;: &quot;29d9ed98-a469-4536-ade2-f981bc1d605e&quot;,
  &quot;response_type&quot;: &quot;code&quot;,
  &quot;response_mode&quot;: &quot;query&quot;,
  &quot;redirect_uri&quot;: &quot;https://login.microsoftonline.com/WebApp/CloudDomainJoin/8&quot;,
  &quot;resource&quot;: &quot;01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9&quot;,
  &quot;state&quot;: &quot;nothingtoseehere&quot;
}</code></pre>
<p>If successful and our victim authenticates, the OAuth workflow will complete and the user will be redirected to the specified URI with an appended authorization code in the query parameters. Again, this code is the critical piece,  it must be shared back with the adversary in order to exchange it for tokens. In our case, once the phishing URL is opened and the target authenticates, we capture the authorization code embedded in the redirect and use it to request tokens from the Microsoft Entra ID token endpoint.</p>
<p></p>
<p>Now, here&#x27;s where it gets interesting. In response to the token request, we receive three types of tokens: an access token, a refresh token, and an ID token. You might be asking –  why do we get more than just an access token? The answer lies in the scopes we initially requested: <em>openid</em>, <em>offline_access</em>, and <em>profile</em>.</p>
<ul>
<li><em>openid</em> grants us an ID token, which is part of the OpenID Connect layer and confirms the identity of the user — this is your authentication (authN) artifact.</li>
<li><em>offline_access</em> provides a refresh token, enabling us to maintain a session and request new access tokens without requiring re-authentication, this supports persistent access but is critical for our use with ROADtx.</li>
<li>And the access token itself is used to authorize requests to protected APIs like Microsoft Graph, this represents authorization (authZ).</li>
</ul>
<p>With these three tokens, we have everything: authentication, authorization, and long-term session continuity. That’s enough to shift from a simple OAuth phishing play into a more persistent foothold — like registering a new device in Microsoft Entra ID.</p>
<p></p>
<p>Now let’s connect the dots. A PRT requires registration of a valid device, one that Entra ID recognizes via a device certificate and private key. This is where ROADtx comes into play. Because our initial OAuth phishing impersonated a joined device flow, and the client used was the Microsoft Authentication Broker (a first-party client that interacts with the Device Registration Service), we already have the right access token in hand to interact with DRS. Notice in our returned object the scope is <em>adrs_access</em> which indicates Azure DRS access and is important for detections later.</p>
<p>From here, we simply drop the JSON object received from our token exchange into the <em>.roadtool_auth</em> file. This file is natively consumed by ROADtools, which uses the stored tokens to perform the device registration, completing the adversary’s move into persistence and setting the stage for obtaining a valid PRT.</p>
<p>After obtaining the tokens, we prep them for ROADtx by reformatting the JSON. ROADtx expects keys in camelCase, and we must also include the Microsoft Authentication Broker’s client ID as <em>_clientId</em>. This setup allows us to run the <em>refreshtokento</em> command, which takes our refresh token and exchanges it for a new JWT scoped to the DRS — specifically, the service principal <em>urn:ms-drs:enterpriseregistration.windows.net</em>.</p>
<p></p>
<p>Once that’s in place, we use the device command to simulate a new device registration. This operation doesn’t require any actual virtual machine or physical host because it’s a backend registration that simply creates an entry in Entra ID. Upon success, we’re issued a valid device ID, PEM-encoded certificate, and private key — all of which are required to simulate a valid hybrid-joined device in the Microsoft ecosystem.</p>
<p></p>
<p>With our device identity established, we invoke the <em>prt</em> command. This uses the refresh token, device certificate, and private key to mint a new PRT — a highly privileged credential that effectively ties together user and device trust in Microsoft Entra ID.</p>
<p></p>
<p>And just like that — whollah! — we have a PRT.</p>
<p>But why go through all this? Why register a device, generate a cert, and obtain a PRT when we already had an access token, ID token, and refresh token?</p>
<p>Because the PRT is the key to full user and device identity emulation. Think of it as a Kerberos-like ticket-granting token in Entra ID’s world, but instead – a token-granting token. With a valid PRT:</p>
<ul>
<li>An adversary can request new access and ID tokens for first-party apps like Outlook, SharePoint, or Teams without needing user interaction.</li>
<li>The PRT enables seamless single sign-on SSO across multiple services, bypassing MFA and other conditional access policies (CAP) that would typically re-prompt the user. This is crucial for persistence as CAP and MFA are often huge barriers for adversaries.</li>
<li>It supports long-lived persistence, as the PRT can be silently renewed and leveraged across sessions as long as the device identity remains trusted.</li>
</ul>
<p>And perhaps most dangerously — the PRT allows adversaries to impersonate a fully compliant, domain-joined device and user combo, effectively bypassing most conventional detection and response controls making the line between benign vs suspicious extremely thin for hunters and analysts.</p>
<p>This makes the PRT an incredibly valuable asset or one that enables covert lateral movement, privilege escalation, and deep access to Microsoft 365 services. It’s not just about getting in anymore — it’s about staying undetected.</p>
<p>Let’s not forget post-compromise activity…</p>
<p>ROADtx offers a few powerful commands frequently used by adversaries – <em>prtenrich</em> and <em>browserprtauth</em>. For example, we can access most browser-based UI services in the Microsoft suite by supplying our PRT which includes the necessary metadata for authentication and authorization – which originally belonged to our phishing victim (me), but is actually the Microsoft Authentication Broker acting on their behalf.</p>
<p></p>
<p>Volexity also reported that following device registration and the PRT acquisition – a 2FA request was sent to the initial victim, approved and then used to access emails via SharePoint. While they do not specify exactly how requests were made to – it’s reasonable to assume the adversary used the PRT to authenticate via a first-party Microsoft client – with the actual data access happening through Microsoft Graph. Graph remains a popular target post-compromise because it serves as a central API hub for most Microsoft 365 resources.</p>
<p>To start – let’s leverage ROADtx to auth with our PRT where Microsoft Teams is our client and Microsoft Graph is our resource. When using the <em>prtauth</em> command with our PRT, we are able to obtain a new access token and refresh token – clearly demonstrating the utility of the PRT as a token-granting token within Microsoft’s identity fabric.</p>
<p></p>
<p>Once our access token is obtained, we plug it into a custom Python script to start enumerating our SharePoint sites, drives, items which allows us to identify files of interest and download their contents.</p>
<p></p>
<p>With this emulation – we showed how adversaries can chain OAuth phishing with the Microsoft Authentication Broker and obtain necessary credential material to leverage ROADtx for acquiring a PRT. This PRT then being an important utility post-compromise to access sensitive files, enumerate tenant resources and much more.</p>
<p>Now, let’s shift focus: what are plausible and accurate signals for detecting this activity?</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="detection-1" class="absolute -top-32"></span>Detection</h2>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="signal-1---microsoft-entra-id-oauth-phishing-as-microsoft-authentication-broker" class="absolute -top-32"></span>Signal 1 - Microsoft Entra ID OAuth Phishing as Microsoft Authentication Broker</h3>
<p>Identifies instances where a user principal initiates an OAuth authorization code flow using the Microsoft Authentication Broker (MAB) as the client and the Device Registration Service (DRS) as the target resource. This detection focuses on cases where a single session ID is reused across two or more distinct IP addresses within a short time window, and at least one request originates from a browser — behavior commonly associated with phishing.</p>
<pre><code>[ FROM logs-azure.signinlogs-* ]
        |
        |  ← Pulls all Microsoft Entra ID sign-in logs
        ↓
[ WHERE app_id == MAB AND resource_id == DRS ]
        |
        |  ← Filters to OAuth auth code requests targeting
        |     Microsoft Authentication Broker + Device Reg Service
        ↓
[ EVAL session_id + is_browser ]
        |
        |  ← Extracts session ID and flags browser-based activity
        ↓
[ STATS BY 30-minute window, user, session_id ]
        |
        |  ← Groups logins within same session and time window,
        |     then aggregates:
        |       - user/session/token identifiers
        |       - distinct IPs and geo info
        |       - user agent, browser presence
        |       - app/resource/client info
        ↓
[ WHERE ip_count ≥ 2 AND session_id_count == 1 ]
        |
        |  ← Identifies reuse of a single session ID
        |     across ≥ 2 different IP addresses
        ↓
[ AND has_browser ≥ 1 AND auth_count ≥ 2 ]
        |
        |  ← Requires at least one browser-based request
        |     and at least two total sign-in events
        ↓
[ Output = Suspicious OAuth Flow with Auth Broker for DRS ]</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="signal-2---suspicious-adrs-token-request-by-microsoft-auth-broker" class="absolute -top-32"></span>Signal 2 - Suspicious ADRS Token Request by Microsoft Auth Broker</h3>
<p>Identifies Microsoft Entra ID sign-in events where a user principal authenticates using a refresh token issued to the Microsoft Authentication Broker (MAB) client, targeting the Device Registration Service (DRS) with the <em>adrs_access</em> OAuth scope. This pattern may indicate token-based access to DRS following an initial authorization code phishing or device registration flow.</p>
<pre><code>event.dataset: &quot;azure.signinlogs&quot; and azure.signinlogs.properties.app_id : &quot;29d9ed98-a469-4536-ade2-f981bc1d605e&quot; and azure.signinlogs.properties.resource_id : &quot;01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9&quot; and azure.signinlogs.properties.authentication_processing_details.`Oauth Scope Info`: *adrs_access* and azure.signinlogs.properties.incoming_token_type: &quot;refreshToken&quot; and azure.signinlogs.properties.user_type: &quot;Member&quot;</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="signal-3---unusual-device-registration-in-entra-id" class="absolute -top-32"></span>Signal 3 - Unusual Device Registration in Entra ID</h3>
<p>Detects a sequence of Entra ID audit log events indicating potential malicious device registration activity using a refresh token, commonly seen after OAuth phishing. This pattern mimics the behavior of tools like ROADtx, where a newly registered Windows device (with a hardcoded OS version 10.0.19041.928) is added by the Device Registration Service, followed by user and owner assignments. All events must share the same correlation ID and occur within a one-minute window, strongly suggesting automation or script-driven registration rather than legitimate user behavior.</p>
<pre><code>sequence by azure.correlation_id with maxspan=1m
[any where event.dataset == &quot;azure.auditlogs&quot; and azure.auditlogs.identity == &quot;Device Registration Service&quot; and azure.auditlogs.operation_name == &quot;Add device&quot; and azure.auditlogs.properties.additional_details.value like &quot;Microsoft.OData.Client/*&quot; and (
  azure.auditlogs.properties.target_resources.`0`.modified_properties.`1`.display_name == &quot;CloudAccountEnabled&quot; and 
azure.auditlogs.properties.target_resources.`0`.modified_properties.`1`.new_value: &quot;[true]&quot;) and azure.auditlogs.properties.target_resources.`0`.modified_properties.`3`.new_value like &quot;*10.0.19041.928*&quot;]
[any where event.dataset == &quot;azure.auditlogs&quot; and azure.auditlogs.operation_name == &quot;Add registered users to device&quot; and azure.auditlogs.properties.target_resources.`0`.modified_properties.`2`.new_value like &quot;*urn:ms-drs:enterpriseregistration.windows.net*&quot;]
[any where event.dataset == &quot;azure.auditlogs&quot; and azure.auditlogs.operation_name == &quot;Add registered owner to device&quot;]</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="signal-3---entra-id-rt-to-prt-transition-from-same-user-and-device" class="absolute -top-32"></span>Signal 3 - Entra ID RT to PRT Transition from Same User and Device</h3>
<p>This detection identifies when a Microsoft Entra ID user first authenticates using a refresh token issued to the Microsoft Authentication Broker (MAB), followed shortly by the use of a Primary Refresh Token (PRT) from the same device. This sequence is rare in normal user behavior and may indicate an adversary has successfully registered a device and escalated to persistent access using tools like ROADtx. By filtering out activity tied to the Device Registration Service (DRS) in the second step, the rule focuses on post-registration usage of the PRT to access other Microsoft 365 services.</p>
<p>This behavior strongly suggests token-based compromise and long-term session emulation, particularly when device trust is established silently. Catching this transition from refresh token to PRT is critical for surfacing high-fidelity signals of OAuth phishing and post-compromise persistence.</p>
<pre><code>sequence by azure.signinlogs.properties.user_id, azure.signinlogs.properties.device_detail.device_id with maxspan=1d
  [authentication where 
    event.dataset == &quot;azure.signinlogs&quot; and
    azure.signinlogs.category == &quot;NonInteractiveUserSignInLogs&quot; and
    azure.signinlogs.properties.app_id == &quot;29d9ed98-a469-4536-ade2-f981bc1d605e&quot; and
    azure.signinlogs.properties.incoming_token_type == &quot;refreshToken&quot; and
    azure.signinlogs.properties.device_detail.trust_type == &quot;Azure AD joined&quot; and
    azure.signinlogs.properties.device_detail.device_id != null and
    azure.signinlogs.properties.token_protection_status_details.sign_in_session_status == &quot;unbound&quot; and
    azure.signinlogs.properties.user_type == &quot;Member&quot; and
    azure.signinlogs.result_signature == &quot;SUCCESS&quot;
  ]
  [authentication where 
    event.dataset == &quot;azure.signinlogs&quot; and
    azure.signinlogs.properties.incoming_token_type == &quot;primaryRefreshToken&quot; and
    azure.signinlogs.properties.resource_display_name != &quot;Device Registration Service&quot; and
    azure.signinlogs.result_signature == &quot;SUCCESS&quot;
  ]</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="signal-4---unusual-prt-usage-and-registered-device-for-user-principal" class="absolute -top-32"></span>Signal 4 - Unusual PRT Usage and Registered Device for User Principal</h3>
<p>This detection surfaces when a Microsoft Entra ID user registers a new device not previously seen within the last 7 days – behavior often associated with OAuth phishing campaigns that chain into ROADtx-based device registration. In these attacks, adversaries trick users into authorizing access for the Microsoft Authentication Broker (MAB) targeting the DRS, obtain a RT, and then use ROADtx to silently register a fake Windows device and mint a PRT. This rule alerts when a user principal authenticates from a newly observed device ID, particularly if the session is unbound, which is characteristic of token replay or device spoofing. Because PRTs require a registered and trusted device, this signal plays a critical role in identifying when an adversary has crossed from basic token abuse into persistent, stealthy access aligned with long-term compromise.</p>
<pre><code>event.dataset: &quot;azure.signinlogs&quot; and
    event.category: &quot;authentication&quot; and
    azure.signinlogs.properties.user_type: &quot;Member&quot; and
    azure.signinlogs.properties.token_protection_status_details.sign_in_session_status: &quot;unbound&quot; and
    not azure.signinlogs.properties.device_detail.device_id: &quot;&quot; and
    azure.signinlogs.properties.user_principal_name: *</code></pre>
<p><a href="https://www.elastic.co/docs/solutions/security/detect-and-alert/about-detection-rules">New Terms</a> Values:</p>
<ul>
<li>azure.signinlogs.properties.user_principal_name</li>
<li>azure.signinlogs.properties.device_detail.device_id</li>
</ul>
<p>This emulation helped us validate the full attacker workflow – from phishing for consent to establishing device trust and minting a PRT for long-term persistence. By chaining OAuth abuse with device registration, adversaries can satisfy CAPs, impersonate compliant endpoints and move laterally through cloud environments – often without triggering traditional security controls.</p>
<p>These nuances matter. When viewed in isolation, individual events like token issuance or device registration may appear benign. But when correlated across sign-in logs, audit data and token metadata, they expose a distinct trail of identity compromise.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="key-telemetry-details-for-detection-and-abuse" class="absolute -top-32"></span>Key Telemetry Details for Detection and Abuse</h1>
<p>Throughout our emulation and detection efforts, specific telemetry artifacts consistently proved essential for separating benign OAuth activity from malicious abuse. Understanding how these fields appear in Microsoft Entra ID logs – and how attackers manipulate them – is critical for effective hunting and detection engineering. From client IDs and grant types to device compliance, token types and conditional access outcomes, these signals tell the story of identity-based attacks. Below we have curated a list of those most important and how they can enable us.</p>
<p><strong>Client Application IDs (client_id)</strong>: Identify the application initiating the OAuth request. First-party clients (e.g. VSCode, Auth Broker) can be abused to blend in. Third-party clients may be malicious or unreviewed - often representing consent grant attacks. Mainly used to identify risky or unexpected app usage.</p>
<p><strong>Target Resource (resource_id / resource_display_name)</strong>: Defines which MSFT service is being accessed (e.g. MSFT Graph or Teams). High value targets include – Graph API, SharePoint, Outlook, Teams and Directory Services. Resource targeting is often scoped by attacker objectives.</p>
<p><strong>Principal type (user_type)</strong>: Indicates if the sign-in was by a member (user) or service principal. Phishing campaigns almost always target member accounts. This enables easy filtering in detection logic but helps pair unusual first-party client requests on-behalf-of user principals.</p>
<p><strong>OAuth Grant Type (authentication_processing_details)</strong>: Key to understanding how the token was obtained – authorization codes, refresh tokens, device codes, client credentials, etc. Whereas refresh tokens and device code reuse are high-fidelity signals of post-compromise.</p>
<p><strong>Geolocation</strong>: Enables us to identify atypical sign-ins (e.g. rare country seen) or impossible travel (same user from distant locations in a short time). Combined with session ID and correlation IDs, these can reveal token hijacking, post identity compromise or lateral movement.</p>
<p><strong>Device Metadata (device_detail, trust_type, compliance_state)</strong>: Includes Device IDs, operating system, trust types, compliance, managed-state and more. Device registration and PRT issuance are tied to this metadata. Often a goal for adversaries to satisfy CAP and gain trusted access that is persistent.</p>
<p><strong>Authentication Protocols and Types (authentication_protocol / incoming_token_type)</strong>: Reveals whether the session was OAuth-based or if MFA was used. Token sources incoming are those used for this request that provide authN or authZ. Useful for detecting token reuse, non-interactive sign-ins.</p>
<p><strong>Authentication Material and Session Context</strong>: Tokens used can be inferred via incoming token type, token protection status and the session ID. Session reuse, long session duration or multiple IPs tied to a single session often indicate abuse.</p>
<p><strong>Conditional Access Policy Status</strong>: Evaluated during token issuance – however it heavily influences whether access was granted. This helps identify CAP evasion, unexpected policy outcomes or can factor into risk.</p>
<p><strong>Scopes and Consent Behavior</strong>: Requested scopes appear in the SCP or OAuth parameters captured in sign-in logs. Indicators of abuse include <em>offline_access</em>, <em>.default</em>, or broad scopes like <em>Mail.ReadWrite</em>. Consent telemetry can help pivot or correlate if the user approved a suspicious application.</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h1>
<p>Microsoft Entra ID’s OAuth implementation presents a double-edged sword: it enables powerful, seamless authentication experiences – but also exposes new opportunities for adversaries to exploit trust, session persistence and device registration attack paths.</p>
<p>By replicating the OAuth phishing techniques observed by Volexity, our team was able to validate how attackers abuse legitimate Microsoft applications, token flows, and open-source tools to gain stealthy access to sensitive data. We extended this work through hands-on emulation, diving deep into the mechanics of OAuth phishing and workflows, security token metadata and acquisition, helping surface behavioral indicators that defenders can detect.</p>
<p>Our findings reinforce a key point: OAuth abuse doesn’t rely on malware or code execution. It weaponizes identity, consent, and token reuse – making traditional security controls a challenge – and why log-based detection, correlation and behavioral analysis are so critical.</p>
<p>We hope the emulation artifacts, detection rules, and lessons shared here help defenders across the community better understand – and detect/hunt – this evolving class of cloud-based identity threats.</p>
<p>If you&#x27;re using Elastic, we’ve open-sourced all the detection rules discussed in this blog to get you started. And if you&#x27;re hunting in another SIEM, we encourage you to adapt the logic and adjust to your environment accordingly.</p>
<p>Identity is the new perimeter – and it’s time we treated it that way. Stay safe and happy hunting!</p>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="detection-rules" class="absolute -top-32"></span>Detection Rules</h1>
<ul>
<li><a href="https://github.com/elastic/detection-rules/blob/d41a83059c78129b4e1337dca10b190b862ca0d2/rules/integrations/azure/initial_access_entra_graph_single_session_from_multiple_addresses.toml">Microsoft Entra ID Session Reuse with Suspicious Graph Access</a></li>
<li><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/azure/initial_access_entra_oauth_phishing_via_vscode_client.toml">Microsoft Entra ID OAuth Phishing via Visual Studio Code Client</a></li>
<li><a href="https://github.com/elastic/detection-rules/blob/3625b1b392e03aa7693a5b8251e7a5d3cfa53cce/rules/integrations/azure/initial_access_entra_id_suspicious_oauth_flow_via_auth_broker_to_drs.toml">Suspicious Microsoft OAuth Flow via Auth Broker to DRS</a></li>
<li><a href="https://github.com/elastic/detection-rules/blob/6b6407df88319f466c6cc56147210635bba5eb01/rules/integrations/azure/persistence_entra_id_suspicious_adrs_token_request.toml">Suspicious ADRS Token Request by Microsoft Auth Broker</a></li>
<li><a href="https://github.com/elastic/detection-rules/blob/43b0f0ada7e290bbbc0d4b1d53ed158e7bfbe75c/rules/integrations/azure/persistence_entra_id_suspicious_cloud_device_registration.toml">Unusual Device Registration in Entra ID</a></li>
<li><a href="https://github.com/elastic/detection-rules/blob/a18c76fe84eedc00efd9a712e74a0877b1061550/rules/integrations/azure/persistence_entra_id_rt_to_prt_transition_from_user_device.toml">Entra ID RT to PRT Transition from Same User and Device</a></li>
<li><a href="https://github.com/elastic/detection-rules/blob/main/rules/integrations/azure/persistence_entra_id_user_signed_in_from_unusual_device.toml">Unusual Registered Device for User Principal</a></li>
</ul>
<h1 class="font-bold leading-tighter text-3xl md:text-5xl relative"><span id="references" class="absolute -top-32"></span>References:</h1>
<ul>
<li><a href="https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/">https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/</a></li>
<li><a href="https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/">https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/</a></li>
<li><a href="https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30">https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30</a></li>
<li><a href="https://learn.microsoft.com/en-us/entra/identity/devices/concept-primary-refresh-token">https://learn.microsoft.com/en-us/entra/identity/devices/concept-primary-refresh-token</a></li>
<li><a href="https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens">https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens</a></li>
<li><a href="https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow">https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow</a></li>
<li><a href="https://learn.microsoft.com/en-us/entra/identity-platform/scopes-oidc#the-default-scope">https://learn.microsoft.com/en-us/entra/identity-platform/scopes-oidc#the-default-scope</a></li>
</ul></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/entra-id-oauth-phishing-detection#why-does-this-matter"><span>Why Does This&nbsp;Matter?</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/entra-id-oauth-phishing-detection#prerequisites"><span>Prerequisites</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/entra-id-oauth-phishing-detection#emulation"><span>Emulation</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/entra-id-oauth-phishing-detection#detection"><span>Detection</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/entra-id-oauth-phishing-detection#signal-1---microsoft-entra-id-oauth-phishing-as-visual-studio-code-client"><span>Signal 1 -&nbsp; Microsoft Entra ID OAuth Phishing as Visual Studio Code&nbsp;Client</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/entra-id-oauth-phishing-detection#signal-2---microsoft-entra-session-reuse-with-suspicious-graph-access-"><span>Signal 2 -&nbsp; Microsoft Entra Session Reuse with Suspicious Graph Access&nbsp;</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/entra-id-oauth-phishing-detection#signal-3---microsoft-entra-id-concurrent-sign-ins-with-suspicious-properties"><span>Signal 3 -&nbsp; Microsoft Entra ID Concurrent Sign-&nbsp;Ins with Suspicious&nbsp;Properties</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/entra-id-oauth-phishing-detection#emulation-1"><span>Emulation</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/entra-id-oauth-phishing-detection#detection-1"><span>Detection</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/entra-id-oauth-phishing-detection#signal-1---microsoft-entra-id-oauth-phishing-as-microsoft-authentication-broker"><span>Signal 1 -&nbsp; Microsoft Entra ID OAuth Phishing as Microsoft Authentication&nbsp;Broker</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Microsoft Entra ID OAuth Phishing and Detections&amp;url=https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection&amp;title=Microsoft Entra ID OAuth Phishing and Detections" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/entra-id-oauth-phishing-detection&amp;title=Microsoft Entra ID OAuth Phishing and Detections" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Microsoft Entra ID OAuth Phishing and Detections","slug":"entra-id-oauth-phishing-detection","date":"2025-06-25","description":"This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse.","image":"Security Labs Images 22.jpg","subtitle":"A crash course on in-the-wild (ItW) Entra ID OAuth phishing and detection strategies","body":{"raw":"\n# Preamble\n\nMembers of the Threat Research and Detection Engineering (TRADE) team at Elastic have recently turned their attention to an emerging class of threats targeting OAuth workflows in Microsoft Entra ID (previously Azure AD). This research was inspired by Volexity's recent blog, [Phishing for Codes: Russian Threat Actors Target Microsoft 365 OAuth Workflows](https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/), which attributes a sophisticated OAuth phishing campaign against NGOs to the threat actor designated [UTA0352](https://malpedia.caad.fkie.fraunhofer.de/actor/uta0352).\n\nVolexity's investigation presents compelling forensic evidence of how attackers abused trusted first-party Microsoft applications to bypass traditional defenses. Using legitimate OAuth flows and the open-source tool [ROADtools](https://github.com/dirkjanm/ROADtools), the actors crafted customized Microsoft authentication URLs, harvested security tokens and leveraged them to impersonate users, elevate privilege, and exfiltrate data via Microsoft Graph — including downloading Outlook emails and accessing SharePoint sites.\n\nWhile their report thoroughly documents the **what** of the attack, our team at Elastic focused on understanding the **how**. We emulated the attack chain in a controlled environment to explore the mechanics of token abuse, device registration, and token enrichment firsthand. This hands-on experimentation yielded deeper insights into the inner workings of Microsoft's OAuth implementation, the practical use of ROADtools, recommended mitigations, and most importantly, effective detection strategies to identify and respond to similar activity.\n\n# OAuth in Microsoft Entra ID\n\nMicrosoft Entra ID implements OAuth 2.0 to enable delegated access to Microsoft 365 services like Outlook, SharePoint, and Graph API. While the OAuth specification is standardized ([RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)), Entra ID introduces unique behaviors and token types that influence how delegated access works and how adversaries exploit them.\n\nIn delegated access, an application is authorized to act on behalf of a signed-in user, constrained by scopes (permissions) the app requests and the user or admin consents to. This model is common in enterprise environments where apps retrieve a user's emails, files, or directory data without prompting for credentials each time.\n\nA typical delegated authorization flow includes:\n\n**Authorization request (OAuth 2.0 Authorization Code Grant)**: The app requests access to a resource (e.g., Graph) with specific scopes (e.g., Mail.Read, offline_access). These are added as parameters to the URI.\n\n* *client_id*: The application’s ID (e.g., VSCode)  \n* *Response_type*: Determines the grant type OAuth workflow (e.g. device code, auth code)  \n* *Scope*: Permissions requested for the target resource (e.g. *Mail.Read, offline_access)*  \n* *Redirect_uri*: Where to send our authorization codes  \n* *State*: CSRF protection  \n* *Login_hint*: Pre-fills username\n\n**User authentication (OpenID Connect)**: Entra ID authenticates the user via policy (password, MFA, device trust).\n\n* Single-Factor Authentication (SFA)  \n* Multi-factor Authentication (MFA)  \n* Device Trust (Hybrid Join, Intune compliance)  \n* Conditional Access Policies (CAP)  \n* Single Sign-On (SSO)\n\n**Consent:** Consent governs whether the app can receive an authorization code and what scopes are permitted.\n\n* User-consentable scopes (e.g. *Mail.Read, offline_access)*  \n* Admin-Consent required scopes (e.g. *Directory.ReadWrite*) requires elevated approval.\n\n**Token issuance**: The app receives an authorization code, then redeems it for :\n\n* Access Token – short-lived token used to call APIs like Graph.  \n* Refresh Token (RT) – longer-lived token to obtain new access tokens silently.  \n* Identity Token - Describes authenticated user; present in OpenID flows.  \n* (Optional) Primary Refresh Token: If the user is on a domain-joined or registered device, a Primary Refresh Token (PRT) may enable silent SSO and additional token flows without user interaction.  \n* **Token claims:** Claims are key-value pairs embedded in JWT tokens that describe the user, app, device, scopes and context of the authentication.\n\n# What Defines an MSFT OAuth Phishing URL\n\nBefore diving into key findings from Volexity's report that help shape our detection strategy, it's important to break down what exactly defines a Microsoft OAuth phishing URL.\n\nAs described earlier, Microsoft Entra ID relies on these URLs to determine which application (client) is requesting access, on behalf of which user principal, to what resource, and with what permissions. Much of this context is embedded directly in the query parameters of the OAuth authorization request,  making them a critical source of metadata for both adversaries and defenders.\n\nHere's an example of a phishing URL aligned with the authorization code grant flow, adapted from Volexity's blog:\n\n```\nhttps://login.microsoftonline[.]com/organizations/oauth2/v2.0/authorize?state=https://mae.gov[.]ro/[REMOVED]\u0026client_id=aebc6443-996d-45c2-90f0-388ff96faa56\u0026scope=https://graph.microsoft.com/.default\u0026response_type=code\u0026redirect_uri=https://insiders.vscode.dev/redirect\u0026login_hint=\u003cEMAIL HERE\u003e\n```\n\nLet's break down some of the key components:\n\n* login.microsoftonline.com – The global Microsoft Entra ID authentication endpoint.  \n* /oauth2/v2.0/authorize - MSFT Entra ID OAuth v2.0 endpoint for authorization workflows  \n* state – Optional value used to prevent CSRF and maintain application state. Sometimes abused to obfuscate phishing redirections.  \n* client_id – The application ID making the request. This could belong to Microsoft first-party apps (like VSCode, Teams) or malicious third-party apps registered by adversaries.  \n* scope – Defines the permissions the application is requesting (e.g., Mail.Read, offline_access). The .default scope is often used for client credential flows to get pre-consented permissions.  \n* response_type=code – Indicates the flow is requesting an authorization code, which can later be exchanged for an access and/or refresh token.  \n* redirect_uri – Where Entra ID will send the response after the user authenticates. If an attacker controls this URI, they gain the code or it is a MSFT-managed URI that is valid.  \n* login_hint – Specifies the target user (e.g., alice @ tenant.onmicrosoft.com). Often pre-filled to lower friction during phishing.\n\nNote: While this example illustrates a common Microsoft Entra ID OAuth phishing URL, there are many variations. Adversaries may adjust parameters such as the client ID, scopes, grant types or redirect URIs depending on their specific objectives, whether it's to gain persistent access, exfiltrate emails, or escalate privileges via broader consent grants.\n\n## Why Does This Matter?\n\nBecause these parameters are customizable, adversaries can easily swap out values to suit their operation. For example:\n\n* They might use a legitimate Microsoft client ID to blend in with benign applications.  \n* They may use a .default scope to bypass specific consent prompts.  \n* They’ll point the redirect_uri to a site under their control to collect the authorization code.  \n* They can target specific user principals they may have identified during reconnaissance.  \n* They can adjust permissions to target resources based on their operational needs.\n\nOnce a target authenticates, the goal is simple – obtain an authorization code. This code is then exchanged (often using tools like ROADtools) for a refresh token and/or access token, enabling the attacker to make Graph API calls or pivot into other Microsoft 365 services, all without further user interaction.\n\n# Abstraction of Volexity's Key Findings\n\nFor threat detection, it is critical to understand the protocols like OAuth, workflow implementation in Microsoft Entra ID, and contextual metadata about the behaviors and/or steps taken by the adversary regarding this operation.\n\nFrom Volexity's investigation and research, we can key in the different variations of OAuth phishing reported. We decided to break these down for easier understanding:\n\n**OAuth Phishing To Access Graph API as VSCode Client On-Behalf-Of Target User Principal**: These URLs are similar to our example “What Defines an MSFT OAuth Phishing URL” – the end game goal being an access token to Graph API with default permissions. \n\n* OAuth phishing URLs were custom, pointing to \"authorize\" endpoint  \n* Client IDs were specifically VSCode (\"aebc6443-996d-45c2-90f0-388ff96faa56\")  \n* Resource/Scope was MSFT Graph (\"https://graph.microsoft.com/.default\") with .default permissions  \n* Token grant flows were auth code (response_type=code)  \n* Redirect URIs were for legitimate MSFT domains (insiders[.]vscode[.]dev or vscode-redirect[.]azurewebsites[.]net)  \n* Login hints were the specific user principal being targeted (not service principals)  \n* Adversary required the target to open the URL, authenticate and share the authorization code (1.AXg….)\n\nFrom here, the adversary would be able to make a request to MSFT's OAuth token endpoint (*https://login.microsoftonline.com/[tenant_id]/oauth2/v2.0/token*) and exchange the refresh token for an access token. This is enough to allow the adversary to access Graph API and access resources normally available to the user. These indicators will be crucial to factoring our detection and hunting strategies later on in this blog.\n\n**OAuth Phishing for Device Registration as MSFT Auth Broker**: These URLs are unique as they are chained with subsequence ROADtools usage to register a virtual device, exchange an RT for a PRT, and require PRT enrichment to accomplish email access via Graph API and Sharepoint access.\n\n* OAuth phishing URLs were custom, pointing to authorize (*https://login.microsoftonline.com/[tenant_id]/oauth2/v2.0/authorize*) endpoint  \n* Client IDs were specifically MSFT Authentication Broker (\"29d9ed98-a469-4536-ade2-f981bc1d605e\")  \n* Resource/Scope was Device Registration Service (DRS) (\"01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9\")  \n* Token grant flows were auth code (response_type=code)  \n* Redirect URI includes cloud-based domain join endpoint (typically used during Windows setup or Autopilot)  \n* Login hint contains user principal email address (Target)  \n* Request is ultimately for an ADRS token\n\nIf the user is phished and opens the URL, authenticating will provide an ADRS token that is required for the adversary to register a device and subsequently obtain a PRT with the device’s private key and PEM file.\n\nVolexity's blog also includes additional information about tracking the activity of the compromise identity via the device ID registered as well as post-compromise activity following an approved 2FA request was identified, allowing the adversary to download the target's email with a session tied to the newly registered device.\n\nWith this understanding of each phishing attempt, our next goal is to replicate this in our own MSFT tenant as accurately as possible to gather data for plausible detections.\n\n# Our Emulation Efforts\n\nAlright – so at this point, we’ve covered the fundamentals of OAuth and how Microsoft Entra ID implements it. We broke down what defines a Microsoft OAuth phishing URL, decoded its critical parameters, and pulled key insights from Volexity's excellent investigation to identify indicators aligned with these phishing workflows.\n\nBut theory and a glimpse into Volexity's notebook only takes us so far.\n\nTo truly understand the attacker's perspective, the full chain of execution, tooling quirks, subtle pitfalls, and opportunities for abuse,  we decided to go hands-on with whitebox testing. We recreated the OAuth phishing process in our own tenant, emulating everything from token harvesting to resource access. The goal? Go beyond static indicators and surface the behavioral breadcrumbs that defenders can reliably detect.\n\nLet's get into it.\n\n## Prerequisites\n\nFor starters, it is good to share some details about our threat research and detection environment in Azure.\n\n* Established Azure tenant: TENANT.onmicrosoft.com  \n* Established Sharepoint Domain: DOMAIN.sharepoint.com  \n* Native IdP Microsoft Entra ID – Enabling our IAM  \n* Microsoft 365 Licenses (P2) for All Users  \n* Azure Activity Logs Streaming to EventHub  \n* Microsoft Entra ID Sign-In Logs Streaming to EventHub  \n* Microsoft Entra ID Audit Logs Streaming to EventHub  \n* Microsoft Graph Audit Logs Streaming to EventHub  \n* Microsoft 365 Audit Logs Streaming to EventHub  \n* Elastic Azure and M365 Integration Enabled for Log Digestion from EventHub  \n* Basic Admin User Enabled with CAP Requiring MFA  \n* MSFT Authenticator App on Mobile for 2FA Emulation  \n* Windows 10 Desktop with NordVPN (Adversary Box)  \n* macOS endpoint (Victim box)\n\nNote that while we could follow the workflows from a single endpoint, often we need data that reflects separate source addresses to developer detection variations of impossible travel.\n\n# Scenario 1: OAuth Phishing as VSCode Client\n\n## Emulation\n\nTo emulate the phishing technique documented by Volexity, we built a Python script to generate an OAuth 2.0 authorization URL using Microsoft Entra ID. The URL initiates an authorization code grant flow, impersonating the first-party Visual Studio Code app to request delegated access to the Microsoft Graph API.\n\nWe configured the URL with the following parameters:\n\n```json\n{\n  \"client_id\": \"aebc6443-996d-45c2-90f0-388ff96faa56\",\n  \"response_type\": \"code\",\n  \"redirect_uri\": \"insiders.vscode.dev/redirect\",\n  \"scope\": \"https://graph.microsoft.com/.default\",\n  \"login_hint\": \"user @ tenant.onmicrosoft.com\",\n  \"prompt\": \"select_account\",\n  \"state\": \"nothingtoseehere\"\n}\n```\n\n*Figure 1: Parameters for OAuth Phishing URL*\n\nThis URL is shared with the target (in our case, a MacOS test user). When opened, it authenticates the user and completes the OAuth workflow. Using browser developer tools, we capture the authorization code returned in the redirect URI,  exactly what the attackers asked their victims to send back.\n\n![Figure 2: Redirect query string parameters with authorization code after authentication](/assets/images/entra-id-oauth-phishing-detection/image7.png)\n\n![Figure 3: Python script execution for generating OAuth phishing URL and exchanging auth code for Token](/assets/images/entra-id-oauth-phishing-detection/image2.png)\n\nAfter receiving the code, we issue a POST request to:\n\n```json\n{token_url: \"https://login.microsoftonline.com/organizations/oauth2/v2.0/token\"}\n```\n\nThis exchange uses the authorization_code grant type, passing the code, client ID, and redirect URI. Microsoft returns an access token, but no refresh token. You might ask why that is?\n\nThe scope https://graph.microsoft.com/.default instructs Microsoft to issue a bearer token for all Graph permissions already granted to the VSCode app on behalf of the user. This is a static scope, pulling from the app registration,  it does not include dynamic scopes like Mail.Read or offline_access.\n\nMicrosoft's documentation states:\n\n““*Clients can’t combine static (.default) consent and dynamic consent in a single request.*””\n\nTherefore, trying to include offline_access alongside *.default* results in an error. If the attacker wants a refresh token, they must avoid *.default* and instead explicitly request *offline_access* and the required delegated scopes (e.g., Mail.Read) – Assuming the app registration supports those.\n\nWith the access token in hand, we pivoted to a second script to interact with the Microsoft Graph API. The goal – extract email messages from the victim’s account — just as the attacker would.\n\nTo do this, we included the access token as a Bearer JWT in the authorization header and made a GET request to the following endpoint:\n\n```json\n{graph_url: \"https://graph.microsoft.com/v1.0/me/messages\"}\n```\n\nThe response returns a JSON array of email objects. From here, we simply iterate through the results and parse out useful metadata such as sender, subject, and received time.  \n\n![Figure 4: Leveraging access token to access user emails via Graph API](/assets/images/entra-id-oauth-phishing-detection/image4.png)\n\nTo test the token’s broader privileges, we also attempted to enumerate SharePoint sites using:\n\n```json\n{graph_search_url: \"https://graph.microsoft.com/v1.0/sites?search=*\"}\n```\n\nThe request failed with an access denied error – which leads us to an important question: why did email access work, but SharePoint access did not? The reason is that the first-party client (VSCode: aebc6443-996d-45c2-90f0-388ff96faa56) does not have default delegated permissions with Graph for Sharepoint – as predefined by Microsoft. Therefore, we know the adversary is limited on what they can access.\n\nTo ensure this was accurate, we decoded the access token to identify the SCP associated with VSCode with *.default* permissions to Graph – Verifying no *Sites.** permissioned by Microsoft.\n\n![Figure 5: Decoded Entra ID Access Token](/assets/images/entra-id-oauth-phishing-detection/image11.png)\n\nThis is one of the variations described by Volexity, but does help us understand more about the processes behind the scenes for the adversary – as well as resources, OAuth, and more for Microsoft Entra ID.\n\nWith the emulation complete, we now turn to identifying high-fidelity signals that are viable for SIEM detection and threat hunting. Our focus is on behavior observables in Microsoft Entra ID and Microsoft Graph logs.\n\n## Detection\n\n#### Signal 1 - Microsoft Entra ID OAuth Phishing as Visual Studio Code Client\n\nA successful OAuth 2.0 (authorization) and OpenID Connect (authentication) flow was completed using the first-party Microsoft application Visual Studio Code (VSCode). The sign-in occurred on behalf of the phished user principal, resulting in delegated access to Microsoft Graph with *.default* permissions.\n\n```\nevent.dataset: \"azure.signinlogs\" and\nevent.action: \"Sign-in activity\" and\nevent.outcome: \"success\" and\nazure.signinlogs.properties.user_type: \"Member\" and\nazure.signinlogs.properties.authentication_processing_details: *Oauth* and\nazure.signinlogs.category: \"NonInteractiveUserSignInLogs\" and\n(\n  azure.signinlogs.properties.resource_display_name: \"Microsoft Graph\" or\n  azure.signinlogs.properties.resource_id: \"00000003-0000-0000-c000-000000000000\"\n) and (\n  azure.signinlogs.properties.app_id: \"aebc6443-996d-45c2-90f0-388ff96faa56\" or\n  azure.signinlogs.properties.app_display_name: \"Visual Studio Code\"\n)\n```\n\n#### Signal 2 - Microsoft Entra Session Reuse with Suspicious Graph Access \n\nWhile traditional query languages like KQL are excellent for filtering and visualizing individual log events, they struggle when a detection relies on correlating multiple records across datasets, time, and identifiers. This is where ES|QL (Elasticsearch Query Language) becomes essential. These types of multi-event correlations, temporal logic, and field normalization are difficult or entirely impossible in static filter-based query languages like KQL without writing multiple disjointed queries and manually correlating them after the fact.\n\nThis detection relies on correlating multiple events that happen close together but from different data sources,  namely sign-in logs and Microsoft Graph activity. The goal is to find suspicious reuse of the same session ID across multiple IPs, potentially indicating session hijacking or token abuse. For the sake of space regarding this publication, you can view the actual detection rule in the Detection Rules section. To better illustrate the flow of the query and meaning, below is a diagram to illustrate at a higher level.\n\n```\n[ FROM logs-azure.* ]\n        |\n        |  ← Pulls events from all relevant Microsoft Cloud datasets:\n        |     - azure.signinlogs (authentication)\n        |     - azure.graphactivitylogs (resource access)\n        ↓\n[ WHERE session_id IS NOT NULL AND IP NOT MICROSOFT ASN ]\n        |\n        |  ← Filters out Microsoft-owned infrastructure (e.g., internal proxy,\n        |     Graph API relays) using ASN checks.\n        |  ← Ensures session ID exists so events can be correlated together.\n        ↓\n[ EVAL session_id, event_type, time_window, etc. ]\n        |\n        |  ← Normalizes key fields across datasets:\n        |     - session_id (from signin or Graph)\n        |     - user ID, app ID, event type (\"signin\" or \"graph\")\n        |  ← Buckets events into 5-minute windows using DATE_TRUNC()\n        ↓\n[ KEEP selected fields ]\n        |\n        |  ← Retains only what's needed:\n        |     session_id, timestamp, IP, user, client ID, etc.\n        ↓\n[ STATS BY session_id + time_window ]\n        |\n        |  ← Groups by session and time window to compute:\n        |     - unique IPs used\n        |     - apps involved\n        |     - first and last timestamps\n        |     - whether both signin and graph occurred\n        ↓\n[ EVAL time_diff + signin_to_graph_delay ]\n        |\n        |  ← Calculates:\n        |     - time_diff: full session duration\n        |     - delay: gap between signin and Graph access\n        ↓\n[ WHERE types_count \u003e 1 AND unique_ips \u003e 1 AND delay \u003c= 5 ]\n        |\n        |  ← Flags sessions where:\n        |     - multiple event types (signin + graph)\n        |     - multiple IPs used\n        |     - all occurred within 5 minutes\n        ↓\n[ Output = Suspicious Session Reuse Detected ]\n```\n\n#### Signal 3 - Microsoft Entra ID Concurrent Sign-Ins with Suspicious Properties\n\nThis detection identifies suspicious sign-ins in Microsoft Entra ID where a user authenticates using the device code flow without MFA or sign-ins using the VSCode client. When the same identity signs in from two or more distinct IPs within a short time window using either method, it may indicate token replay, OAuth phishing, or adversary-in-the-middle (AitM) activity. \n\n```\n[ FROM logs-azure.signinlogs* ]\n        |\n        |  ← Pulls only Microsoft Entra ID sign-in logs\n        ↓\n[ WHERE @timestamp \u003e NOW() - 1h AND event.outcome == \"success\" ]\n        |\n        |  ← Filters to the last hour and keeps only successful sign-ins\n        ↓\n[ WHERE source.ip IS NOT NULL AND identity IS NOT NULL ]\n        |\n        |  ← Ensures the sign-in is tied to a user and IP for correlation\n        ↓\n[ KEEP fields: identity, app_id, auth_protocol, IP, etc. ]\n        |\n        |  ← Retains app/client, IP, auth method, and resource info\n        ↓\n[ EVAL detection flags ]\n        |\n        |  ← Labels events as:\n        |     - device_code: if MFA not required\n        |     - visual_studio: if VS Code client used\n        |     - other: everything else\n        ↓\n[ STATS BY identity ]\n        |\n        |  ← Aggregates all sign-ins per user, calculates:\n        |     - IP count\n        |     - Device Code or VSCode usage\n        |     - App/client/resource details\n        ↓\n[ WHERE src_ip \u003e= 2 AND (device_code_count \u003e 0 OR vsc \u003e 0) ]\n        |\n        |  ← Flags users with:\n        |     - Sign-ins from multiple IPs\n        |     - And either:\n        |         - Device Code w/o MFA\n        |         - Visual Studio Code app\n        ↓\n[ Output = Potential OAuth Phishing or Token Misuse ]\n```\n\nWhile this variation of OAuth phishing lacks the full persistence offered by refresh tokens or PRTs, it still provides adversaries with valuable one-time access to sensitive user data – such as emails – through legitimate channels. This exercise helps us understand the limitations and capabilities of static *.default* scopes, the influence of app registrations, and how Microsoft Graph plays a pivotal role in post-authentication. It also reinforces a broader lesson: not all OAuth phishing attacks are created equal. Some aim for longevity (as we will see later) through refresh tokens or device registration, while others focus on immediate data theft via first-party clients. Understanding the nuances is essential for accurate detection logic.\n\n# Scenario 2: OAuth Phishing for Device Registration\n\nAs we stated earlier – Volexity also reported a separate phishing playbook targeting victims, this time with the goal of registering a virtual device and obtaining a PRT. While this approach requires more steps from the adversary, the payoff is a token-granting token that offers far more utility for completing their operations. For our emulation efforts, we needed to expand our toolset and rely on ROADtools, just as the adversary did to remain accurate, however, several other python scripts were made for initial phishing and post-compromise actions.\n\n## Emulation\n\nStarting with the initial phishing, we adjusted our Python script to craft a different OAuth URL that would be sent to our victim. This time, the focus was on our first-party client ID being the Microsoft Authentication Broker, requesting a refresh token with *offline_access* and redirecting to Entra ID’s cloud domain device joining endpoint URI.\n\n```json\n{\n  \"client_id\": \"29d9ed98-a469-4536-ade2-f981bc1d605e\",\n  \"response_type\": \"code\",\n  \"response_mode\": \"query\",\n  \"redirect_uri\": \"https://login.microsoftonline.com/WebApp/CloudDomainJoin/8\",\n  \"resource\": \"01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9\",\n  \"state\": \"nothingtoseehere\"\n}\n```\n\nIf successful and our victim authenticates, the OAuth workflow will complete and the user will be redirected to the specified URI with an appended authorization code in the query parameters. Again, this code is the critical piece,  it must be shared back with the adversary in order to exchange it for tokens. In our case, once the phishing URL is opened and the target authenticates, we capture the authorization code embedded in the redirect and use it to request tokens from the Microsoft Entra ID token endpoint.\n\n![Figure 6: Microsoft Authentication Broker OAuth Phishing and token exchange with custom Python script](/assets/images/entra-id-oauth-phishing-detection/image5.png)\n\nNow, here's where it gets interesting. In response to the token request, we receive three types of tokens: an access token, a refresh token, and an ID token. You might be asking –  why do we get more than just an access token? The answer lies in the scopes we initially requested: *openid*, *offline_access*, and *profile*.\n\n* *openid* grants us an ID token, which is part of the OpenID Connect layer and confirms the identity of the user — this is your authentication (authN) artifact.  \n* *offline_access* provides a refresh token, enabling us to maintain a session and request new access tokens without requiring re-authentication, this supports persistent access but is critical for our use with ROADtx.  \n* And the access token itself is used to authorize requests to protected APIs like Microsoft Graph, this represents authorization (authZ).\n\nWith these three tokens, we have everything: authentication, authorization, and long-term session continuity. That’s enough to shift from a simple OAuth phishing play into a more persistent foothold — like registering a new device in Microsoft Entra ID.\n\n![Figure 7: Captured JWT access, refresh and id token after exchange with authorization code](/assets/images/entra-id-oauth-phishing-detection/image10.png)\n\nNow let’s connect the dots. A PRT requires registration of a valid device, one that Entra ID recognizes via a device certificate and private key. This is where ROADtx comes into play. Because our initial OAuth phishing impersonated a joined device flow, and the client used was the Microsoft Authentication Broker (a first-party client that interacts with the Device Registration Service), we already have the right access token in hand to interact with DRS. Notice in our returned object the scope is *adrs_access* which indicates Azure DRS access and is important for detections later.\n\nFrom here, we simply drop the JSON object received from our token exchange into the *.roadtool_auth* file. This file is natively consumed by ROADtools, which uses the stored tokens to perform the device registration, completing the adversary’s move into persistence and setting the stage for obtaining a valid PRT.\n\nAfter obtaining the tokens, we prep them for ROADtx by reformatting the JSON. ROADtx expects keys in camelCase, and we must also include the Microsoft Authentication Broker’s client ID as *_clientId*. This setup allows us to run the *refreshtokento* command, which takes our refresh token and exchanges it for a new JWT scoped to the DRS — specifically, the service principal *urn:ms-drs:enterpriseregistration.windows.net*.\n\n![Figure 8: New authentication material from “refreshtokento” command for DRS as Microsoft Authentication Broker](/assets/images/entra-id-oauth-phishing-detection/image1.png)\n\nOnce that’s in place, we use the device command to simulate a new device registration. This operation doesn’t require any actual virtual machine or physical host because it’s a backend registration that simply creates an entry in Entra ID. Upon success, we’re issued a valid device ID, PEM-encoded certificate, and private key — all of which are required to simulate a valid hybrid-joined device in the Microsoft ecosystem.\n\n![Figure 9: “device” command output from registering a device and receiving a PEM certificate and private key](/assets/images/entra-id-oauth-phishing-detection/image9.png)\n\nWith our device identity established, we invoke the *prt* command. This uses the refresh token, device certificate, and private key to mint a new PRT — a highly privileged credential that effectively ties together user and device trust in Microsoft Entra ID.\n\n![Figure 10: “prt” command with refresh token, PEM certificate and private key to obtain a PRT](/assets/images/entra-id-oauth-phishing-detection/image3.png)\n\nAnd just like that — whollah! — we have a PRT.\n\nBut why go through all this? Why register a device, generate a cert, and obtain a PRT when we already had an access token, ID token, and refresh token?\n\nBecause the PRT is the key to full user and device identity emulation. Think of it as a Kerberos-like ticket-granting token in Entra ID’s world, but instead – a token-granting token. With a valid PRT:\n\n* An adversary can request new access and ID tokens for first-party apps like Outlook, SharePoint, or Teams without needing user interaction.  \n* The PRT enables seamless single sign-on SSO across multiple services, bypassing MFA and other conditional access policies (CAP) that would typically re-prompt the user. This is crucial for persistence as CAP and MFA are often huge barriers for adversaries.  \n* It supports long-lived persistence, as the PRT can be silently renewed and leveraged across sessions as long as the device identity remains trusted.\n\nAnd perhaps most dangerously — the PRT allows adversaries to impersonate a fully compliant, domain-joined device and user combo, effectively bypassing most conventional detection and response controls making the line between benign vs suspicious extremely thin for hunters and analysts.\n\nThis makes the PRT an incredibly valuable asset or one that enables covert lateral movement, privilege escalation, and deep access to Microsoft 365 services. It’s not just about getting in anymore — it’s about staying undetected.\n\nLet’s not forget post-compromise activity…\n\nROADtx offers a few powerful commands frequently used by adversaries – *prtenrich* and *browserprtauth*. For example, we can access most browser-based UI services in the Microsoft suite by supplying our PRT which includes the necessary metadata for authentication and authorization – which originally belonged to our phishing victim (me), but is actually the Microsoft Authentication Broker acting on their behalf.\n\n![Figure 11: Accessing M365 Copilot with PRT via “browserprtauth” command](/assets/images/entra-id-oauth-phishing-detection/image12.png)\n\nVolexity also reported that following device registration and the PRT acquisition – a 2FA request was sent to the initial victim, approved and then used to access emails via SharePoint. While they do not specify exactly how requests were made to – it’s reasonable to assume the adversary used the PRT to authenticate via a first-party Microsoft client – with the actual data access happening through Microsoft Graph. Graph remains a popular target post-compromise because it serves as a central API hub for most Microsoft 365 resources.\n\nTo start – let’s leverage ROADtx to auth with our PRT where Microsoft Teams is our client and Microsoft Graph is our resource. When using the *prtauth* command with our PRT, we are able to obtain a new access token and refresh token – clearly demonstrating the utility of the PRT as a token-granting token within Microsoft’s identity fabric.\n\n![Figure 12: “prtauth” command for tokens as MSFT Teams client for MSFT Graph resource](/assets/images/entra-id-oauth-phishing-detection/image8.png)\n\nOnce our access token is obtained, we plug it into a custom Python script to start enumerating our SharePoint sites, drives, items which allows us to identify files of interest and download their contents.\n\n![Figure 13: Discovering all SharePoint sites in tenant and downloading user files via MSFT Graph](/assets/images/entra-id-oauth-phishing-detection/image6.png)\n\nWith this emulation – we showed how adversaries can chain OAuth phishing with the Microsoft Authentication Broker and obtain necessary credential material to leverage ROADtx for acquiring a PRT. This PRT then being an important utility post-compromise to access sensitive files, enumerate tenant resources and much more.\n\nNow, let’s shift focus: what are plausible and accurate signals for detecting this activity?\n\n## Detection\n\n### Signal 1 - Microsoft Entra ID OAuth Phishing as Microsoft Authentication Broker\n\nIdentifies instances where a user principal initiates an OAuth authorization code flow using the Microsoft Authentication Broker (MAB) as the client and the Device Registration Service (DRS) as the target resource. This detection focuses on cases where a single session ID is reused across two or more distinct IP addresses within a short time window, and at least one request originates from a browser — behavior commonly associated with phishing.\n\n```\n[ FROM logs-azure.signinlogs-* ]\n        |\n        |  ← Pulls all Microsoft Entra ID sign-in logs\n        ↓\n[ WHERE app_id == MAB AND resource_id == DRS ]\n        |\n        |  ← Filters to OAuth auth code requests targeting\n        |     Microsoft Authentication Broker + Device Reg Service\n        ↓\n[ EVAL session_id + is_browser ]\n        |\n        |  ← Extracts session ID and flags browser-based activity\n        ↓\n[ STATS BY 30-minute window, user, session_id ]\n        |\n        |  ← Groups logins within same session and time window,\n        |     then aggregates:\n        |       - user/session/token identifiers\n        |       - distinct IPs and geo info\n        |       - user agent, browser presence\n        |       - app/resource/client info\n        ↓\n[ WHERE ip_count ≥ 2 AND session_id_count == 1 ]\n        |\n        |  ← Identifies reuse of a single session ID\n        |     across ≥ 2 different IP addresses\n        ↓\n[ AND has_browser ≥ 1 AND auth_count ≥ 2 ]\n        |\n        |  ← Requires at least one browser-based request\n        |     and at least two total sign-in events\n        ↓\n[ Output = Suspicious OAuth Flow with Auth Broker for DRS ]\n\n```\n\n### Signal 2 - Suspicious ADRS Token Request by Microsoft Auth Broker\n\nIdentifies Microsoft Entra ID sign-in events where a user principal authenticates using a refresh token issued to the Microsoft Authentication Broker (MAB) client, targeting the Device Registration Service (DRS) with the *adrs_access* OAuth scope. This pattern may indicate token-based access to DRS following an initial authorization code phishing or device registration flow.\n\n```\nevent.dataset: \"azure.signinlogs\" and azure.signinlogs.properties.app_id : \"29d9ed98-a469-4536-ade2-f981bc1d605e\" and azure.signinlogs.properties.resource_id : \"01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9\" and azure.signinlogs.properties.authentication_processing_details.`Oauth Scope Info`: *adrs_access* and azure.signinlogs.properties.incoming_token_type: \"refreshToken\" and azure.signinlogs.properties.user_type: \"Member\"\n```\n\n### Signal 3 - Unusual Device Registration in Entra ID\n\nDetects a sequence of Entra ID audit log events indicating potential malicious device registration activity using a refresh token, commonly seen after OAuth phishing. This pattern mimics the behavior of tools like ROADtx, where a newly registered Windows device (with a hardcoded OS version 10.0.19041.928) is added by the Device Registration Service, followed by user and owner assignments. All events must share the same correlation ID and occur within a one-minute window, strongly suggesting automation or script-driven registration rather than legitimate user behavior.\n\n```\nsequence by azure.correlation_id with maxspan=1m\n[any where event.dataset == \"azure.auditlogs\" and azure.auditlogs.identity == \"Device Registration Service\" and azure.auditlogs.operation_name == \"Add device\" and azure.auditlogs.properties.additional_details.value like \"Microsoft.OData.Client/*\" and (\n  azure.auditlogs.properties.target_resources.`0`.modified_properties.`1`.display_name == \"CloudAccountEnabled\" and \nazure.auditlogs.properties.target_resources.`0`.modified_properties.`1`.new_value: \"[true]\") and azure.auditlogs.properties.target_resources.`0`.modified_properties.`3`.new_value like \"*10.0.19041.928*\"]\n[any where event.dataset == \"azure.auditlogs\" and azure.auditlogs.operation_name == \"Add registered users to device\" and azure.auditlogs.properties.target_resources.`0`.modified_properties.`2`.new_value like \"*urn:ms-drs:enterpriseregistration.windows.net*\"]\n[any where event.dataset == \"azure.auditlogs\" and azure.auditlogs.operation_name == \"Add registered owner to device\"]\n```\n\n### Signal 3 - Entra ID RT to PRT Transition from Same User and Device \n\nThis detection identifies when a Microsoft Entra ID user first authenticates using a refresh token issued to the Microsoft Authentication Broker (MAB), followed shortly by the use of a Primary Refresh Token (PRT) from the same device. This sequence is rare in normal user behavior and may indicate an adversary has successfully registered a device and escalated to persistent access using tools like ROADtx. By filtering out activity tied to the Device Registration Service (DRS) in the second step, the rule focuses on post-registration usage of the PRT to access other Microsoft 365 services. \n\nThis behavior strongly suggests token-based compromise and long-term session emulation, particularly when device trust is established silently. Catching this transition from refresh token to PRT is critical for surfacing high-fidelity signals of OAuth phishing and post-compromise persistence.\n\n```\nsequence by azure.signinlogs.properties.user_id, azure.signinlogs.properties.device_detail.device_id with maxspan=1d\n  [authentication where \n    event.dataset == \"azure.signinlogs\" and\n    azure.signinlogs.category == \"NonInteractiveUserSignInLogs\" and\n    azure.signinlogs.properties.app_id == \"29d9ed98-a469-4536-ade2-f981bc1d605e\" and\n    azure.signinlogs.properties.incoming_token_type == \"refreshToken\" and\n    azure.signinlogs.properties.device_detail.trust_type == \"Azure AD joined\" and\n    azure.signinlogs.properties.device_detail.device_id != null and\n    azure.signinlogs.properties.token_protection_status_details.sign_in_session_status == \"unbound\" and\n    azure.signinlogs.properties.user_type == \"Member\" and\n    azure.signinlogs.result_signature == \"SUCCESS\"\n  ]\n  [authentication where \n    event.dataset == \"azure.signinlogs\" and\n    azure.signinlogs.properties.incoming_token_type == \"primaryRefreshToken\" and\n    azure.signinlogs.properties.resource_display_name != \"Device Registration Service\" and\n    azure.signinlogs.result_signature == \"SUCCESS\"\n  ]\n```\n\n### Signal 4 - Unusual PRT Usage and Registered Device for User Principal\n\nThis detection surfaces when a Microsoft Entra ID user registers a new device not previously seen within the last 7 days – behavior often associated with OAuth phishing campaigns that chain into ROADtx-based device registration. In these attacks, adversaries trick users into authorizing access for the Microsoft Authentication Broker (MAB) targeting the DRS, obtain a RT, and then use ROADtx to silently register a fake Windows device and mint a PRT. This rule alerts when a user principal authenticates from a newly observed device ID, particularly if the session is unbound, which is characteristic of token replay or device spoofing. Because PRTs require a registered and trusted device, this signal plays a critical role in identifying when an adversary has crossed from basic token abuse into persistent, stealthy access aligned with long-term compromise.\n\n```\nevent.dataset: \"azure.signinlogs\" and\n    event.category: \"authentication\" and\n    azure.signinlogs.properties.user_type: \"Member\" and\n    azure.signinlogs.properties.token_protection_status_details.sign_in_session_status: \"unbound\" and\n    not azure.signinlogs.properties.device_detail.device_id: \"\" and\n    azure.signinlogs.properties.user_principal_name: *\n```\n\n[New Terms](https://www.elastic.co/docs/solutions/security/detect-and-alert/about-detection-rules) Values:\n\n* azure.signinlogs.properties.user_principal_name  \n* azure.signinlogs.properties.device_detail.device_id\n\nThis emulation helped us validate the full attacker workflow – from phishing for consent to establishing device trust and minting a PRT for long-term persistence. By chaining OAuth abuse with device registration, adversaries can satisfy CAPs, impersonate compliant endpoints and move laterally through cloud environments – often without triggering traditional security controls.\n\nThese nuances matter. When viewed in isolation, individual events like token issuance or device registration may appear benign. But when correlated across sign-in logs, audit data and token metadata, they expose a distinct trail of identity compromise.\n\n# Key Telemetry Details for Detection and Abuse\n\nThroughout our emulation and detection efforts, specific telemetry artifacts consistently proved essential for separating benign OAuth activity from malicious abuse. Understanding how these fields appear in Microsoft Entra ID logs – and how attackers manipulate them – is critical for effective hunting and detection engineering. From client IDs and grant types to device compliance, token types and conditional access outcomes, these signals tell the story of identity-based attacks. Below we have curated a list of those most important and how they can enable us.\n\n**Client Application IDs (client_id)**: Identify the application initiating the OAuth request. First-party clients (e.g. VSCode, Auth Broker) can be abused to blend in. Third-party clients may be malicious or unreviewed - often representing consent grant attacks. Mainly used to identify risky or unexpected app usage.\n\n**Target Resource (resource_id / resource_display_name)**: Defines which MSFT service is being accessed (e.g. MSFT Graph or Teams). High value targets include – Graph API, SharePoint, Outlook, Teams and Directory Services. Resource targeting is often scoped by attacker objectives.\n\n**Principal type (user_type)**: Indicates if the sign-in was by a member (user) or service principal. Phishing campaigns almost always target member accounts. This enables easy filtering in detection logic but helps pair unusual first-party client requests on-behalf-of user principals.\n\n**OAuth Grant Type (authentication_processing_details)**: Key to understanding how the token was obtained – authorization codes, refresh tokens, device codes, client credentials, etc. Whereas refresh tokens and device code reuse are high-fidelity signals of post-compromise.\n\n**Geolocation**: Enables us to identify atypical sign-ins (e.g. rare country seen) or impossible travel (same user from distant locations in a short time). Combined with session ID and correlation IDs, these can reveal token hijacking, post identity compromise or lateral movement.\n\n**Device Metadata (device_detail, trust_type, compliance_state)**: Includes Device IDs, operating system, trust types, compliance, managed-state and more. Device registration and PRT issuance are tied to this metadata. Often a goal for adversaries to satisfy CAP and gain trusted access that is persistent.\n\n**Authentication Protocols and Types (authentication_protocol / incoming_token_type)**: Reveals whether the session was OAuth-based or if MFA was used. Token sources incoming are those used for this request that provide authN or authZ. Useful for detecting token reuse, non-interactive sign-ins.\n\n**Authentication Material and Session Context**: Tokens used can be inferred via incoming token type, token protection status and the session ID. Session reuse, long session duration or multiple IPs tied to a single session often indicate abuse.\n\n**Conditional Access Policy Status**: Evaluated during token issuance – however it heavily influences whether access was granted. This helps identify CAP evasion, unexpected policy outcomes or can factor into risk.\n\n**Scopes and Consent Behavior**: Requested scopes appear in the SCP or OAuth parameters captured in sign-in logs. Indicators of abuse include *offline_access*, *.default*, or broad scopes like *Mail.ReadWrite*. Consent telemetry can help pivot or correlate if the user approved a suspicious application.\n\n# Conclusion\n\nMicrosoft Entra ID’s OAuth implementation presents a double-edged sword: it enables powerful, seamless authentication experiences – but also exposes new opportunities for adversaries to exploit trust, session persistence and device registration attack paths.\n\nBy replicating the OAuth phishing techniques observed by Volexity, our team was able to validate how attackers abuse legitimate Microsoft applications, token flows, and open-source tools to gain stealthy access to sensitive data. We extended this work through hands-on emulation, diving deep into the mechanics of OAuth phishing and workflows, security token metadata and acquisition, helping surface behavioral indicators that defenders can detect.\n\nOur findings reinforce a key point: OAuth abuse doesn’t rely on malware or code execution. It weaponizes identity, consent, and token reuse – making traditional security controls a challenge – and why log-based detection, correlation and behavioral analysis are so critical.\n\nWe hope the emulation artifacts, detection rules, and lessons shared here help defenders across the community better understand – and detect/hunt – this evolving class of cloud-based identity threats.\n\nIf you're using Elastic, we’ve open-sourced all the detection rules discussed in this blog to get you started. And if you're hunting in another SIEM, we encourage you to adapt the logic and adjust to your environment accordingly. \n\nIdentity is the new perimeter – and it’s time we treated it that way. Stay safe and happy hunting!\n\n# Detection Rules\n\n* [Microsoft Entra ID Session Reuse with Suspicious Graph Access](https://github.com/elastic/detection-rules/blob/d41a83059c78129b4e1337dca10b190b862ca0d2/rules/integrations/azure/initial_access_entra_graph_single_session_from_multiple_addresses.toml)  \n* [Microsoft Entra ID OAuth Phishing via Visual Studio Code Client](https://github.com/elastic/detection-rules/blob/main/rules/integrations/azure/initial_access_entra_oauth_phishing_via_vscode_client.toml)  \n* [Suspicious Microsoft OAuth Flow via Auth Broker to DRS](https://github.com/elastic/detection-rules/blob/3625b1b392e03aa7693a5b8251e7a5d3cfa53cce/rules/integrations/azure/initial_access_entra_id_suspicious_oauth_flow_via_auth_broker_to_drs.toml)  \n* [Suspicious ADRS Token Request by Microsoft Auth Broker](https://github.com/elastic/detection-rules/blob/6b6407df88319f466c6cc56147210635bba5eb01/rules/integrations/azure/persistence_entra_id_suspicious_adrs_token_request.toml)  \n* [Unusual Device Registration in Entra ID](https://github.com/elastic/detection-rules/blob/43b0f0ada7e290bbbc0d4b1d53ed158e7bfbe75c/rules/integrations/azure/persistence_entra_id_suspicious_cloud_device_registration.toml)  \n* [Entra ID RT to PRT Transition from Same User and Device](https://github.com/elastic/detection-rules/blob/a18c76fe84eedc00efd9a712e74a0877b1061550/rules/integrations/azure/persistence_entra_id_rt_to_prt_transition_from_user_device.toml)  \n* [Unusual Registered Device for User Principal](https://github.com/elastic/detection-rules/blob/main/rules/integrations/azure/persistence_entra_id_user_signed_in_from_unusual_device.toml)\n\n# References:\n\n* [https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/](https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/)  \n* [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)  \n* [https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)  \n* [https://learn.microsoft.com/en-us/entra/identity/devices/concept-primary-refresh-token](https://learn.microsoft.com/en-us/entra/identity/devices/concept-primary-refresh-token)  \n* [https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens](https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens)  \n* [https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow](https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow)  \n* [https://learn.microsoft.com/en-us/entra/identity-platform/scopes-oidc#the-default-scope](https://learn.microsoft.com/en-us/entra/identity-platform/scopes-oidc#the-default-scope)\n","code":"var Component=(()=\u003e{var l=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var m=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=\u003e{for(var n in e)r(t,n,{get:e[n],enumerable:!0})},o=(t,e,n,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let s of p(e))!f.call(t,s)\u0026\u0026s!==n\u0026\u0026r(t,s,{get:()=\u003ee[s],enumerable:!(a=u(e,s))||a.enumerable});return t};var v=(t,e,n)=\u003e(n=t!=null?l(g(t)):{},o(e||!t||!t.__esModule?r(n,\"default\",{value:t,enumerable:!0}):n,t)),y=t=\u003eo(r({},\"__esModule\",{value:!0}),t);var h=m((D,c)=\u003e{c.exports=_jsx_runtime});var _={};w(_,{default:()=\u003eA,frontmatter:()=\u003eb});var i=v(h()),b={title:\"Microsoft Entra ID OAuth Phishing and Detections\",slug:\"entra-id-oauth-phishing-detection\",date:\"2025-06-25\",subtitle:\"A crash course on in-the-wild (ItW) Entra ID OAuth phishing and detection strategies\",description:\"This article explores OAuth phishing and token-based abuse in Microsoft Entra ID. Through emulation and analysis of tokens, scope, and device behavior during sign-in activity, we surface high-fidelity signals defenders can use to detect and hunt for OAuth misuse.\",author:[{slug:\"terrance-dejesus\"}],image:\"Security Labs Images 22.jpg\",category:[{slug:\"security-research\"}]};function d(t){let e=Object.assign({h1:\"h1\",p:\"p\",a:\"a\",strong:\"strong\",ul:\"ul\",li:\"li\",em:\"em\",pre:\"pre\",code:\"code\",h2:\"h2\",img:\"img\",h4:\"h4\",h3:\"h3\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:\"preamble\",children:\"Preamble\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Members of the Threat Research and Detection Engineering (TRADE) team at Elastic have recently turned their attention to an emerging class of threats targeting OAuth workflows in Microsoft Entra ID (previously Azure AD). This research was inspired by Volexity's recent blog, \",(0,i.jsx)(e.a,{href:\"https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/\",rel:\"nofollow\",children:\"Phishing for Codes: Russian Threat Actors Target Microsoft 365 OAuth Workflows\"}),\", which attributes a sophisticated OAuth phishing campaign against NGOs to the threat actor designated \",(0,i.jsx)(e.a,{href:\"https://malpedia.caad.fkie.fraunhofer.de/actor/uta0352\",rel:\"nofollow\",children:\"UTA0352\"}),\".\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Volexity's investigation presents compelling forensic evidence of how attackers abused trusted first-party Microsoft applications to bypass traditional defenses. Using legitimate OAuth flows and the open-source tool \",(0,i.jsx)(e.a,{href:\"https://github.com/dirkjanm/ROADtools\",rel:\"nofollow\",children:\"ROADtools\"}),\", the actors crafted customized Microsoft authentication URLs, harvested security tokens and leveraged them to impersonate users, elevate privilege, and exfiltrate data via Microsoft Graph \\u2014 including downloading Outlook emails and accessing SharePoint sites.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"While their report thoroughly documents the \",(0,i.jsx)(e.strong,{children:\"what\"}),\" of the attack, our team at Elastic focused on understanding the \",(0,i.jsx)(e.strong,{children:\"how\"}),\". We emulated the attack chain in a controlled environment to explore the mechanics of token abuse, device registration, and token enrichment firsthand. This hands-on experimentation yielded deeper insights into the inner workings of Microsoft's OAuth implementation, the practical use of ROADtools, recommended mitigations, and most importantly, effective detection strategies to identify and respond to similar activity.\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"oauth-in-microsoft-entra-id\",children:\"OAuth in Microsoft Entra ID\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Microsoft Entra ID implements OAuth 2.0 to enable delegated access to Microsoft 365 services like Outlook, SharePoint, and Graph API. While the OAuth specification is standardized (\",(0,i.jsx)(e.a,{href:\"https://datatracker.ietf.org/doc/html/rfc6749\",rel:\"nofollow\",children:\"RFC6749\"}),\"), Entra ID introduces unique behaviors and token types that influence how delegated access works and how adversaries exploit them.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In delegated access, an application is authorized to act on behalf of a signed-in user, constrained by scopes (permissions) the app requests and the user or admin consents to. This model is common in enterprise environments where apps retrieve a user's emails, files, or directory data without prompting for credentials each time.\"}),`\n`,(0,i.jsx)(e.p,{children:\"A typical delegated authorization flow includes:\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Authorization request (OAuth 2.0 Authorization Code Grant)\"}),\": The app requests access to a resource (e.g., Graph) with specific scopes (e.g., Mail.Read, offline_access). These are added as parameters to the URI.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"client_id\"}),\": The application\\u2019s ID (e.g., VSCode)\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"Response_type\"}),\": Determines the grant type OAuth workflow (e.g. device code, auth code)\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"Scope\"}),\": Permissions requested for the target resource (e.g. \",(0,i.jsx)(e.em,{children:\"Mail.Read, offline_access)\"})]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"Redirect_uri\"}),\": Where to send our authorization codes\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"State\"}),\": CSRF protection\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"Login_hint\"}),\": Pre-fills username\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"User authentication (OpenID Connect)\"}),\": Entra ID authenticates the user via policy (password, MFA, device trust).\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Single-Factor Authentication (SFA)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Multi-factor Authentication (MFA)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Device Trust (Hybrid Join, Intune compliance)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Conditional Access Policies (CAP)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Single Sign-On (SSO)\"}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Consent:\"}),\" Consent governs whether the app can receive an authorization code and what scopes are permitted.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"User-consentable scopes (e.g. \",(0,i.jsx)(e.em,{children:\"Mail.Read, offline_access)\"})]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Admin-Consent required scopes (e.g. \",(0,i.jsx)(e.em,{children:\"Directory.ReadWrite\"}),\") requires elevated approval.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Token issuance\"}),\": The app receives an authorization code, then redeems it for :\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Access Token \\u2013 short-lived token used to call APIs like Graph.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Refresh Token (RT) \\u2013 longer-lived token to obtain new access tokens silently.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Identity Token - Describes authenticated user; present in OpenID flows.\"}),`\n`,(0,i.jsx)(e.li,{children:\"(Optional) Primary Refresh Token: If the user is on a domain-joined or registered device, a Primary Refresh Token (PRT) may enable silent SSO and additional token flows without user interaction.\"}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Token claims:\"}),\" Claims are key-value pairs embedded in JWT tokens that describe the user, app, device, scopes and context of the authentication.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h1,{id:\"what-defines-an-msft-oauth-phishing-url\",children:\"What Defines an MSFT OAuth Phishing URL\"}),`\n`,(0,i.jsx)(e.p,{children:\"Before diving into key findings from Volexity's report that help shape our detection strategy, it's important to break down what exactly defines a Microsoft OAuth phishing URL.\"}),`\n`,(0,i.jsx)(e.p,{children:\"As described earlier, Microsoft Entra ID relies on these URLs to determine which application (client) is requesting access, on behalf of which user principal, to what resource, and with what permissions. Much of this context is embedded directly in the query parameters of the OAuth authorization request,  making them a critical source of metadata for both adversaries and defenders.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Here's an example of a phishing URL aligned with the authorization code grant flow, adapted from Volexity's blog:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`https://login.microsoftonline[.]com/organizations/oauth2/v2.0/authorize?state=https://mae.gov[.]ro/[REMOVED]\u0026client_id=aebc6443-996d-45c2-90f0-388ff96faa56\u0026scope=https://graph.microsoft.com/.default\u0026response_type=code\u0026redirect_uri=https://insiders.vscode.dev/redirect\u0026login_hint=\u003cEMAIL HERE\u003e\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Let's break down some of the key components:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"login.microsoftonline.com \\u2013 The global Microsoft Entra ID authentication endpoint.\"}),`\n`,(0,i.jsx)(e.li,{children:\"/oauth2/v2.0/authorize - MSFT Entra ID OAuth v2.0 endpoint for authorization workflows\"}),`\n`,(0,i.jsx)(e.li,{children:\"state \\u2013 Optional value used to prevent CSRF and maintain application state. Sometimes abused to obfuscate phishing redirections.\"}),`\n`,(0,i.jsx)(e.li,{children:\"client_id \\u2013 The application ID making the request. This could belong to Microsoft first-party apps (like VSCode, Teams) or malicious third-party apps registered by adversaries.\"}),`\n`,(0,i.jsx)(e.li,{children:\"scope \\u2013 Defines the permissions the application is requesting (e.g., Mail.Read, offline_access). The .default scope is often used for client credential flows to get pre-consented permissions.\"}),`\n`,(0,i.jsx)(e.li,{children:\"response_type=code \\u2013 Indicates the flow is requesting an authorization code, which can later be exchanged for an access and/or refresh token.\"}),`\n`,(0,i.jsx)(e.li,{children:\"redirect_uri \\u2013 Where Entra ID will send the response after the user authenticates. If an attacker controls this URI, they gain the code or it is a MSFT-managed URI that is valid.\"}),`\n`,(0,i.jsx)(e.li,{children:\"login_hint \\u2013 Specifies the target user (e.g., alice @ tenant.onmicrosoft.com). Often pre-filled to lower friction during phishing.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Note: While this example illustrates a common Microsoft Entra ID OAuth phishing URL, there are many variations. Adversaries may adjust parameters such as the client ID, scopes, grant types or redirect URIs depending on their specific objectives, whether it's to gain persistent access, exfiltrate emails, or escalate privileges via broader consent grants.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"why-does-this-matter\",children:\"Why Does This Matter?\"}),`\n`,(0,i.jsx)(e.p,{children:\"Because these parameters are customizable, adversaries can easily swap out values to suit their operation. For example:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"They might use a legitimate Microsoft client ID to blend in with benign applications.\"}),`\n`,(0,i.jsx)(e.li,{children:\"They may use a .default scope to bypass specific consent prompts.\"}),`\n`,(0,i.jsx)(e.li,{children:\"They\\u2019ll point the redirect_uri to a site under their control to collect the authorization code.\"}),`\n`,(0,i.jsx)(e.li,{children:\"They can target specific user principals they may have identified during reconnaissance.\"}),`\n`,(0,i.jsx)(e.li,{children:\"They can adjust permissions to target resources based on their operational needs.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Once a target authenticates, the goal is simple \\u2013 obtain an authorization code. This code is then exchanged (often using tools like ROADtools) for a refresh token and/or access token, enabling the attacker to make Graph API calls or pivot into other Microsoft 365 services, all without further user interaction.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"abstraction-of-volexitys-key-findings\",children:\"Abstraction of Volexity's Key Findings\"}),`\n`,(0,i.jsx)(e.p,{children:\"For threat detection, it is critical to understand the protocols like OAuth, workflow implementation in Microsoft Entra ID, and contextual metadata about the behaviors and/or steps taken by the adversary regarding this operation.\"}),`\n`,(0,i.jsx)(e.p,{children:\"From Volexity's investigation and research, we can key in the different variations of OAuth phishing reported. We decided to break these down for easier understanding:\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"OAuth Phishing To Access Graph API as VSCode Client On-Behalf-Of Target User Principal\"}),\": These URLs are similar to our example \\u201CWhat Defines an MSFT OAuth Phishing URL\\u201D \\u2013 the end game goal being an access token to Graph API with default permissions.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:'OAuth phishing URLs were custom, pointing to \"authorize\" endpoint'}),`\n`,(0,i.jsx)(e.li,{children:'Client IDs were specifically VSCode (\"aebc6443-996d-45c2-90f0-388ff96faa56\")'}),`\n`,(0,i.jsxs)(e.li,{children:['Resource/Scope was MSFT Graph (\"',(0,i.jsx)(e.a,{href:\"https://graph.microsoft.com/.default\",rel:\"nofollow\",children:\"https://graph.microsoft.com/.default\"}),'\") with .default permissions']}),`\n`,(0,i.jsx)(e.li,{children:\"Token grant flows were auth code (response_type=code)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Redirect URIs were for legitimate MSFT domains (insiders[.]vscode[.]dev or vscode-redirect[.]azurewebsites[.]net)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Login hints were the specific user principal being targeted (not service principals)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Adversary required the target to open the URL, authenticate and share the authorization code (1.AXg\\u2026.)\"}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"From here, the adversary would be able to make a request to MSFT's OAuth token endpoint (\",(0,i.jsx)(e.em,{children:(0,i.jsx)(e.a,{href:\"https://login.microsoftonline.com/%5Btenant_id%5D/oauth2/v2.0/token\",rel:\"nofollow\",children:\"https://login.microsoftonline.com/[tenant_id]/oauth2/v2.0/token\"})}),\") and exchange the refresh token for an access token. This is enough to allow the adversary to access Graph API and access resources normally available to the user. These indicators will be crucial to factoring our detection and hunting strategies later on in this blog.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"OAuth Phishing for Device Registration as MSFT Auth Broker\"}),\": These URLs are unique as they are chained with subsequence ROADtools usage to register a virtual device, exchange an RT for a PRT, and require PRT enrichment to accomplish email access via Graph API and Sharepoint access.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"OAuth phishing URLs were custom, pointing to authorize (\",(0,i.jsx)(e.em,{children:(0,i.jsx)(e.a,{href:\"https://login.microsoftonline.com/%5Btenant_id%5D/oauth2/v2.0/authorize\",rel:\"nofollow\",children:\"https://login.microsoftonline.com/[tenant_id]/oauth2/v2.0/authorize\"})}),\") endpoint\"]}),`\n`,(0,i.jsx)(e.li,{children:'Client IDs were specifically MSFT Authentication Broker (\"29d9ed98-a469-4536-ade2-f981bc1d605e\")'}),`\n`,(0,i.jsx)(e.li,{children:'Resource/Scope was Device Registration Service (DRS) (\"01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9\")'}),`\n`,(0,i.jsx)(e.li,{children:\"Token grant flows were auth code (response_type=code)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Redirect URI includes cloud-based domain join endpoint (typically used during Windows setup or Autopilot)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Login hint contains user principal email address (Target)\"}),`\n`,(0,i.jsx)(e.li,{children:\"Request is ultimately for an ADRS token\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"If the user is phished and opens the URL, authenticating will provide an ADRS token that is required for the adversary to register a device and subsequently obtain a PRT with the device\\u2019s private key and PEM file.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Volexity's blog also includes additional information about tracking the activity of the compromise identity via the device ID registered as well as post-compromise activity following an approved 2FA request was identified, allowing the adversary to download the target's email with a session tied to the newly registered device.\"}),`\n`,(0,i.jsx)(e.p,{children:\"With this understanding of each phishing attempt, our next goal is to replicate this in our own MSFT tenant as accurately as possible to gather data for plausible detections.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"our-emulation-efforts\",children:\"Our Emulation Efforts\"}),`\n`,(0,i.jsx)(e.p,{children:\"Alright \\u2013 so at this point, we\\u2019ve covered the fundamentals of OAuth and how Microsoft Entra ID implements it. We broke down what defines a Microsoft OAuth phishing URL, decoded its critical parameters, and pulled key insights from Volexity's excellent investigation to identify indicators aligned with these phishing workflows.\"}),`\n`,(0,i.jsx)(e.p,{children:\"But theory and a glimpse into Volexity's notebook only takes us so far.\"}),`\n`,(0,i.jsx)(e.p,{children:\"To truly understand the attacker's perspective, the full chain of execution, tooling quirks, subtle pitfalls, and opportunities for abuse,  we decided to go hands-on with whitebox testing. We recreated the OAuth phishing process in our own tenant, emulating everything from token harvesting to resource access. The goal? Go beyond static indicators and surface the behavioral breadcrumbs that defenders can reliably detect.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Let's get into it.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"prerequisites\",children:\"Prerequisites\"}),`\n`,(0,i.jsx)(e.p,{children:\"For starters, it is good to share some details about our threat research and detection environment in Azure.\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Established Azure tenant: TENANT.onmicrosoft.com\"}),`\n`,(0,i.jsx)(e.li,{children:\"Established Sharepoint Domain: DOMAIN.sharepoint.com\"}),`\n`,(0,i.jsx)(e.li,{children:\"Native IdP Microsoft Entra ID \\u2013 Enabling our IAM\"}),`\n`,(0,i.jsx)(e.li,{children:\"Microsoft 365 Licenses (P2) for All Users\"}),`\n`,(0,i.jsx)(e.li,{children:\"Azure Activity Logs Streaming to EventHub\"}),`\n`,(0,i.jsx)(e.li,{children:\"Microsoft Entra ID Sign-In Logs Streaming to EventHub\"}),`\n`,(0,i.jsx)(e.li,{children:\"Microsoft Entra ID Audit Logs Streaming to EventHub\"}),`\n`,(0,i.jsx)(e.li,{children:\"Microsoft Graph Audit Logs Streaming to EventHub\"}),`\n`,(0,i.jsx)(e.li,{children:\"Microsoft 365 Audit Logs Streaming to EventHub\"}),`\n`,(0,i.jsx)(e.li,{children:\"Elastic Azure and M365 Integration Enabled for Log Digestion from EventHub\"}),`\n`,(0,i.jsx)(e.li,{children:\"Basic Admin User Enabled with CAP Requiring MFA\"}),`\n`,(0,i.jsx)(e.li,{children:\"MSFT Authenticator App on Mobile for 2FA Emulation\"}),`\n`,(0,i.jsx)(e.li,{children:\"Windows 10 Desktop with NordVPN (Adversary Box)\"}),`\n`,(0,i.jsx)(e.li,{children:\"macOS endpoint (Victim box)\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Note that while we could follow the workflows from a single endpoint, often we need data that reflects separate source addresses to developer detection variations of impossible travel.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"scenario-1-oauth-phishing-as-vscode-client\",children:\"Scenario 1: OAuth Phishing as VSCode Client\"}),`\n`,(0,i.jsx)(e.h2,{id:\"emulation\",children:\"Emulation\"}),`\n`,(0,i.jsx)(e.p,{children:\"To emulate the phishing technique documented by Volexity, we built a Python script to generate an OAuth 2.0 authorization URL using Microsoft Entra ID. The URL initiates an authorization code grant flow, impersonating the first-party Visual Studio Code app to request delegated access to the Microsoft Graph API.\"}),`\n`,(0,i.jsx)(e.p,{children:\"We configured the URL with the following parameters:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-json\",children:`{\n  \"client_id\": \"aebc6443-996d-45c2-90f0-388ff96faa56\",\n  \"response_type\": \"code\",\n  \"redirect_uri\": \"insiders.vscode.dev/redirect\",\n  \"scope\": \"https://graph.microsoft.com/.default\",\n  \"login_hint\": \"user @ tenant.onmicrosoft.com\",\n  \"prompt\": \"select_account\",\n  \"state\": \"nothingtoseehere\"\n}\n`})}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:\"Figure 1: Parameters for OAuth Phishing URL\"})}),`\n`,(0,i.jsx)(e.p,{children:\"This URL is shared with the target (in our case, a MacOS test user). When opened, it authenticates the user and completes the OAuth workflow. Using browser developer tools, we capture the authorization code returned in the redirect URI,  exactly what the attackers asked their victims to send back.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image7.png\",alt:\"Figure 2: Redirect query string parameters with authorization code after authentication\",width:\"1999\",height:\"436\"})}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image2.png\",alt:\"Figure 3: Python script execution for generating OAuth phishing URL and exchanging auth code for Token\",width:\"871\",height:\"1106\"})}),`\n`,(0,i.jsx)(e.p,{children:\"After receiving the code, we issue a POST request to:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-json\",children:`{token_url: \"https://login.microsoftonline.com/organizations/oauth2/v2.0/token\"}\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"This exchange uses the authorization_code grant type, passing the code, client ID, and redirect URI. Microsoft returns an access token, but no refresh token. You might ask why that is?\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The scope \",(0,i.jsx)(e.a,{href:\"https://graph.microsoft.com/.default\",rel:\"nofollow\",children:\"https://graph.microsoft.com/.default\"}),\" instructs Microsoft to issue a bearer token for all Graph permissions already granted to the VSCode app on behalf of the user. This is a static scope, pulling from the app registration,  it does not include dynamic scopes like Mail.Read or offline_access.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Microsoft's documentation states:\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"\\u201C\\u201C\",(0,i.jsx)(e.em,{children:\"Clients can\\u2019t combine static (.default) consent and dynamic consent in a single request.\"}),\"\\u201D\\u201D\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Therefore, trying to include offline_access alongside \",(0,i.jsx)(e.em,{children:\".default\"}),\" results in an error. If the attacker wants a refresh token, they must avoid \",(0,i.jsx)(e.em,{children:\".default\"}),\" and instead explicitly request \",(0,i.jsx)(e.em,{children:\"offline_access\"}),\" and the required delegated scopes (e.g., Mail.Read) \\u2013 Assuming the app registration supports those.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"With the access token in hand, we pivoted to a second script to interact with the Microsoft Graph API. The goal \\u2013 extract email messages from the victim\\u2019s account \\u2014 just as the attacker would.\"}),`\n`,(0,i.jsx)(e.p,{children:\"To do this, we included the access token as a Bearer JWT in the authorization header and made a GET request to the following endpoint:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-json\",children:`{graph_url: \"https://graph.microsoft.com/v1.0/me/messages\"}\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"The response returns a JSON array of email objects. From here, we simply iterate through the results and parse out useful metadata such as sender, subject, and received time.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image4.png\",alt:\"Figure 4: Leveraging access token to access user emails via Graph API\",width:\"895\",height:\"970\"})}),`\n`,(0,i.jsx)(e.p,{children:\"To test the token\\u2019s broader privileges, we also attempted to enumerate SharePoint sites using:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-json\",children:`{graph_search_url: \"https://graph.microsoft.com/v1.0/sites?search=*\"}\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"The request failed with an access denied error \\u2013 which leads us to an important question: why did email access work, but SharePoint access did not? The reason is that the first-party client (VSCode: aebc6443-996d-45c2-90f0-388ff96faa56) does not have default delegated permissions with Graph for Sharepoint \\u2013 as predefined by Microsoft. Therefore, we know the adversary is limited on what they can access.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"To ensure this was accurate, we decoded the access token to identify the SCP associated with VSCode with \",(0,i.jsx)(e.em,{children:\".default\"}),\" permissions to Graph \\u2013 Verifying no \",(0,i.jsx)(e.em,{children:\"Sites.\"}),\"* permissioned by Microsoft.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image11.png\",alt:\"Figure 5: Decoded Entra ID Access Token\",width:\"622\",height:\"622\"})}),`\n`,(0,i.jsx)(e.p,{children:\"This is one of the variations described by Volexity, but does help us understand more about the processes behind the scenes for the adversary \\u2013 as well as resources, OAuth, and more for Microsoft Entra ID.\"}),`\n`,(0,i.jsx)(e.p,{children:\"With the emulation complete, we now turn to identifying high-fidelity signals that are viable for SIEM detection and threat hunting. Our focus is on behavior observables in Microsoft Entra ID and Microsoft Graph logs.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"detection\",children:\"Detection\"}),`\n`,(0,i.jsx)(e.h4,{id:\"signal-1---microsoft-entra-id-oauth-phishing-as-visual-studio-code-client\",children:\"Signal 1 - Microsoft Entra ID OAuth Phishing as Visual Studio Code Client\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"A successful OAuth 2.0 (authorization) and OpenID Connect (authentication) flow was completed using the first-party Microsoft application Visual Studio Code (VSCode). The sign-in occurred on behalf of the phished user principal, resulting in delegated access to Microsoft Graph with \",(0,i.jsx)(e.em,{children:\".default\"}),\" permissions.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`event.dataset: \"azure.signinlogs\" and\nevent.action: \"Sign-in activity\" and\nevent.outcome: \"success\" and\nazure.signinlogs.properties.user_type: \"Member\" and\nazure.signinlogs.properties.authentication_processing_details: *Oauth* and\nazure.signinlogs.category: \"NonInteractiveUserSignInLogs\" and\n(\n  azure.signinlogs.properties.resource_display_name: \"Microsoft Graph\" or\n  azure.signinlogs.properties.resource_id: \"00000003-0000-0000-c000-000000000000\"\n) and (\n  azure.signinlogs.properties.app_id: \"aebc6443-996d-45c2-90f0-388ff96faa56\" or\n  azure.signinlogs.properties.app_display_name: \"Visual Studio Code\"\n)\n`})}),`\n`,(0,i.jsx)(e.h4,{id:\"signal-2---microsoft-entra-session-reuse-with-suspicious-graph-access\",children:\"Signal 2 - Microsoft Entra Session Reuse with Suspicious Graph Access\"}),`\n`,(0,i.jsx)(e.p,{children:\"While traditional query languages like KQL are excellent for filtering and visualizing individual log events, they struggle when a detection relies on correlating multiple records across datasets, time, and identifiers. This is where ES|QL (Elasticsearch Query Language) becomes essential. These types of multi-event correlations, temporal logic, and field normalization are difficult or entirely impossible in static filter-based query languages like KQL without writing multiple disjointed queries and manually correlating them after the fact.\"}),`\n`,(0,i.jsx)(e.p,{children:\"This detection relies on correlating multiple events that happen close together but from different data sources,  namely sign-in logs and Microsoft Graph activity. The goal is to find suspicious reuse of the same session ID across multiple IPs, potentially indicating session hijacking or token abuse. For the sake of space regarding this publication, you can view the actual detection rule in the Detection Rules section. To better illustrate the flow of the query and meaning, below is a diagram to illustrate at a higher level.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[ FROM logs-azure.* ]\n        |\n        |  \\u2190 Pulls events from all relevant Microsoft Cloud datasets:\n        |     - azure.signinlogs (authentication)\n        |     - azure.graphactivitylogs (resource access)\n        \\u2193\n[ WHERE session_id IS NOT NULL AND IP NOT MICROSOFT ASN ]\n        |\n        |  \\u2190 Filters out Microsoft-owned infrastructure (e.g., internal proxy,\n        |     Graph API relays) using ASN checks.\n        |  \\u2190 Ensures session ID exists so events can be correlated together.\n        \\u2193\n[ EVAL session_id, event_type, time_window, etc. ]\n        |\n        |  \\u2190 Normalizes key fields across datasets:\n        |     - session_id (from signin or Graph)\n        |     - user ID, app ID, event type (\"signin\" or \"graph\")\n        |  \\u2190 Buckets events into 5-minute windows using DATE_TRUNC()\n        \\u2193\n[ KEEP selected fields ]\n        |\n        |  \\u2190 Retains only what's needed:\n        |     session_id, timestamp, IP, user, client ID, etc.\n        \\u2193\n[ STATS BY session_id + time_window ]\n        |\n        |  \\u2190 Groups by session and time window to compute:\n        |     - unique IPs used\n        |     - apps involved\n        |     - first and last timestamps\n        |     - whether both signin and graph occurred\n        \\u2193\n[ EVAL time_diff + signin_to_graph_delay ]\n        |\n        |  \\u2190 Calculates:\n        |     - time_diff: full session duration\n        |     - delay: gap between signin and Graph access\n        \\u2193\n[ WHERE types_count \u003e 1 AND unique_ips \u003e 1 AND delay \u003c= 5 ]\n        |\n        |  \\u2190 Flags sessions where:\n        |     - multiple event types (signin + graph)\n        |     - multiple IPs used\n        |     - all occurred within 5 minutes\n        \\u2193\n[ Output = Suspicious Session Reuse Detected ]\n`})}),`\n`,(0,i.jsx)(e.h4,{id:\"signal-3---microsoft-entra-id-concurrent-sign-ins-with-suspicious-properties\",children:\"Signal 3 - Microsoft Entra ID Concurrent Sign-Ins with Suspicious Properties\"}),`\n`,(0,i.jsx)(e.p,{children:\"This detection identifies suspicious sign-ins in Microsoft Entra ID where a user authenticates using the device code flow without MFA or sign-ins using the VSCode client. When the same identity signs in from two or more distinct IPs within a short time window using either method, it may indicate token replay, OAuth phishing, or adversary-in-the-middle (AitM) activity.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[ FROM logs-azure.signinlogs* ]\n        |\n        |  \\u2190 Pulls only Microsoft Entra ID sign-in logs\n        \\u2193\n[ WHERE @timestamp \u003e NOW() - 1h AND event.outcome == \"success\" ]\n        |\n        |  \\u2190 Filters to the last hour and keeps only successful sign-ins\n        \\u2193\n[ WHERE source.ip IS NOT NULL AND identity IS NOT NULL ]\n        |\n        |  \\u2190 Ensures the sign-in is tied to a user and IP for correlation\n        \\u2193\n[ KEEP fields: identity, app_id, auth_protocol, IP, etc. ]\n        |\n        |  \\u2190 Retains app/client, IP, auth method, and resource info\n        \\u2193\n[ EVAL detection flags ]\n        |\n        |  \\u2190 Labels events as:\n        |     - device_code: if MFA not required\n        |     - visual_studio: if VS Code client used\n        |     - other: everything else\n        \\u2193\n[ STATS BY identity ]\n        |\n        |  \\u2190 Aggregates all sign-ins per user, calculates:\n        |     - IP count\n        |     - Device Code or VSCode usage\n        |     - App/client/resource details\n        \\u2193\n[ WHERE src_ip \u003e= 2 AND (device_code_count \u003e 0 OR vsc \u003e 0) ]\n        |\n        |  \\u2190 Flags users with:\n        |     - Sign-ins from multiple IPs\n        |     - And either:\n        |         - Device Code w/o MFA\n        |         - Visual Studio Code app\n        \\u2193\n[ Output = Potential OAuth Phishing or Token Misuse ]\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"While this variation of OAuth phishing lacks the full persistence offered by refresh tokens or PRTs, it still provides adversaries with valuable one-time access to sensitive user data \\u2013 such as emails \\u2013 through legitimate channels. This exercise helps us understand the limitations and capabilities of static \",(0,i.jsx)(e.em,{children:\".default\"}),\" scopes, the influence of app registrations, and how Microsoft Graph plays a pivotal role in post-authentication. It also reinforces a broader lesson: not all OAuth phishing attacks are created equal. Some aim for longevity (as we will see later) through refresh tokens or device registration, while others focus on immediate data theft via first-party clients. Understanding the nuances is essential for accurate detection logic.\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"scenario-2-oauth-phishing-for-device-registration\",children:\"Scenario 2: OAuth Phishing for Device Registration\"}),`\n`,(0,i.jsx)(e.p,{children:\"As we stated earlier \\u2013 Volexity also reported a separate phishing playbook targeting victims, this time with the goal of registering a virtual device and obtaining a PRT. While this approach requires more steps from the adversary, the payoff is a token-granting token that offers far more utility for completing their operations. For our emulation efforts, we needed to expand our toolset and rely on ROADtools, just as the adversary did to remain accurate, however, several other python scripts were made for initial phishing and post-compromise actions.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"emulation-1\",children:\"Emulation\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Starting with the initial phishing, we adjusted our Python script to craft a different OAuth URL that would be sent to our victim. This time, the focus was on our first-party client ID being the Microsoft Authentication Broker, requesting a refresh token with \",(0,i.jsx)(e.em,{children:\"offline_access\"}),\" and redirecting to Entra ID\\u2019s cloud domain device joining endpoint URI.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-json\",children:`{\n  \"client_id\": \"29d9ed98-a469-4536-ade2-f981bc1d605e\",\n  \"response_type\": \"code\",\n  \"response_mode\": \"query\",\n  \"redirect_uri\": \"https://login.microsoftonline.com/WebApp/CloudDomainJoin/8\",\n  \"resource\": \"01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9\",\n  \"state\": \"nothingtoseehere\"\n}\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"If successful and our victim authenticates, the OAuth workflow will complete and the user will be redirected to the specified URI with an appended authorization code in the query parameters. Again, this code is the critical piece,  it must be shared back with the adversary in order to exchange it for tokens. In our case, once the phishing URL is opened and the target authenticates, we capture the authorization code embedded in the redirect and use it to request tokens from the Microsoft Entra ID token endpoint.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image5.png\",alt:\"Figure 6: Microsoft Authentication Broker OAuth Phishing and token exchange with custom Python script\",width:\"894\",height:\"956\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Now, here's where it gets interesting. In response to the token request, we receive three types of tokens: an access token, a refresh token, and an ID token. You might be asking \\u2013  why do we get more than just an access token? The answer lies in the scopes we initially requested: \",(0,i.jsx)(e.em,{children:\"openid\"}),\", \",(0,i.jsx)(e.em,{children:\"offline_access\"}),\", and \",(0,i.jsx)(e.em,{children:\"profile\"}),\".\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"openid\"}),\" grants us an ID token, which is part of the OpenID Connect layer and confirms the identity of the user \\u2014 this is your authentication (authN) artifact.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:\"offline_access\"}),\" provides a refresh token, enabling us to maintain a session and request new access tokens without requiring re-authentication, this supports persistent access but is critical for our use with ROADtx.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"And the access token itself is used to authorize requests to protected APIs like Microsoft Graph, this represents authorization (authZ).\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"With these three tokens, we have everything: authentication, authorization, and long-term session continuity. That\\u2019s enough to shift from a simple OAuth phishing play into a more persistent foothold \\u2014 like registering a new device in Microsoft Entra ID.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image10.png\",alt:\"Figure 7: Captured JWT access, refresh and id token after exchange with authorization code\",width:\"845\",height:\"671\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Now let\\u2019s connect the dots. A PRT requires registration of a valid device, one that Entra ID recognizes via a device certificate and private key. This is where ROADtx comes into play. Because our initial OAuth phishing impersonated a joined device flow, and the client used was the Microsoft Authentication Broker (a first-party client that interacts with the Device Registration Service), we already have the right access token in hand to interact with DRS. Notice in our returned object the scope is \",(0,i.jsx)(e.em,{children:\"adrs_access\"}),\" which indicates Azure DRS access and is important for detections later.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"From here, we simply drop the JSON object received from our token exchange into the \",(0,i.jsx)(e.em,{children:\".roadtool_auth\"}),\" file. This file is natively consumed by ROADtools, which uses the stored tokens to perform the device registration, completing the adversary\\u2019s move into persistence and setting the stage for obtaining a valid PRT.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"After obtaining the tokens, we prep them for ROADtx by reformatting the JSON. ROADtx expects keys in camelCase, and we must also include the Microsoft Authentication Broker\\u2019s client ID as \",(0,i.jsx)(e.em,{children:\"_clientId\"}),\". This setup allows us to run the \",(0,i.jsx)(e.em,{children:\"refreshtokento\"}),\" command, which takes our refresh token and exchanges it for a new JWT scoped to the DRS \\u2014 specifically, the service principal \",(0,i.jsx)(e.em,{children:\"urn:ms-drs:enterpriseregistration.windows.net\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image1.png\",alt:\"Figure 8: New authentication material from \\u201Crefreshtokento\\u201D command for DRS as Microsoft Authentication Broker\",width:\"1115\",height:\"366\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Once that\\u2019s in place, we use the device command to simulate a new device registration. This operation doesn\\u2019t require any actual virtual machine or physical host because it\\u2019s a backend registration that simply creates an entry in Entra ID. Upon success, we\\u2019re issued a valid device ID, PEM-encoded certificate, and private key \\u2014 all of which are required to simulate a valid hybrid-joined device in the Microsoft ecosystem.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image9.png\",alt:\"Figure 9: \\u201Cdevice\\u201D command output from registering a device and receiving a PEM certificate and private key\",width:\"996\",height:\"762\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"With our device identity established, we invoke the \",(0,i.jsx)(e.em,{children:\"prt\"}),\" command. This uses the refresh token, device certificate, and private key to mint a new PRT \\u2014 a highly privileged credential that effectively ties together user and device trust in Microsoft Entra ID.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image3.png\",alt:\"Figure 10: \\u201Cprt\\u201D command with refresh token, PEM certificate and private key to obtain a PRT\",width:\"1538\",height:\"844\"})}),`\n`,(0,i.jsx)(e.p,{children:\"And just like that \\u2014 whollah! \\u2014 we have a PRT.\"}),`\n`,(0,i.jsx)(e.p,{children:\"But why go through all this? Why register a device, generate a cert, and obtain a PRT when we already had an access token, ID token, and refresh token?\"}),`\n`,(0,i.jsx)(e.p,{children:\"Because the PRT is the key to full user and device identity emulation. Think of it as a Kerberos-like ticket-granting token in Entra ID\\u2019s world, but instead \\u2013 a token-granting token. With a valid PRT:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"An adversary can request new access and ID tokens for first-party apps like Outlook, SharePoint, or Teams without needing user interaction.\"}),`\n`,(0,i.jsx)(e.li,{children:\"The PRT enables seamless single sign-on SSO across multiple services, bypassing MFA and other conditional access policies (CAP) that would typically re-prompt the user. This is crucial for persistence as CAP and MFA are often huge barriers for adversaries.\"}),`\n`,(0,i.jsx)(e.li,{children:\"It supports long-lived persistence, as the PRT can be silently renewed and leveraged across sessions as long as the device identity remains trusted.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"And perhaps most dangerously \\u2014 the PRT allows adversaries to impersonate a fully compliant, domain-joined device and user combo, effectively bypassing most conventional detection and response controls making the line between benign vs suspicious extremely thin for hunters and analysts.\"}),`\n`,(0,i.jsx)(e.p,{children:\"This makes the PRT an incredibly valuable asset or one that enables covert lateral movement, privilege escalation, and deep access to Microsoft 365 services. It\\u2019s not just about getting in anymore \\u2014 it\\u2019s about staying undetected.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Let\\u2019s not forget post-compromise activity\\u2026\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"ROADtx offers a few powerful commands frequently used by adversaries \\u2013 \",(0,i.jsx)(e.em,{children:\"prtenrich\"}),\" and \",(0,i.jsx)(e.em,{children:\"browserprtauth\"}),\". For example, we can access most browser-based UI services in the Microsoft suite by supplying our PRT which includes the necessary metadata for authentication and authorization \\u2013 which originally belonged to our phishing victim (me), but is actually the Microsoft Authentication Broker acting on their behalf.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image12.png\",alt:\"Figure 11: Accessing M365 Copilot with PRT via \\u201Cbrowserprtauth\\u201D command\",width:\"1581\",height:\"744\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Volexity also reported that following device registration and the PRT acquisition \\u2013 a 2FA request was sent to the initial victim, approved and then used to access emails via SharePoint. While they do not specify exactly how requests were made to \\u2013 it\\u2019s reasonable to assume the adversary used the PRT to authenticate via a first-party Microsoft client \\u2013 with the actual data access happening through Microsoft Graph. Graph remains a popular target post-compromise because it serves as a central API hub for most Microsoft 365 resources.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"To start \\u2013 let\\u2019s leverage ROADtx to auth with our PRT where Microsoft Teams is our client and Microsoft Graph is our resource. When using the \",(0,i.jsx)(e.em,{children:\"prtauth\"}),\" command with our PRT, we are able to obtain a new access token and refresh token \\u2013 clearly demonstrating the utility of the PRT as a token-granting token within Microsoft\\u2019s identity fabric.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image8.png\",alt:\"Figure 12: \\u201Cprtauth\\u201D command for tokens as MSFT Teams client for MSFT Graph resource\",width:\"907\",height:\"489\"})}),`\n`,(0,i.jsx)(e.p,{children:\"Once our access token is obtained, we plug it into a custom Python script to start enumerating our SharePoint sites, drives, items which allows us to identify files of interest and download their contents.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/assets/images/entra-id-oauth-phishing-detection/image6.png\",alt:\"Figure 13: Discovering all SharePoint sites in tenant and downloading user files via MSFT Graph\",width:\"1647\",height:\"816\"})}),`\n`,(0,i.jsx)(e.p,{children:\"With this emulation \\u2013 we showed how adversaries can chain OAuth phishing with the Microsoft Authentication Broker and obtain necessary credential material to leverage ROADtx for acquiring a PRT. This PRT then being an important utility post-compromise to access sensitive files, enumerate tenant resources and much more.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Now, let\\u2019s shift focus: what are plausible and accurate signals for detecting this activity?\"}),`\n`,(0,i.jsx)(e.h2,{id:\"detection-1\",children:\"Detection\"}),`\n`,(0,i.jsx)(e.h3,{id:\"signal-1---microsoft-entra-id-oauth-phishing-as-microsoft-authentication-broker\",children:\"Signal 1 - Microsoft Entra ID OAuth Phishing as Microsoft Authentication Broker\"}),`\n`,(0,i.jsx)(e.p,{children:\"Identifies instances where a user principal initiates an OAuth authorization code flow using the Microsoft Authentication Broker (MAB) as the client and the Device Registration Service (DRS) as the target resource. This detection focuses on cases where a single session ID is reused across two or more distinct IP addresses within a short time window, and at least one request originates from a browser \\u2014 behavior commonly associated with phishing.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`[ FROM logs-azure.signinlogs-* ]\n        |\n        |  \\u2190 Pulls all Microsoft Entra ID sign-in logs\n        \\u2193\n[ WHERE app_id == MAB AND resource_id == DRS ]\n        |\n        |  \\u2190 Filters to OAuth auth code requests targeting\n        |     Microsoft Authentication Broker + Device Reg Service\n        \\u2193\n[ EVAL session_id + is_browser ]\n        |\n        |  \\u2190 Extracts session ID and flags browser-based activity\n        \\u2193\n[ STATS BY 30-minute window, user, session_id ]\n        |\n        |  \\u2190 Groups logins within same session and time window,\n        |     then aggregates:\n        |       - user/session/token identifiers\n        |       - distinct IPs and geo info\n        |       - user agent, browser presence\n        |       - app/resource/client info\n        \\u2193\n[ WHERE ip_count \\u2265 2 AND session_id_count == 1 ]\n        |\n        |  \\u2190 Identifies reuse of a single session ID\n        |     across \\u2265 2 different IP addresses\n        \\u2193\n[ AND has_browser \\u2265 1 AND auth_count \\u2265 2 ]\n        |\n        |  \\u2190 Requires at least one browser-based request\n        |     and at least two total sign-in events\n        \\u2193\n[ Output = Suspicious OAuth Flow with Auth Broker for DRS ]\n\n`})}),`\n`,(0,i.jsx)(e.h3,{id:\"signal-2---suspicious-adrs-token-request-by-microsoft-auth-broker\",children:\"Signal 2 - Suspicious ADRS Token Request by Microsoft Auth Broker\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Identifies Microsoft Entra ID sign-in events where a user principal authenticates using a refresh token issued to the Microsoft Authentication Broker (MAB) client, targeting the Device Registration Service (DRS) with the \",(0,i.jsx)(e.em,{children:\"adrs_access\"}),\" OAuth scope. This pattern may indicate token-based access to DRS following an initial authorization code phishing or device registration flow.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'event.dataset: \"azure.signinlogs\" and azure.signinlogs.properties.app_id : \"29d9ed98-a469-4536-ade2-f981bc1d605e\" and azure.signinlogs.properties.resource_id : \"01cb2876-7ebd-4aa4-9cc9-d28bd4d359a9\" and azure.signinlogs.properties.authentication_processing_details.`Oauth Scope Info`: *adrs_access* and azure.signinlogs.properties.incoming_token_type: \"refreshToken\" and azure.signinlogs.properties.user_type: \"Member\"\\n'})}),`\n`,(0,i.jsx)(e.h3,{id:\"signal-3---unusual-device-registration-in-entra-id\",children:\"Signal 3 - Unusual Device Registration in Entra ID\"}),`\n`,(0,i.jsx)(e.p,{children:\"Detects a sequence of Entra ID audit log events indicating potential malicious device registration activity using a refresh token, commonly seen after OAuth phishing. This pattern mimics the behavior of tools like ROADtx, where a newly registered Windows device (with a hardcoded OS version 10.0.19041.928) is added by the Device Registration Service, followed by user and owner assignments. All events must share the same correlation ID and occur within a one-minute window, strongly suggesting automation or script-driven registration rather than legitimate user behavior.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'sequence by azure.correlation_id with maxspan=1m\\n[any where event.dataset == \"azure.auditlogs\" and azure.auditlogs.identity == \"Device Registration Service\" and azure.auditlogs.operation_name == \"Add device\" and azure.auditlogs.properties.additional_details.value like \"Microsoft.OData.Client/*\" and (\\n  azure.auditlogs.properties.target_resources.`0`.modified_properties.`1`.display_name == \"CloudAccountEnabled\" and \\nazure.auditlogs.properties.target_resources.`0`.modified_properties.`1`.new_value: \"[true]\") and azure.auditlogs.properties.target_resources.`0`.modified_properties.`3`.new_value like \"*10.0.19041.928*\"]\\n[any where event.dataset == \"azure.auditlogs\" and azure.auditlogs.operation_name == \"Add registered users to device\" and azure.auditlogs.properties.target_resources.`0`.modified_properties.`2`.new_value like \"*urn:ms-drs:enterpriseregistration.windows.net*\"]\\n[any where event.dataset == \"azure.auditlogs\" and azure.auditlogs.operation_name == \"Add registered owner to device\"]\\n'})}),`\n`,(0,i.jsx)(e.h3,{id:\"signal-3---entra-id-rt-to-prt-transition-from-same-user-and-device\",children:\"Signal 3 - Entra ID RT to PRT Transition from Same User and Device\"}),`\n`,(0,i.jsx)(e.p,{children:\"This detection identifies when a Microsoft Entra ID user first authenticates using a refresh token issued to the Microsoft Authentication Broker (MAB), followed shortly by the use of a Primary Refresh Token (PRT) from the same device. This sequence is rare in normal user behavior and may indicate an adversary has successfully registered a device and escalated to persistent access using tools like ROADtx. By filtering out activity tied to the Device Registration Service (DRS) in the second step, the rule focuses on post-registration usage of the PRT to access other Microsoft 365 services.\"}),`\n`,(0,i.jsx)(e.p,{children:\"This behavior strongly suggests token-based compromise and long-term session emulation, particularly when device trust is established silently. Catching this transition from refresh token to PRT is critical for surfacing high-fidelity signals of OAuth phishing and post-compromise persistence.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`sequence by azure.signinlogs.properties.user_id, azure.signinlogs.properties.device_detail.device_id with maxspan=1d\n  [authentication where \n    event.dataset == \"azure.signinlogs\" and\n    azure.signinlogs.category == \"NonInteractiveUserSignInLogs\" and\n    azure.signinlogs.properties.app_id == \"29d9ed98-a469-4536-ade2-f981bc1d605e\" and\n    azure.signinlogs.properties.incoming_token_type == \"refreshToken\" and\n    azure.signinlogs.properties.device_detail.trust_type == \"Azure AD joined\" and\n    azure.signinlogs.properties.device_detail.device_id != null and\n    azure.signinlogs.properties.token_protection_status_details.sign_in_session_status == \"unbound\" and\n    azure.signinlogs.properties.user_type == \"Member\" and\n    azure.signinlogs.result_signature == \"SUCCESS\"\n  ]\n  [authentication where \n    event.dataset == \"azure.signinlogs\" and\n    azure.signinlogs.properties.incoming_token_type == \"primaryRefreshToken\" and\n    azure.signinlogs.properties.resource_display_name != \"Device Registration Service\" and\n    azure.signinlogs.result_signature == \"SUCCESS\"\n  ]\n`})}),`\n`,(0,i.jsx)(e.h3,{id:\"signal-4---unusual-prt-usage-and-registered-device-for-user-principal\",children:\"Signal 4 - Unusual PRT Usage and Registered Device for User Principal\"}),`\n`,(0,i.jsx)(e.p,{children:\"This detection surfaces when a Microsoft Entra ID user registers a new device not previously seen within the last 7 days \\u2013 behavior often associated with OAuth phishing campaigns that chain into ROADtx-based device registration. In these attacks, adversaries trick users into authorizing access for the Microsoft Authentication Broker (MAB) targeting the DRS, obtain a RT, and then use ROADtx to silently register a fake Windows device and mint a PRT. This rule alerts when a user principal authenticates from a newly observed device ID, particularly if the session is unbound, which is characteristic of token replay or device spoofing. Because PRTs require a registered and trusted device, this signal plays a critical role in identifying when an adversary has crossed from basic token abuse into persistent, stealthy access aligned with long-term compromise.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:`event.dataset: \"azure.signinlogs\" and\n    event.category: \"authentication\" and\n    azure.signinlogs.properties.user_type: \"Member\" and\n    azure.signinlogs.properties.token_protection_status_details.sign_in_session_status: \"unbound\" and\n    not azure.signinlogs.properties.device_detail.device_id: \"\" and\n    azure.signinlogs.properties.user_principal_name: *\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://www.elastic.co/docs/solutions/security/detect-and-alert/about-detection-rules\",rel:\"nofollow\",children:\"New Terms\"}),\" Values:\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"azure.signinlogs.properties.user_principal_name\"}),`\n`,(0,i.jsx)(e.li,{children:\"azure.signinlogs.properties.device_detail.device_id\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"This emulation helped us validate the full attacker workflow \\u2013 from phishing for consent to establishing device trust and minting a PRT for long-term persistence. By chaining OAuth abuse with device registration, adversaries can satisfy CAPs, impersonate compliant endpoints and move laterally through cloud environments \\u2013 often without triggering traditional security controls.\"}),`\n`,(0,i.jsx)(e.p,{children:\"These nuances matter. When viewed in isolation, individual events like token issuance or device registration may appear benign. But when correlated across sign-in logs, audit data and token metadata, they expose a distinct trail of identity compromise.\"}),`\n`,(0,i.jsx)(e.h1,{id:\"key-telemetry-details-for-detection-and-abuse\",children:\"Key Telemetry Details for Detection and Abuse\"}),`\n`,(0,i.jsx)(e.p,{children:\"Throughout our emulation and detection efforts, specific telemetry artifacts consistently proved essential for separating benign OAuth activity from malicious abuse. Understanding how these fields appear in Microsoft Entra ID logs \\u2013 and how attackers manipulate them \\u2013 is critical for effective hunting and detection engineering. From client IDs and grant types to device compliance, token types and conditional access outcomes, these signals tell the story of identity-based attacks. Below we have curated a list of those most important and how they can enable us.\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Client Application IDs (client_id)\"}),\": Identify the application initiating the OAuth request. First-party clients (e.g. VSCode, Auth Broker) can be abused to blend in. Third-party clients may be malicious or unreviewed - often representing consent grant attacks. Mainly used to identify risky or unexpected app usage.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Target Resource (resource_id / resource_display_name)\"}),\": Defines which MSFT service is being accessed (e.g. MSFT Graph or Teams). High value targets include \\u2013 Graph API, SharePoint, Outlook, Teams and Directory Services. Resource targeting is often scoped by attacker objectives.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Principal type (user_type)\"}),\": Indicates if the sign-in was by a member (user) or service principal. Phishing campaigns almost always target member accounts. This enables easy filtering in detection logic but helps pair unusual first-party client requests on-behalf-of user principals.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"OAuth Grant Type (authentication_processing_details)\"}),\": Key to understanding how the token was obtained \\u2013 authorization codes, refresh tokens, device codes, client credentials, etc. Whereas refresh tokens and device code reuse are high-fidelity signals of post-compromise.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Geolocation\"}),\": Enables us to identify atypical sign-ins (e.g. rare country seen) or impossible travel (same user from distant locations in a short time). Combined with session ID and correlation IDs, these can reveal token hijacking, post identity compromise or lateral movement.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Device Metadata (device_detail, trust_type, compliance_state)\"}),\": Includes Device IDs, operating system, trust types, compliance, managed-state and more. Device registration and PRT issuance are tied to this metadata. Often a goal for adversaries to satisfy CAP and gain trusted access that is persistent.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Authentication Protocols and Types (authentication_protocol / incoming_token_type)\"}),\": Reveals whether the session was OAuth-based or if MFA was used. Token sources incoming are those used for this request that provide authN or authZ. Useful for detecting token reuse, non-interactive sign-ins.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Authentication Material and Session Context\"}),\": Tokens used can be inferred via incoming token type, token protection status and the session ID. Session reuse, long session duration or multiple IPs tied to a single session often indicate abuse.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Conditional Access Policy Status\"}),\": Evaluated during token issuance \\u2013 however it heavily influences whether access was granted. This helps identify CAP evasion, unexpected policy outcomes or can factor into risk.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Scopes and Consent Behavior\"}),\": Requested scopes appear in the SCP or OAuth parameters captured in sign-in logs. Indicators of abuse include \",(0,i.jsx)(e.em,{children:\"offline_access\"}),\", \",(0,i.jsx)(e.em,{children:\".default\"}),\", or broad scopes like \",(0,i.jsx)(e.em,{children:\"Mail.ReadWrite\"}),\". Consent telemetry can help pivot or correlate if the user approved a suspicious application.\"]}),`\n`,(0,i.jsx)(e.h1,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,i.jsx)(e.p,{children:\"Microsoft Entra ID\\u2019s OAuth implementation presents a double-edged sword: it enables powerful, seamless authentication experiences \\u2013 but also exposes new opportunities for adversaries to exploit trust, session persistence and device registration attack paths.\"}),`\n`,(0,i.jsx)(e.p,{children:\"By replicating the OAuth phishing techniques observed by Volexity, our team was able to validate how attackers abuse legitimate Microsoft applications, token flows, and open-source tools to gain stealthy access to sensitive data. We extended this work through hands-on emulation, diving deep into the mechanics of OAuth phishing and workflows, security token metadata and acquisition, helping surface behavioral indicators that defenders can detect.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Our findings reinforce a key point: OAuth abuse doesn\\u2019t rely on malware or code execution. It weaponizes identity, consent, and token reuse \\u2013 making traditional security controls a challenge \\u2013 and why log-based detection, correlation and behavioral analysis are so critical.\"}),`\n`,(0,i.jsx)(e.p,{children:\"We hope the emulation artifacts, detection rules, and lessons shared here help defenders across the community better understand \\u2013 and detect/hunt \\u2013 this evolving class of cloud-based identity threats.\"}),`\n`,(0,i.jsx)(e.p,{children:\"If you're using Elastic, we\\u2019ve open-sourced all the detection rules discussed in this blog to get you started. And if you're hunting in another SIEM, we encourage you to adapt the logic and adjust to your environment accordingly.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Identity is the new perimeter \\u2013 and it\\u2019s time we treated it that way. Stay safe and happy hunting!\"}),`\n`,(0,i.jsx)(e.h1,{id:\"detection-rules\",children:\"Detection Rules\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/d41a83059c78129b4e1337dca10b190b862ca0d2/rules/integrations/azure/initial_access_entra_graph_single_session_from_multiple_addresses.toml\",rel:\"nofollow\",children:\"Microsoft Entra ID Session Reuse with Suspicious Graph Access\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/azure/initial_access_entra_oauth_phishing_via_vscode_client.toml\",rel:\"nofollow\",children:\"Microsoft Entra ID OAuth Phishing via Visual Studio Code Client\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/3625b1b392e03aa7693a5b8251e7a5d3cfa53cce/rules/integrations/azure/initial_access_entra_id_suspicious_oauth_flow_via_auth_broker_to_drs.toml\",rel:\"nofollow\",children:\"Suspicious Microsoft OAuth Flow via Auth Broker to DRS\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/6b6407df88319f466c6cc56147210635bba5eb01/rules/integrations/azure/persistence_entra_id_suspicious_adrs_token_request.toml\",rel:\"nofollow\",children:\"Suspicious ADRS Token Request by Microsoft Auth Broker\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/43b0f0ada7e290bbbc0d4b1d53ed158e7bfbe75c/rules/integrations/azure/persistence_entra_id_suspicious_cloud_device_registration.toml\",rel:\"nofollow\",children:\"Unusual Device Registration in Entra ID\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/a18c76fe84eedc00efd9a712e74a0877b1061550/rules/integrations/azure/persistence_entra_id_rt_to_prt_transition_from_user_device.toml\",rel:\"nofollow\",children:\"Entra ID RT to PRT Transition from Same User and Device\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://github.com/elastic/detection-rules/blob/main/rules/integrations/azure/persistence_entra_id_user_signed_in_from_unusual_device.toml\",rel:\"nofollow\",children:\"Unusual Registered Device for User Principal\"})}),`\n`]}),`\n`,(0,i.jsx)(e.h1,{id:\"references\",children:\"References:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/\",rel:\"nofollow\",children:\"https://www.volexity.com/blog/2025/04/22/phishing-for-codes-russian-threat-actors-target-microsoft-365-oauth-workflows/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/\",rel:\"nofollow\",children:\"https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30\",rel:\"nofollow\",children:\"https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/entra/identity/devices/concept-primary-refresh-token\",rel:\"nofollow\",children:\"https://learn.microsoft.com/en-us/entra/identity/devices/concept-primary-refresh-token\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens\",rel:\"nofollow\",children:\"https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow\",rel:\"nofollow\",children:\"https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/entra/identity-platform/scopes-oidc#the-default-scope\",rel:\"nofollow\",children:\"https://learn.microsoft.com/en-us/entra/identity-platform/scopes-oidc#the-default-scope\"})}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(d,t)})):d(t)}var A=k;return y(_);})();\n;return Component;"},"_id":"articles/entra-id-oauth-phishing-detection.mdx","_raw":{"sourceFilePath":"articles/entra-id-oauth-phishing-detection.mdx","sourceFileName":"entra-id-oauth-phishing-detection.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/entra-id-oauth-phishing-detection"},"type":"Article","imageUrl":"/assets/images/entra-id-oauth-phishing-detection/Security Labs Images 22.jpg","readingTime":"40 min read","series":"","url":"/entra-id-oauth-phishing-detection","headings":[{"level":2,"title":"Why Does This Matter?","href":"#why-does-this-matter"},{"level":2,"title":"Prerequisites","href":"#prerequisites"},{"level":2,"title":"Emulation","href":"#emulation"},{"level":2,"title":"Detection","href":"#detection"},{"level":4,"title":"Signal 1 - Microsoft Entra ID OAuth Phishing as Visual Studio Code Client","href":"#signal-1---microsoft-entra-id-oauth-phishing-as-visual-studio-code-client"},{"level":4,"title":"Signal 2 - Microsoft Entra Session Reuse with Suspicious Graph Access ","href":"#signal-2---microsoft-entra-session-reuse-with-suspicious-graph-access-"},{"level":4,"title":"Signal 3 - Microsoft Entra ID Concurrent Sign-Ins with Suspicious Properties","href":"#signal-3---microsoft-entra-id-concurrent-sign-ins-with-suspicious-properties"},{"level":2,"title":"Emulation","href":"#emulation-1"},{"level":2,"title":"Detection","href":"#detection-1"},{"level":3,"title":"Signal 1 - Microsoft Entra ID OAuth Phishing as Microsoft Authentication Broker","href":"#signal-1---microsoft-entra-id-oauth-phishing-as-microsoft-authentication-broker"},{"level":3,"title":"Signal 2 - Suspicious ADRS Token Request by Microsoft Auth Broker","href":"#signal-2---suspicious-adrs-token-request-by-microsoft-auth-broker"},{"level":3,"title":"Signal 3 - Unusual Device Registration in Entra ID","href":"#signal-3---unusual-device-registration-in-entra-id"},{"level":3,"title":"Signal 3 - Entra ID RT to PRT Transition from Same User and Device ","href":"#signal-3---entra-id-rt-to-prt-transition-from-same-user-and-device-"},{"level":3,"title":"Signal 4 - Unusual PRT Usage and Registered Device for User Principal","href":"#signal-4---unusual-prt-usage-and-registered-device-for-user-principal"}],"author":[{"title":"Terrance DeJesus","slug":"terrance-dejesus","description":"Senior Security Research Engineer, Elastic","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(e,t)=\u003e()=\u003e(t||e((t={exports:{}}).exports,t),t.exports),_=(e,t)=\u003e{for(var n in t)o(e,n,{get:t[n],enumerable:!0})},c=(e,t,n,a)=\u003e{if(t\u0026\u0026typeof t==\"object\"||typeof t==\"function\")for(let s of f(t))!j.call(e,s)\u0026\u0026s!==n\u0026\u0026o(e,s,{get:()=\u003et[s],enumerable:!(a=d(t,s))||a.enumerable});return e};var p=(e,t,n)=\u003e(n=e!=null?x(g(e)):{},c(t||!e||!e.__esModule?o(n,\"default\",{value:e,enumerable:!0}):n,e)),D=e=\u003ec(o({},\"__esModule\",{value:!0}),e);var u=l((F,i)=\u003e{i.exports=_jsx_runtime});var C={};_(C,{default:()=\u003ey,frontmatter:()=\u003eM});var r=p(u()),M={title:\"Terrance DeJesus\",description:\"Senior Security Research Engineer, Elastic\",slug:\"terrance-dejesus\"};function m(e){return(0,r.jsx)(r.Fragment,{})}function h(e={}){let{wrapper:t}=e.components||{};return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(m,e)})):m(e)}var y=h;return D(C);})();\n;return Component;"},"_id":"authors/terrance-dejesus.mdx","_raw":{"sourceFilePath":"authors/terrance-dejesus.mdx","sourceFileName":"terrance-dejesus.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/terrance-dejesus"},"type":"Author","imageUrl":"","url":"/authors/terrance-dejesus"}],"category":[{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var l=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),d=(t,e)=\u003e{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!j.call(t,o)\u0026\u0026o!==r\u0026\u0026s(t,o,{get:()=\u003ee[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var h=(t,e,r)=\u003e(r=t!=null?x(g(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),p=t=\u003ec(s({},\"__esModule\",{value:!0}),t);var i=l((X,u)=\u003e{u.exports=_jsx_runtime});var D={};d(D,{default:()=\u003eC,frontmatter:()=\u003ey});var n=h(i()),y={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=M;return p(D);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"entra-id-oauth-phishing-detection"},"buildId":"4A8XvBW8obAxlgMkcFpOB","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>