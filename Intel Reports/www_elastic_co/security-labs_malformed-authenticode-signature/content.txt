<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Investigating a Mysteriously Malformed Authenticode Signature — Elastic Security Labs</title><meta name="description" content="An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines."/><meta property="og:title" content="Investigating a Mysteriously Malformed Authenticode Signature — Elastic Security Labs"/><meta property="og:description" content="An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/malformed-authenticode-signature/malformed-authenticode-signature.png?35edbcd9519bd1c70126ff1f7d63cfe1"/><meta property="og:image:alt" content="An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/malformed-authenticode-signature"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Investigating a Mysteriously Malformed Authenticode Signature — Elastic Security Labs"/><meta name="twitter:description" content="An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/malformed-authenticode-signature/malformed-authenticode-signature.png?35edbcd9519bd1c70126ff1f7d63cfe1"/><meta name="twitter:image:alt" content="An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines."/><link rel="canonical" href="https://www.elastic.co/security-labs/malformed-authenticode-signature"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/8e9860b6e62d6359-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/0ea4f4df910e6120-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/739c2d8941231bb4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/d6767b3d672ed658.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/d6767b3d672ed658.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/fc1dcb1d74b71e18.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/fc1dcb1d74b71e18.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-e159b4ec612933fd.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/352-a63885403f676dc6.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/848-7728ed7430cf686c.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-013a8e3e62f69159.js" defer=""></script><script src="/security-labs/_next/static/chunks/765-d242be8b14c8b8f1.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-48153d1766e2f66b.js" defer=""></script><script src="/security-labs/_next/static/mPJGlO3yOEw6E1EzEho9U/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/mPJGlO3yOEw6E1EzEho9U/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_d672da __variable_ead7f7 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><div class="UtilityHeader_utilityHeader__T_Eto"><div class="UtilityHeader_utilityHeader__container__exgwf"><nav class="UtilityHeader_utilityLinks__ogtQ6"><h2 class="UtilityHeader_utilityHeading__0DExG">Explore Elastic: </h2><ul><li><a href="https://www.elastic.co">elastic.co</a></li><li><a href="https://www.elastic.co/search-labs">Search Labs</a></li><li><a href="https://www.elastic.co/observability-labs">Observability Labs</a></li></ul></nav></div></div><nav class="fixed w-full z-40 top-[29px]" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kq6:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/malformed-authenticode-signature"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/malformed-authenticode-signature"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R5a6:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-09-04T00:00:00.000Z">4 September 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/elastic-security-labs">Elastic Security Labs</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Investigating a Mysteriously Malformed Authenticode&nbsp;Signature</span></h1><p class="text-zinc-200 text-base md:text-xl">Uncovering the hidden heuristics behind malformed authenticode signatures</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>16 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-operations">Security operations</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Investigating a Mysteriously Malformed Authenticode Signature" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fmalformed-authenticode-signature%2Fmalformed-authenticode-signature.png&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>Elastic Security Labs recently encountered a signature validation issue with one of our Windows binaries. The executable was signed using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">signtool.exe</code> as part of our standard continuous integration (CI) process, but on this occasion, the output file failed signature validation with the following error message:</p>
<blockquote>
<p>The digital signature of the object is malformed. For technical detail, see security bulletin MS13-098.</p>
</blockquote>
<p></p>
<p>The <a href="https://learn.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-098">documentation for MS13-098</a> is vague, but it describes a potential vulnerability related to malformed Authenticode signatures. Nothing obvious had changed on our end that might explain this new error, so we needed to investigate the cause and resolve the issue.</p>
<p>While we identified that this issue was affecting one of our signed Windows binaries, it could impact any binary. We are publishing this research as a reference for anyone else who may encounter the same problem in the future.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="diagnosis" class="absolute -top-32"></span>Diagnosis</h2>
<p>To investigate further, we created a basic test program that called the Windows <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">WinVerifyTrust</code> function against the problematic executable to manually validate the signature. This revealed that it was failing with the error code <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TRUST_E_MALFORMED_SIGNATURE</code>.</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">WinVerifyTrust</code> is a complex function, but after attaching a debugger, we discovered that the error code was being set at the following point:</p>
<pre><code>dwReserved1 = psSipSubjectInfo-&gt;dwReserved1;
if(!dwReserved1)
    goto LABEL_58;
v40 = I_GetRelaxedMarkerCheckFlags(a1, v22, (unsigned int *)&amp;pvData);
if(v40 &lt; 0)
    break;
if(!pvData)
    v42 = 0x80096011;    // TRUST_E_MALFORMED_SIGNATURE</code></pre>
<p>As shown above, if <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">psSipSubjectInfo-&gt;dwReserved1</code> is not <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code>, the code calls <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">I_GetRelaxedMarkerCheckFlags</code>. If this function returns no data, the code sets the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">TRUST_E_MALFORMED_SIGNATURE</code> error and exits.</p>
<p>When stepping through the code with our problematic binary, we saw that <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dwReserved1</code> was indeed set to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1</code>. Running the same test against a correctly signed binary, this value was always <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code>, which skips the call to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">I_GetRelaxedMarkerCheckFlags</code>.</p>
<p>Looking into <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">I_GetRelaxedMarkerCheckFlags</code>, we saw that it simply checks for the presence of a specific attribute: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1.3.6.1.4.1.311.2.6.1</code>. A quick online search turned up very little other than the fact that this object identifier (OID) is labeled as <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SpcRelaxedPEMarkerCheck</code>.</p>
<pre><code>__int64 __fastcall I_GetRelaxedMarkerCheckFlags(struct _CRYPT_PROVIDER_DATA *a1, DWORD a2, unsigned int *a3)
{
    unsigned int v4; // ebx
    CRYPT_PROVIDER_SGNR *ProvSignerFromChain; // rax
    PCRYPT_ATTRIBUTE Attribute; // rax
    signed int LastError; // eax
    DWORD pcbStructInfo; // [rsp+60h] [rbp+18h] BYREF

    pcbStructInfo = 4;
    v4 = 0;
    *a3 = 0;
    ProvSignerFromChain = WTHelperGetProvSignerFromChain(a1, a2, 0, 0);
    if(ProvSignerFromChain)
    {
        Attribute = CertFindAttribute(
            &quot;1.3.6.1.4.1.311.2.6.1&quot;,
            ProvSignerFromChain-&gt;psSigner-&gt;AuthAttrs.cAttr,
            ProvSignerFromChain-&gt;psSigner-&gt;AuthAttrs.rgAttr);
        if(Attribute)
        {
            if(!CryptDecodeObject(
                a1-&gt;dwEncoding,
                (LPCSTR)0x1B,
                Attribute-&gt;rgValue-&gt;pbData,
                Attribute-&gt;rgValue-&gt;cbData,
                0,
                a3,
                &amp;pcbStructInfo))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    return v4;
}</code></pre>
<p>Our binary did not have this attribute, which caused the function to return no data and triggered the error. The function names reminded us of an optional parameter that we had previously seen in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">signtool.exe</code>:</p>
<blockquote>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/rmc</code> - Specifies signing a PE file with the relaxed marker check semantic. The flag is ignored for non-PE files. During verification, certain authenticated sections of the signature will bypass invalid PE markers check. This option should only be used after careful consideration and reviewing the details of MSRC case MS12-024 to ensure that no vulnerabilities are introduced.</p>
</blockquote>
<p>Based on our analysis, we suspected that re-signing the executable with the “relaxed marker check” flag (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/rmc</code>), and as expected, the signature was now valid.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="root-cause-analysis" class="absolute -top-32"></span>Root cause analysis</h3>
<p>While the workaround above resolved our immediate problem, it clearly wasn’t the root cause. We needed to investigate further to understand why the internal <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dwReserved1</code> flag was set in the first place.</p>
<p>This field is part of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SIP_SUBJECTINFO</code> structure, which is <a href="https://learn.microsoft.com/en-us/windows/win32/api/mssip/ns-mssip-sip_subjectinfo">documented on MSDN</a> - but unfortunately, it didn’t help much in this case:</p>
<p></p>
<p>To find where this field was being set, we worked backwards and identified a point where <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dwReserved1</code> was still <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code> - i.e., before the flag had been set. We placed a hardware breakpoint (on write) on the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dwReserved1</code> field and resumed execution. The breakpoint was hit in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">SIPObjectPE_::GetMessageFromFile</code> function:</p>
<pre><code>__int64 __fastcall SIPObjectPE_::GetMessageFromFile(
    SIPObjectPE_ *this,
    struct SIP_SUBJECTINFO_ *a2,
    struct _WIN_CERTIFICATE *a3,
    unsigned int a4,
    unsigned int *a5)
{
    __int64 v5; // rcx
    __int64 result; // rax
    DWORD v8; // [rsp+40h] [rbp+8h] BYREF

    v5 = *((_QWORD*)this + 1);
    v8 = 0;
    result = ImageGetCertificateDataEx(v5, a4, a3, a5, &amp;v8);
    if((_DWORD)result)
        a2-&gt;dwReserved1 = v8;

    return result;
}</code></pre>
<p>This function calls the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ImageGetCertificateDataEx</code> API which is exported by <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">imagehlp.dll</code>. The value returned by the fifth parameter of this function is stored in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">dwReserved1</code>. This value ultimately determines whether the PE is considered &quot;malformed&quot; in the manner we have been observing.</p>
<p>Unfortunately, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ImageGetCertificateDataEx</code> is undocumented on MSDN. However, an earlier variant, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ImageGetCertificateData</code>, <a href="https://learn.microsoft.com/en-us/windows/win32/api/imagehlp/nf-imagehlp-imagegetcertificatedata">is documented</a>:</p>
<pre><code>BOOL IMAGEAPI ImageGetCertificateData(
  [in]      HANDLE            FileHandle,
  [in]      DWORD             CertificateIndex,
  [out]     LPWIN_CERTIFICATE Certificate,
  [in, out] PDWORD            RequiredLength
);</code></pre>
<p>This function extracts the contents of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">IMAGE_DIRECTORY_ENTRY_SECURITY</code> directory from the PE headers. Manual analysis of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ImageGetCertificateDataEx</code> function showed that the first four parameters match those of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ImageGetCertificateData</code>, but with one additional output parameter at the end.</p>
<p>We wrote a simple test program that allows us to call this function and perform checks against the unknown fifth parameter:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;imagehlp.h&gt;

int main()
{
    HANDLE hFile = NULL;
    DWORD dwCertLength = 0;
    WIN_CERTIFICATE *pCertData = NULL;
    DWORD dwUnknown = 0;
    BOOL (WINAPI *pImageGetCertificateDataEx)(HANDLE FileHandle, DWORD CertificateIndex, LPWIN_CERTIFICATE Certificate, PDWORD RequiredLength, DWORD *pdwUnknown);

    // open target executable
    hFile = CreateFileA(&quot;C:\\users\\matthew\\sample-executable.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        printf(&quot;Failed to open input file\n&quot;);
        return 1;
    }

    // locate ImageGetCertificateDataEx export in imagehlp.dll
    pImageGetCertificateDataEx = (BOOL(WINAPI*)(HANDLE,DWORD,LPWIN_CERTIFICATE,PDWORD,DWORD*))GetProcAddress(LoadLibraryA(&quot;imagehlp.dll&quot;), &quot;ImageGetCertificateDataEx&quot;);
    if(pImageGetCertificateDataEx == NULL)
    {
        printf(&quot;Failed to locate ImageGetCertificateDataEx\n&quot;);
        return 1;
    }

    // get required length
    dwCertLength = 0;
    if(pImageGetCertificateDataEx(hFile, 0, NULL, &amp;dwCertLength, &amp;dwUnknown) == 0)
    {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            printf(&quot;ImageGetCertificateDataEx error (1)\n&quot;);
            return 1;
        }
    }

    // allocate data
    printf(&quot;Allocating %u bytes for certificate...\n&quot;, dwCertLength);
    pCertData = (WIN_CERTIFICATE*)malloc(dwCertLength);
    if(pCertData == NULL)
    {
        printf(&quot;Failed to allocate memory\n&quot;);
        return 1;
    }

    // read certificate data and dwUnknown flag
    if(pImageGetCertificateDataEx(hFile, 0, pCertData, &amp;dwCertLength, &amp;dwUnknown) == 0)
    {
        printf(&quot;ImageGetCertificateDataEx error (2)\n&quot;);
        return 1;
    }

    printf(&quot;Finished - dwUnknown: %u\n&quot;, dwUnknown);

    return 0;
}</code></pre>
<p>Running this against a variety of executables confirmed our expectations: the unknown return value was <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1</code> for our “broken” executable, and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0</code> for correctly signed binaries. This confirmed that the issue originated somewhere within the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ImageGetCertificateDataEx</code> function.</p>
<p>Further analysis of this function revealed that the unknown flag is being set by another internal function: <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">IsBufferCleanOfInvalidMarkers</code>.</p>
<pre><code>...
if(!IsBufferCleanOfInvalidMarkers(v25, v15, pdwUnknown))
{
    LastError = GetLastError();
    if(!pdwUnknown)
        goto LABEL_34;
}
...</code></pre>
<p>After cleaning up the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">IsBufferCleanOfInvalidMarkers</code> function, we observed the following:</p>
<pre><code>DWORD IsBufferCleanOfInvalidMarkers(BYTE *pData, DWORD dwLength, DWORD *pdwInvalidMarkerFound)
{
    if(!_InterlockedCompareExchange64(&amp;global_InvalidMarkerList, 0, 0))
        LoadInvalidMarkers();

    if(!RabinKarpFindPatternInBuffer(pData, dwLength, pdwInvalidMarkerFound))
        return 1;

    SetLastError(0x80096011); // TRUST_E_MALFORMED_SIGNATURE

    return 0;
}</code></pre>
<p>This function loads a global list of &quot;invalid markers&quot; using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">LoadInvalidMarkers</code>, if they are not already loaded. <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">imagehlp.dll</code> contains a hardcoded default list of markers, but also checks the registry for a user-defined list at the following path:</p>
<p><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\Wintrust\Config\PECertInvalidMarkers</code></p>
<p>This registry value does not appear to exist by default.</p>
<p>The function then performs a search across the entire PE signature data, looking for any of these markers. If a match is found, <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pdwInvalidMarkerFound</code> is set to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">1</code>, which maps directly to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">psSipSubjectInfo-&gt;dwReserved1</code> value mentioned earlier.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="dumping-the-invalid-markers" class="absolute -top-32"></span>Dumping the invalid markers</h3>
<p>The markers are stored in an undocumented structure inside <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">imagehlp.dll</code>. After reverse-engineering the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">RabinKarpFindPatternInBuffer</code> function noted above, we wrote a small tool to dump the entire list of markers:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main()
{
    HMODULE hModule = LoadLibraryA(&quot;imagehlp.dll&quot;);

    // hardcoded address - imagehlp.dll version:
    // 509ef25f9bac59ebf1c19ec141cb882e5c1a8cb61ac74a10a9f2bd43ed1f0585
    BYTE *pInvalidMarkerData = (BYTE*)hModule + 0xC4D8;

    BYTE *pEntryList = (BYTE*)*(DWORD64*)(pInvalidMarkerData + 20);
    DWORD dwEntryCount = *(DWORD*)pInvalidMarkerData;
    for(DWORD i = 0; i &lt; dwEntryCount; i++)
    {
        BYTE *pCurrEntry = pEntryList + (i * 18);
        BYTE bLength = *(BYTE*)(pCurrEntry + 9);
        BYTE *pString = (BYTE*)*(DWORD64*)(pCurrEntry + 10);
        for(DWORD ii = 0; ii &lt; bLength; ii++)
        {
            if(isprint(pString[ii]))
            {
                // printable character
                printf(&quot;%c&quot;, pString[ii]);
            }
            else
            {
                // non-printable character
                printf(&quot;\\x%02X&quot;, pString[ii]);
            }
        }
        printf(&quot;\n&quot;);
    }

    return 0;
}</code></pre>
<p>This produced the following results:</p>
<pre><code>PK\x01\x02
PK\x05\x06
PK\x03\x04
PK\x07\x08
Rar!\x1A\x07\x00
z\xBC\xAF&#x27;\x1C
**ACE**
!&lt;arch&gt;\x0A
MSCF\x00\x00\x00\x00
\xEF\xBE\xAD\xDENull
Initializing Wise Installation Wizard
zlb\x1A
KGB_arch
KGB2\x00
KGB2\x01
ENC\x00
disk%i.pak
&gt;-\x1C\x0BxV4\x12
ISc(
Smart Install Maker
\xAE\x01NanoZip
;!@Install@
EGGA
ArC\x01
StuffIt!
-sqx-
PK\x09\x0A
&quot;\x0B\x01\x0B
-lh0-
-lh1-
-lh2-
-lh3-
-lh4-
-lh5-
-lh6-
-lh7-
-lh8-
-lh9-
-lha-
-lhb-
-lhc-
-lhd-
-lhe-
-lzs-
-lz2-
-lz3-
-lz4-
-lz5-
-lz7-
-lz8-
&lt;#$@@$#&gt;</code></pre>
<p>As expected, this appears to be a list of magic values pertaining to old installers and compressed archive formats. This aligns with the description of <a href="https://learn.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-098">MS13-098</a>, which hints towards certain installers being affected.</p>
<p>We suspected this was related to self-extracting executables. If an executable reads itself from disk and scans its own data for an embedded archive (e.g., a ZIP file), an attacker could potentially append malicious data to the signature section without invalidating the signature - since signature data cannot hash itself. This could potentially cause the vulnerable executable to locate the malicious data before the original data, especially if it scans backwards from the end of the file.</p>
<p>We later found an old <a href="https://recon.cx/2012/schedule/events/246.en.html">RECon talk from 2012 by Igor Glücksmann</a>, which describes this exact scenario and appears to confirm our hypothesis.</p>
<p>Microsoft&#x27;s fix involved scanning the PE signature block for known byte patterns that could indicate this type of abuse.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="investigating-the-false-positive" class="absolute -top-32"></span>Investigating the false positive</h3>
<p>Upon further debugging, we discovered that the binary was being flagged due to the signature data containing the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">EGGA</code> marker from the list above:</p>
<p></p>
<p>In the context of the list of markers above, the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">EGGA</code> signature appears to relate to a specific header value used by an archive format called <a href="http://justsolve.archiveteam.org/wiki/EGG_(ALZip)">ALZip</a>. Our code does not make any use of this file format.</p>
<p>Microsoft’s heuristic treated the presence of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">EGGA</code> as evidence that malicious archive data had been embedded in the PE signature. In practice, nothing of the sort was present. The signature block itself happened to include those four bytes as part of the hashed data.</p>
<p>Collisions like this are unusual, but page hashing (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/ph</code>) made it more likely. By expanding the size of the signature block, page hashing increases the surface area for coincidental matches and increases the likelihood of triggering the heuristic.</p>
<p>The binary didn’t contain any self-extracting routines, so the hit on <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">EGGA</code> was a false positive. In that context, the warning had no bearing on the file’s integrity. This meant it was safe to re-sign the file with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/rmc</code> to restore the expected validation.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h3>
<p>It is well known that additional data can be embedded in a PE file without breaking its signature by appending it to the security block. Even some <a href="https://learn.microsoft.com/en-us/archive/blogs/ieinternals/caveats-for-authenticode-code-signing">legitimate software products</a> take advantage of this to embed user-specific metadata into signed executables. However, we were not aware that Microsoft had implemented heuristics to detect specific malicious cases of this, even though they were introduced back in 2012.</p>
<p>The original error message was very vague, and we were unable to find any documentation or references online that helped explain the behavior. Even searching for the associated registry value after discovering it (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">PECertInvalidMarkers</code>) yielded zero results.</p>
<p>What we uncovered is that Microsoft added heuristic scanning of signature blocks more than a decade ago to counter specific abuse cases. Those heuristics reside in a hardcoded list of “invalid markers,” many of which are tied to outdated installers and archive formats. Our binary happened to collide with one of those markers when signed with page hashing enabled, creating a validation failure with no clear documentation and no public references to the underlying registry key or detection logic.</p>
<p>The absence of online discussions regarding this failure mode, aside from a single unresolved <a href="https://developercommunity.visualstudio.com/t/malformed-digital-signature-ms13-098-1/235599">Visual Studio Developer Community post from 2018</a>, made the initial diagnosis difficult. By publishing this analysis, we want to provide a technical reference point for others who may encounter the same problem. In our case, resolving the issue required deep troubleshooting that few outside this space would normally need to exercise. For teams automating code signing, the key lesson is to integrate signature validation checks early and be aware that heuristic marker detection can lead to edge-case failures.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="additional-references" class="absolute -top-32"></span>Additional references</h2>
<p>The author can be found on X at <a href="https://x.com/x86matthew">@x86matthew.</a></p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/malformed-authenticode-signature#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/malformed-authenticode-signature#diagnosis"><span>Diagnosis</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/malformed-authenticode-signature#root-cause-analysis"><span>Root cause&nbsp;analysis</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/malformed-authenticode-signature#dumping-the-invalid-markers"><span>Dumping the invalid&nbsp;markers</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/malformed-authenticode-signature#investigating-the-false-positive"><span>Investigating the false&nbsp;positive</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/malformed-authenticode-signature#conclusion"><span>Conclusion</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/malformed-authenticode-signature#additional-references"><span>Additional&nbsp;references</span></a></li></ul></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Investigating a Mysteriously Malformed Authenticode Signature&amp;url=https://www.elastic.co/security-labs/malformed-authenticode-signature" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Twitter" title="Share this article on Twitter"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>Twitter</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/malformed-authenticode-signature" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/malformed-authenticode-signature&amp;title=Investigating a Mysteriously Malformed Authenticode Signature" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/malformed-authenticode-signature&amp;title=Investigating a Mysteriously Malformed Authenticode Signature" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"Investigating a Mysteriously Malformed Authenticode Signature","slug":"malformed-authenticode-signature","date":"2025-09-04","description":"An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines.","image":"malformed-authenticode-signature.png","subtitle":"Uncovering the hidden heuristics behind malformed authenticode signatures","tags":["ms13-098","Windows kernel"],"body":{"raw":"\n## Introduction\n\nElastic Security Labs recently encountered a signature validation issue with one of our Windows binaries. The executable was signed using `signtool.exe` as part of our standard continuous integration (CI) process, but on this occasion, the output file failed signature validation with the following error message:\n\n\u003e The digital signature of the object is malformed. For technical detail, see security bulletin MS13-098.\n\n![MS13-098 error](/assets/images/malformed-authenticode-signature/image2.png \"MS13-098 error\")\n\nThe [documentation for MS13-098](https://learn.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-098) is vague, but it describes a potential vulnerability related to malformed Authenticode signatures. Nothing obvious had changed on our end that might explain this new error, so we needed to investigate the cause and resolve the issue.\n\nWhile we identified that this issue was affecting one of our signed Windows binaries, it could impact any binary. We are publishing this research as a reference for anyone else who may encounter the same problem in the future.\n\n## Diagnosis\n\nTo investigate further, we created a basic test program that called the Windows `WinVerifyTrust` function against the problematic executable to manually validate the signature. This revealed that it was failing with the error code `TRUST_E_MALFORMED_SIGNATURE`.\n\n`WinVerifyTrust` is a complex function, but after attaching a debugger, we discovered that the error code was being set at the following point:\n\n```c\ndwReserved1 = psSipSubjectInfo-\u003edwReserved1;\nif(!dwReserved1)\n    goto LABEL_58;\nv40 = I_GetRelaxedMarkerCheckFlags(a1, v22, (unsigned int *)\u0026pvData);\nif(v40 \u003c 0)\n    break;\nif(!pvData)\n    v42 = 0x80096011;    // TRUST_E_MALFORMED_SIGNATURE\n```\n\nAs shown above, if `psSipSubjectInfo-\u003edwReserved1` is not `0`, the code calls `I_GetRelaxedMarkerCheckFlags`. If this function returns no data, the code sets the `TRUST_E_MALFORMED_SIGNATURE` error and exits.\n\nWhen stepping through the code with our problematic binary, we saw that `dwReserved1` was indeed set to `1`. Running the same test against a correctly signed binary, this value was always `0`, which skips the call to `I_GetRelaxedMarkerCheckFlags`.\n\nLooking into `I_GetRelaxedMarkerCheckFlags`, we saw that it simply checks for the presence of a specific attribute: `1.3.6.1.4.1.311.2.6.1`. A quick online search turned up very little other than the fact that this object identifier (OID) is labeled as `SpcRelaxedPEMarkerCheck`.\n\n```c\n__int64 __fastcall I_GetRelaxedMarkerCheckFlags(struct _CRYPT_PROVIDER_DATA *a1, DWORD a2, unsigned int *a3)\n{\n    unsigned int v4; // ebx\n    CRYPT_PROVIDER_SGNR *ProvSignerFromChain; // rax\n    PCRYPT_ATTRIBUTE Attribute; // rax\n    signed int LastError; // eax\n    DWORD pcbStructInfo; // [rsp+60h] [rbp+18h] BYREF\n\n    pcbStructInfo = 4;\n    v4 = 0;\n    *a3 = 0;\n    ProvSignerFromChain = WTHelperGetProvSignerFromChain(a1, a2, 0, 0);\n    if(ProvSignerFromChain)\n    {\n        Attribute = CertFindAttribute(\n            \"1.3.6.1.4.1.311.2.6.1\",\n            ProvSignerFromChain-\u003epsSigner-\u003eAuthAttrs.cAttr,\n            ProvSignerFromChain-\u003epsSigner-\u003eAuthAttrs.rgAttr);\n        if(Attribute)\n        {\n            if(!CryptDecodeObject(\n                a1-\u003edwEncoding,\n                (LPCSTR)0x1B,\n                Attribute-\u003ergValue-\u003epbData,\n                Attribute-\u003ergValue-\u003ecbData,\n                0,\n                a3,\n                \u0026pcbStructInfo))\n            {\n                return HRESULT_FROM_WIN32(GetLastError());\n            }\n        }\n    }\n\n    return v4;\n}\n```\n\nOur binary did not have this attribute, which caused the function to return no data and triggered the error. The function names reminded us of an optional parameter that we had previously seen in `signtool.exe`:\n\n\u003e `/rmc` - Specifies signing a PE file with the relaxed marker check semantic. The flag is ignored for non-PE files. During verification, certain authenticated sections of the signature will bypass invalid PE markers check. This option should only be used after careful consideration and reviewing the details of MSRC case MS12-024 to ensure that no vulnerabilities are introduced.\n\nBased on our analysis, we suspected that re-signing the executable with the “relaxed marker check” flag (`/rmc`), and as expected, the signature was now valid.\n\n### Root cause analysis\n\nWhile the workaround above resolved our immediate problem, it clearly wasn’t the root cause. We needed to investigate further to understand why the internal `dwReserved1` flag was set in the first place.\n\nThis field is part of the `SIP_SUBJECTINFO` structure, which is [documented on MSDN](https://learn.microsoft.com/en-us/windows/win32/api/mssip/ns-mssip-sip_subjectinfo) - but unfortunately, it didn’t help much in this case:\n\n![SIP_SUBJECTINFO structure comment](/assets/images/malformed-authenticode-signature/image3.png \"SIP_SUBJECTINFO structure comment\")\n\nTo find where this field was being set, we worked backwards and identified a point where `dwReserved1` was still `0` - i.e., before the flag had been set. We placed a hardware breakpoint (on write) on the `dwReserved1` field and resumed execution. The breakpoint was hit in the `SIPObjectPE_::GetMessageFromFile` function:\n\n```c\n__int64 __fastcall SIPObjectPE_::GetMessageFromFile(\n    SIPObjectPE_ *this,\n    struct SIP_SUBJECTINFO_ *a2,\n    struct _WIN_CERTIFICATE *a3,\n    unsigned int a4,\n    unsigned int *a5)\n{\n    __int64 v5; // rcx\n    __int64 result; // rax\n    DWORD v8; // [rsp+40h] [rbp+8h] BYREF\n\n    v5 = *((_QWORD*)this + 1);\n    v8 = 0;\n    result = ImageGetCertificateDataEx(v5, a4, a3, a5, \u0026v8);\n    if((_DWORD)result)\n        a2-\u003edwReserved1 = v8;\n\n    return result;\n}\n```\n\nThis function calls the `ImageGetCertificateDataEx` API which is exported by `imagehlp.dll`. The value returned by the fifth parameter of this function is stored in `dwReserved1`. This value ultimately determines whether the PE is considered \"malformed\" in the manner we have been observing.\n\nUnfortunately, `ImageGetCertificateDataEx` is undocumented on MSDN. However, an earlier variant, `ImageGetCertificateData`, [is documented](https://learn.microsoft.com/en-us/windows/win32/api/imagehlp/nf-imagehlp-imagegetcertificatedata):\n\n```c\nBOOL IMAGEAPI ImageGetCertificateData(\n  [in]      HANDLE            FileHandle,\n  [in]      DWORD             CertificateIndex,\n  [out]     LPWIN_CERTIFICATE Certificate,\n  [in, out] PDWORD            RequiredLength\n);\n```\n\nThis function extracts the contents of the `IMAGE_DIRECTORY_ENTRY_SECURITY` directory from the PE headers. Manual analysis of the `ImageGetCertificateDataEx` function showed that the first four parameters match those of `ImageGetCertificateData`, but with one additional output parameter at the end.\n\nWe wrote a simple test program that allows us to call this function and perform checks against the unknown fifth parameter:\n\n```c\n#include \u003cstdio.h\u003e\n#include \u003cwindows.h\u003e\n#include \u003cimagehlp.h\u003e\n\nint main()\n{\n    HANDLE hFile = NULL;\n    DWORD dwCertLength = 0;\n    WIN_CERTIFICATE *pCertData = NULL;\n    DWORD dwUnknown = 0;\n    BOOL (WINAPI *pImageGetCertificateDataEx)(HANDLE FileHandle, DWORD CertificateIndex, LPWIN_CERTIFICATE Certificate, PDWORD RequiredLength, DWORD *pdwUnknown);\n\n    // open target executable\n    hFile = CreateFileA(\"C:\\\\users\\\\matthew\\\\sample-executable.exe\", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n    if(hFile == INVALID_HANDLE_VALUE)\n    {\n        printf(\"Failed to open input file\\n\");\n        return 1;\n    }\n\n    // locate ImageGetCertificateDataEx export in imagehlp.dll\n    pImageGetCertificateDataEx = (BOOL(WINAPI*)(HANDLE,DWORD,LPWIN_CERTIFICATE,PDWORD,DWORD*))GetProcAddress(LoadLibraryA(\"imagehlp.dll\"), \"ImageGetCertificateDataEx\");\n    if(pImageGetCertificateDataEx == NULL)\n    {\n        printf(\"Failed to locate ImageGetCertificateDataEx\\n\");\n        return 1;\n    }\n\n    // get required length\n    dwCertLength = 0;\n    if(pImageGetCertificateDataEx(hFile, 0, NULL, \u0026dwCertLength, \u0026dwUnknown) == 0)\n    {\n        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n        {\n            printf(\"ImageGetCertificateDataEx error (1)\\n\");\n            return 1;\n        }\n    }\n\n    // allocate data\n    printf(\"Allocating %u bytes for certificate...\\n\", dwCertLength);\n    pCertData = (WIN_CERTIFICATE*)malloc(dwCertLength);\n    if(pCertData == NULL)\n    {\n        printf(\"Failed to allocate memory\\n\");\n        return 1;\n    }\n\n    // read certificate data and dwUnknown flag\n    if(pImageGetCertificateDataEx(hFile, 0, pCertData, \u0026dwCertLength, \u0026dwUnknown) == 0)\n    {\n        printf(\"ImageGetCertificateDataEx error (2)\\n\");\n        return 1;\n    }\n\n    printf(\"Finished - dwUnknown: %u\\n\", dwUnknown);\n\n    return 0;\n}\n```\n\nRunning this against a variety of executables confirmed our expectations: the unknown return value was `1` for our “broken” executable, and `0` for correctly signed binaries. This confirmed that the issue originated somewhere within the `ImageGetCertificateDataEx` function.\n\nFurther analysis of this function revealed that the unknown flag is being set by another internal function: `IsBufferCleanOfInvalidMarkers`.\n\n```c\n...\nif(!IsBufferCleanOfInvalidMarkers(v25, v15, pdwUnknown))\n{\n    LastError = GetLastError();\n    if(!pdwUnknown)\n        goto LABEL_34;\n}\n...\n```\n\nAfter cleaning up the `IsBufferCleanOfInvalidMarkers` function, we observed the following:\n\n```c\nDWORD IsBufferCleanOfInvalidMarkers(BYTE *pData, DWORD dwLength, DWORD *pdwInvalidMarkerFound)\n{\n    if(!_InterlockedCompareExchange64(\u0026global_InvalidMarkerList, 0, 0))\n        LoadInvalidMarkers();\n\n    if(!RabinKarpFindPatternInBuffer(pData, dwLength, pdwInvalidMarkerFound))\n        return 1;\n\n    SetLastError(0x80096011); // TRUST_E_MALFORMED_SIGNATURE\n\n    return 0;\n}\n```\n\nThis function loads a global list of \"invalid markers\" using `LoadInvalidMarkers`, if they are not already loaded. `imagehlp.dll` contains a hardcoded default list of markers, but also checks the registry for a user-defined list at the following path: \n\n`HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\Wintrust\\Config\\PECertInvalidMarkers`\n\nThis registry value does not appear to exist by default.\n\nThe function then performs a search across the entire PE signature data, looking for any of these markers. If a match is found, `pdwInvalidMarkerFound` is set to `1`, which maps directly to the `psSipSubjectInfo-\u003edwReserved1` value mentioned earlier.\n\n### Dumping the invalid markers\n\nThe markers are stored in an undocumented structure inside `imagehlp.dll`. After reverse-engineering the `RabinKarpFindPatternInBuffer` function noted above, we wrote a small tool to dump the entire list of markers:\n\n```c\n#include \u003cstdio.h\u003e\n#include \u003cwindows.h\u003e\n\nint main()\n{\n    HMODULE hModule = LoadLibraryA(\"imagehlp.dll\");\n\n    // hardcoded address - imagehlp.dll version:\n    // 509ef25f9bac59ebf1c19ec141cb882e5c1a8cb61ac74a10a9f2bd43ed1f0585\n    BYTE *pInvalidMarkerData = (BYTE*)hModule + 0xC4D8;\n\n    BYTE *pEntryList = (BYTE*)*(DWORD64*)(pInvalidMarkerData + 20);\n    DWORD dwEntryCount = *(DWORD*)pInvalidMarkerData;\n    for(DWORD i = 0; i \u003c dwEntryCount; i++)\n    {\n        BYTE *pCurrEntry = pEntryList + (i * 18);\n        BYTE bLength = *(BYTE*)(pCurrEntry + 9);\n        BYTE *pString = (BYTE*)*(DWORD64*)(pCurrEntry + 10);\n        for(DWORD ii = 0; ii \u003c bLength; ii++)\n        {\n            if(isprint(pString[ii]))\n            {\n                // printable character\n                printf(\"%c\", pString[ii]);\n            }\n            else\n            {\n                // non-printable character\n                printf(\"\\\\x%02X\", pString[ii]);\n            }\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n```\n\nThis produced the following results:\n\n```\nPK\\x01\\x02\nPK\\x05\\x06\nPK\\x03\\x04\nPK\\x07\\x08\nRar!\\x1A\\x07\\x00\nz\\xBC\\xAF'\\x1C\n**ACE**\n!\u003carch\u003e\\x0A\nMSCF\\x00\\x00\\x00\\x00\n\\xEF\\xBE\\xAD\\xDENull\nInitializing Wise Installation Wizard\nzlb\\x1A\nKGB_arch\nKGB2\\x00\nKGB2\\x01\nENC\\x00\ndisk%i.pak\n\u003e-\\x1C\\x0BxV4\\x12\nISc(\nSmart Install Maker\n\\xAE\\x01NanoZip\n;!@Install@\nEGGA\nArC\\x01\nStuffIt!\n-sqx-\nPK\\x09\\x0A\n\"\\x0B\\x01\\x0B\n-lh0-\n-lh1-\n-lh2-\n-lh3-\n-lh4-\n-lh5-\n-lh6-\n-lh7-\n-lh8-\n-lh9-\n-lha-\n-lhb-\n-lhc-\n-lhd-\n-lhe-\n-lzs-\n-lz2-\n-lz3-\n-lz4-\n-lz5-\n-lz7-\n-lz8-\n\u003c#$@@$#\u003e\n```\n\nAs expected, this appears to be a list of magic values pertaining to old installers and compressed archive formats. This aligns with the description of [MS13-098](https://learn.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-098), which hints towards certain installers being affected.\n\nWe suspected this was related to self-extracting executables. If an executable reads itself from disk and scans its own data for an embedded archive (e.g., a ZIP file), an attacker could potentially append malicious data to the signature section without invalidating the signature \\- since signature data cannot hash itself. This could potentially cause the vulnerable executable to locate the malicious data before the original data, especially if it scans backwards from the end of the file.\n\nWe later found an old [RECon talk from 2012 by Igor Glücksmann](https://recon.cx/2012/schedule/events/246.en.html), which describes this exact scenario and appears to confirm our hypothesis.\n\nMicrosoft's fix involved scanning the PE signature block for known byte patterns that could indicate this type of abuse.\n\n### Investigating the false positive\n\nUpon further debugging, we discovered that the binary was being flagged due to the signature data containing the `EGGA` marker from the list above:\n\n![EGGA marker](/assets/images/malformed-authenticode-signature/image1.png \"EGGA marker\")\n\nIn the context of the list of markers above, the `EGGA` signature appears to relate to a specific header value used by an archive format called [ALZip](http://justsolve.archiveteam.org/wiki/EGG_\\(ALZip\\)). Our code does not make any use of this file format.\n\nMicrosoft’s heuristic treated the presence of `EGGA` as evidence that malicious archive data had been embedded in the PE signature. In practice, nothing of the sort was present. The signature block itself happened to include those four bytes as part of the hashed data.\n\nCollisions like this are unusual, but page hashing (`/ph`) made it more likely. By expanding the size of the signature block, page hashing increases the surface area for coincidental matches and increases the likelihood of triggering the heuristic.\n\nThe binary didn’t contain any self-extracting routines, so the hit on `EGGA` was a false positive. In that context, the warning had no bearing on the file’s integrity. This meant it was safe to re-sign the file with `/rmc` to restore the expected validation.\n\n### Conclusion\n\nIt is well known that additional data can be embedded in a PE file without breaking its signature by appending it to the security block. Even some [legitimate software products](https://learn.microsoft.com/en-us/archive/blogs/ieinternals/caveats-for-authenticode-code-signing) take advantage of this to embed user-specific metadata into signed executables. However, we were not aware that Microsoft had implemented heuristics to detect specific malicious cases of this, even though they were introduced back in 2012\\.\n\nThe original error message was very vague, and we were unable to find any documentation or references online that helped explain the behavior. Even searching for the associated registry value after discovering it (`PECertInvalidMarkers`) yielded zero results.\n\nWhat we uncovered is that Microsoft added heuristic scanning of signature blocks more than a decade ago to counter specific abuse cases. Those heuristics reside in a hardcoded list of “invalid markers,” many of which are tied to outdated installers and archive formats. Our binary happened to collide with one of those markers when signed with page hashing enabled, creating a validation failure with no clear documentation and no public references to the underlying registry key or detection logic.\n\nThe absence of online discussions regarding this failure mode, aside from a single unresolved [Visual Studio Developer Community post from 2018](https://developercommunity.visualstudio.com/t/malformed-digital-signature-ms13-098-1/235599), made the initial diagnosis difficult. By publishing this analysis, we want to provide a technical reference point for others who may encounter the same problem. In our case, resolving the issue required deep troubleshooting that few outside this space would normally need to exercise. For teams automating code signing, the key lesson is to integrate signature validation checks early and be aware that heuristic marker detection can lead to edge-case failures. \n\n## Additional references\n\nThe author can be found on X at [@x86matthew.](https://x.com/x86matthew)","code":"var Component=(()=\u003e{var u=Object.create;var r=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var w=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=\u003e{for(var i in e)r(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of g(e))!m.call(t,a)\u0026\u0026a!==i\u0026\u0026r(t,a,{get:()=\u003ee[a],enumerable:!(o=f(e,a))||o.enumerable});return t};var v=(t,e,i)=\u003e(i=t!=null?u(p(t)):{},s(e||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),E=t=\u003es(r({},\"__esModule\",{value:!0}),t);var c=w((k,d)=\u003e{d.exports=_jsx_runtime});var x={};b(x,{default:()=\u003eh,frontmatter:()=\u003eI});var n=v(c()),I={title:\"Investigating a Mysteriously Malformed Authenticode Signature\",slug:\"malformed-authenticode-signature\",date:\"2025-09-04\",subtitle:\"Uncovering the hidden heuristics behind malformed authenticode signatures\",description:\"An in-depth investigation tracing a Windows Authenticode validation failure from vague error codes to undocumented kernel routines.\",author:[{slug:\"elastic-security-labs\"}],image:\"malformed-authenticode-signature.png\",category:[{slug:\"security-operations\"}],tags:[\"ms13-098\",\"Windows kernel\"]};function l(t){let e={a:\"a\",blockquote:\"blockquote\",code:\"code\",h2:\"h2\",h3:\"h3\",img:\"img\",p:\"p\",pre:\"pre\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Elastic Security Labs recently encountered a signature validation issue with one of our Windows binaries. The executable was signed using \",(0,n.jsx)(e.code,{children:\"signtool.exe\"}),\" as part of our standard continuous integration (CI) process, but on this occasion, the output file failed signature validation with the following error message:\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The digital signature of the object is malformed. For technical detail, see security bulletin MS13-098.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/malformed-authenticode-signature/image2.png\",alt:\"MS13-098 error\",title:\"MS13-098 error\",width:\"395\",height:\"123\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-098\",rel:\"nofollow\",children:\"documentation for MS13-098\"}),\" is vague, but it describes a potential vulnerability related to malformed Authenticode signatures. Nothing obvious had changed on our end that might explain this new error, so we needed to investigate the cause and resolve the issue.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"While we identified that this issue was affecting one of our signed Windows binaries, it could impact any binary. We are publishing this research as a reference for anyone else who may encounter the same problem in the future.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"diagnosis\",children:\"Diagnosis\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To investigate further, we created a basic test program that called the Windows \",(0,n.jsx)(e.code,{children:\"WinVerifyTrust\"}),\" function against the problematic executable to manually validate the signature. This revealed that it was failing with the error code \",(0,n.jsx)(e.code,{children:\"TRUST_E_MALFORMED_SIGNATURE\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"WinVerifyTrust\"}),\" is a complex function, but after attaching a debugger, we discovered that the error code was being set at the following point:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`dwReserved1 = psSipSubjectInfo-\u003edwReserved1;\nif(!dwReserved1)\n    goto LABEL_58;\nv40 = I_GetRelaxedMarkerCheckFlags(a1, v22, (unsigned int *)\u0026pvData);\nif(v40 \u003c 0)\n    break;\nif(!pvData)\n    v42 = 0x80096011;    // TRUST_E_MALFORMED_SIGNATURE\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As shown above, if \",(0,n.jsx)(e.code,{children:\"psSipSubjectInfo-\u003edwReserved1\"}),\" is not \",(0,n.jsx)(e.code,{children:\"0\"}),\", the code calls \",(0,n.jsx)(e.code,{children:\"I_GetRelaxedMarkerCheckFlags\"}),\". If this function returns no data, the code sets the \",(0,n.jsx)(e.code,{children:\"TRUST_E_MALFORMED_SIGNATURE\"}),\" error and exits.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"When stepping through the code with our problematic binary, we saw that \",(0,n.jsx)(e.code,{children:\"dwReserved1\"}),\" was indeed set to \",(0,n.jsx)(e.code,{children:\"1\"}),\". Running the same test against a correctly signed binary, this value was always \",(0,n.jsx)(e.code,{children:\"0\"}),\", which skips the call to \",(0,n.jsx)(e.code,{children:\"I_GetRelaxedMarkerCheckFlags\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Looking into \",(0,n.jsx)(e.code,{children:\"I_GetRelaxedMarkerCheckFlags\"}),\", we saw that it simply checks for the presence of a specific attribute: \",(0,n.jsx)(e.code,{children:\"1.3.6.1.4.1.311.2.6.1\"}),\". A quick online search turned up very little other than the fact that this object identifier (OID) is labeled as \",(0,n.jsx)(e.code,{children:\"SpcRelaxedPEMarkerCheck\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`__int64 __fastcall I_GetRelaxedMarkerCheckFlags(struct _CRYPT_PROVIDER_DATA *a1, DWORD a2, unsigned int *a3)\n{\n    unsigned int v4; // ebx\n    CRYPT_PROVIDER_SGNR *ProvSignerFromChain; // rax\n    PCRYPT_ATTRIBUTE Attribute; // rax\n    signed int LastError; // eax\n    DWORD pcbStructInfo; // [rsp+60h] [rbp+18h] BYREF\n\n    pcbStructInfo = 4;\n    v4 = 0;\n    *a3 = 0;\n    ProvSignerFromChain = WTHelperGetProvSignerFromChain(a1, a2, 0, 0);\n    if(ProvSignerFromChain)\n    {\n        Attribute = CertFindAttribute(\n            \"1.3.6.1.4.1.311.2.6.1\",\n            ProvSignerFromChain-\u003epsSigner-\u003eAuthAttrs.cAttr,\n            ProvSignerFromChain-\u003epsSigner-\u003eAuthAttrs.rgAttr);\n        if(Attribute)\n        {\n            if(!CryptDecodeObject(\n                a1-\u003edwEncoding,\n                (LPCSTR)0x1B,\n                Attribute-\u003ergValue-\u003epbData,\n                Attribute-\u003ergValue-\u003ecbData,\n                0,\n                a3,\n                \u0026pcbStructInfo))\n            {\n                return HRESULT_FROM_WIN32(GetLastError());\n            }\n        }\n    }\n\n    return v4;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Our binary did not have this attribute, which caused the function to return no data and triggered the error. The function names reminded us of an optional parameter that we had previously seen in \",(0,n.jsx)(e.code,{children:\"signtool.exe\"}),\":\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"/rmc\"}),\" - Specifies signing a PE file with the relaxed marker check semantic. The flag is ignored for non-PE files. During verification, certain authenticated sections of the signature will bypass invalid PE markers check. This option should only be used after careful consideration and reviewing the details of MSRC case MS12-024 to ensure that no vulnerabilities are introduced.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Based on our analysis, we suspected that re-signing the executable with the \\u201Crelaxed marker check\\u201D flag (\",(0,n.jsx)(e.code,{children:\"/rmc\"}),\"), and as expected, the signature was now valid.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"root-cause-analysis\",children:\"Root cause analysis\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"While the workaround above resolved our immediate problem, it clearly wasn\\u2019t the root cause. We needed to investigate further to understand why the internal \",(0,n.jsx)(e.code,{children:\"dwReserved1\"}),\" flag was set in the first place.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This field is part of the \",(0,n.jsx)(e.code,{children:\"SIP_SUBJECTINFO\"}),\" structure, which is \",(0,n.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/mssip/ns-mssip-sip_subjectinfo\",rel:\"nofollow\",children:\"documented on MSDN\"}),\" - but unfortunately, it didn\\u2019t help much in this case:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/malformed-authenticode-signature/image3.png\",alt:\"SIP_SUBJECTINFO structure comment\",title:\"SIP_SUBJECTINFO structure comment\",width:\"358\",height:\"83\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To find where this field was being set, we worked backwards and identified a point where \",(0,n.jsx)(e.code,{children:\"dwReserved1\"}),\" was still \",(0,n.jsx)(e.code,{children:\"0\"}),\" - i.e., before the flag had been set. We placed a hardware breakpoint (on write) on the \",(0,n.jsx)(e.code,{children:\"dwReserved1\"}),\" field and resumed execution. The breakpoint was hit in the \",(0,n.jsx)(e.code,{children:\"SIPObjectPE_::GetMessageFromFile\"}),\" function:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`__int64 __fastcall SIPObjectPE_::GetMessageFromFile(\n    SIPObjectPE_ *this,\n    struct SIP_SUBJECTINFO_ *a2,\n    struct _WIN_CERTIFICATE *a3,\n    unsigned int a4,\n    unsigned int *a5)\n{\n    __int64 v5; // rcx\n    __int64 result; // rax\n    DWORD v8; // [rsp+40h] [rbp+8h] BYREF\n\n    v5 = *((_QWORD*)this + 1);\n    v8 = 0;\n    result = ImageGetCertificateDataEx(v5, a4, a3, a5, \u0026v8);\n    if((_DWORD)result)\n        a2-\u003edwReserved1 = v8;\n\n    return result;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This function calls the \",(0,n.jsx)(e.code,{children:\"ImageGetCertificateDataEx\"}),\" API which is exported by \",(0,n.jsx)(e.code,{children:\"imagehlp.dll\"}),\". The value returned by the fifth parameter of this function is stored in \",(0,n.jsx)(e.code,{children:\"dwReserved1\"}),'. This value ultimately determines whether the PE is considered \"malformed\" in the manner we have been observing.']}),`\n`,(0,n.jsxs)(e.p,{children:[\"Unfortunately, \",(0,n.jsx)(e.code,{children:\"ImageGetCertificateDataEx\"}),\" is undocumented on MSDN. However, an earlier variant, \",(0,n.jsx)(e.code,{children:\"ImageGetCertificateData\"}),\", \",(0,n.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/windows/win32/api/imagehlp/nf-imagehlp-imagegetcertificatedata\",rel:\"nofollow\",children:\"is documented\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`BOOL IMAGEAPI ImageGetCertificateData(\n  [in]      HANDLE            FileHandle,\n  [in]      DWORD             CertificateIndex,\n  [out]     LPWIN_CERTIFICATE Certificate,\n  [in, out] PDWORD            RequiredLength\n);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This function extracts the contents of the \",(0,n.jsx)(e.code,{children:\"IMAGE_DIRECTORY_ENTRY_SECURITY\"}),\" directory from the PE headers. Manual analysis of the \",(0,n.jsx)(e.code,{children:\"ImageGetCertificateDataEx\"}),\" function showed that the first four parameters match those of \",(0,n.jsx)(e.code,{children:\"ImageGetCertificateData\"}),\", but with one additional output parameter at the end.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We wrote a simple test program that allows us to call this function and perform checks against the unknown fifth parameter:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`#include \u003cstdio.h\u003e\n#include \u003cwindows.h\u003e\n#include \u003cimagehlp.h\u003e\n\nint main()\n{\n    HANDLE hFile = NULL;\n    DWORD dwCertLength = 0;\n    WIN_CERTIFICATE *pCertData = NULL;\n    DWORD dwUnknown = 0;\n    BOOL (WINAPI *pImageGetCertificateDataEx)(HANDLE FileHandle, DWORD CertificateIndex, LPWIN_CERTIFICATE Certificate, PDWORD RequiredLength, DWORD *pdwUnknown);\n\n    // open target executable\n    hFile = CreateFileA(\"C:\\\\\\\\users\\\\\\\\matthew\\\\\\\\sample-executable.exe\", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n    if(hFile == INVALID_HANDLE_VALUE)\n    {\n        printf(\"Failed to open input file\\\\n\");\n        return 1;\n    }\n\n    // locate ImageGetCertificateDataEx export in imagehlp.dll\n    pImageGetCertificateDataEx = (BOOL(WINAPI*)(HANDLE,DWORD,LPWIN_CERTIFICATE,PDWORD,DWORD*))GetProcAddress(LoadLibraryA(\"imagehlp.dll\"), \"ImageGetCertificateDataEx\");\n    if(pImageGetCertificateDataEx == NULL)\n    {\n        printf(\"Failed to locate ImageGetCertificateDataEx\\\\n\");\n        return 1;\n    }\n\n    // get required length\n    dwCertLength = 0;\n    if(pImageGetCertificateDataEx(hFile, 0, NULL, \u0026dwCertLength, \u0026dwUnknown) == 0)\n    {\n        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n        {\n            printf(\"ImageGetCertificateDataEx error (1)\\\\n\");\n            return 1;\n        }\n    }\n\n    // allocate data\n    printf(\"Allocating %u bytes for certificate...\\\\n\", dwCertLength);\n    pCertData = (WIN_CERTIFICATE*)malloc(dwCertLength);\n    if(pCertData == NULL)\n    {\n        printf(\"Failed to allocate memory\\\\n\");\n        return 1;\n    }\n\n    // read certificate data and dwUnknown flag\n    if(pImageGetCertificateDataEx(hFile, 0, pCertData, \u0026dwCertLength, \u0026dwUnknown) == 0)\n    {\n        printf(\"ImageGetCertificateDataEx error (2)\\\\n\");\n        return 1;\n    }\n\n    printf(\"Finished - dwUnknown: %u\\\\n\", dwUnknown);\n\n    return 0;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Running this against a variety of executables confirmed our expectations: the unknown return value was \",(0,n.jsx)(e.code,{children:\"1\"}),\" for our \\u201Cbroken\\u201D executable, and \",(0,n.jsx)(e.code,{children:\"0\"}),\" for correctly signed binaries. This confirmed that the issue originated somewhere within the \",(0,n.jsx)(e.code,{children:\"ImageGetCertificateDataEx\"}),\" function.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Further analysis of this function revealed that the unknown flag is being set by another internal function: \",(0,n.jsx)(e.code,{children:\"IsBufferCleanOfInvalidMarkers\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`...\nif(!IsBufferCleanOfInvalidMarkers(v25, v15, pdwUnknown))\n{\n    LastError = GetLastError();\n    if(!pdwUnknown)\n        goto LABEL_34;\n}\n...\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"After cleaning up the \",(0,n.jsx)(e.code,{children:\"IsBufferCleanOfInvalidMarkers\"}),\" function, we observed the following:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`DWORD IsBufferCleanOfInvalidMarkers(BYTE *pData, DWORD dwLength, DWORD *pdwInvalidMarkerFound)\n{\n    if(!_InterlockedCompareExchange64(\u0026global_InvalidMarkerList, 0, 0))\n        LoadInvalidMarkers();\n\n    if(!RabinKarpFindPatternInBuffer(pData, dwLength, pdwInvalidMarkerFound))\n        return 1;\n\n    SetLastError(0x80096011); // TRUST_E_MALFORMED_SIGNATURE\n\n    return 0;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:['This function loads a global list of \"invalid markers\" using ',(0,n.jsx)(e.code,{children:\"LoadInvalidMarkers\"}),\", if they are not already loaded. \",(0,n.jsx)(e.code,{children:\"imagehlp.dll\"}),\" contains a hardcoded default list of markers, but also checks the registry for a user-defined list at the following path:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Cryptography\\\\Wintrust\\\\Config\\\\PECertInvalidMarkers\"})}),`\n`,(0,n.jsx)(e.p,{children:\"This registry value does not appear to exist by default.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The function then performs a search across the entire PE signature data, looking for any of these markers. If a match is found, \",(0,n.jsx)(e.code,{children:\"pdwInvalidMarkerFound\"}),\" is set to \",(0,n.jsx)(e.code,{children:\"1\"}),\", which maps directly to the \",(0,n.jsx)(e.code,{children:\"psSipSubjectInfo-\u003edwReserved1\"}),\" value mentioned earlier.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"dumping-the-invalid-markers\",children:\"Dumping the invalid markers\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The markers are stored in an undocumented structure inside \",(0,n.jsx)(e.code,{children:\"imagehlp.dll\"}),\". After reverse-engineering the \",(0,n.jsx)(e.code,{children:\"RabinKarpFindPatternInBuffer\"}),\" function noted above, we wrote a small tool to dump the entire list of markers:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-c\",children:`#include \u003cstdio.h\u003e\n#include \u003cwindows.h\u003e\n\nint main()\n{\n    HMODULE hModule = LoadLibraryA(\"imagehlp.dll\");\n\n    // hardcoded address - imagehlp.dll version:\n    // 509ef25f9bac59ebf1c19ec141cb882e5c1a8cb61ac74a10a9f2bd43ed1f0585\n    BYTE *pInvalidMarkerData = (BYTE*)hModule + 0xC4D8;\n\n    BYTE *pEntryList = (BYTE*)*(DWORD64*)(pInvalidMarkerData + 20);\n    DWORD dwEntryCount = *(DWORD*)pInvalidMarkerData;\n    for(DWORD i = 0; i \u003c dwEntryCount; i++)\n    {\n        BYTE *pCurrEntry = pEntryList + (i * 18);\n        BYTE bLength = *(BYTE*)(pCurrEntry + 9);\n        BYTE *pString = (BYTE*)*(DWORD64*)(pCurrEntry + 10);\n        for(DWORD ii = 0; ii \u003c bLength; ii++)\n        {\n            if(isprint(pString[ii]))\n            {\n                // printable character\n                printf(\"%c\", pString[ii]);\n            }\n            else\n            {\n                // non-printable character\n                printf(\"\\\\\\\\x%02X\", pString[ii]);\n            }\n        }\n        printf(\"\\\\n\");\n    }\n\n    return 0;\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This produced the following results:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`PK\\\\x01\\\\x02\nPK\\\\x05\\\\x06\nPK\\\\x03\\\\x04\nPK\\\\x07\\\\x08\nRar!\\\\x1A\\\\x07\\\\x00\nz\\\\xBC\\\\xAF'\\\\x1C\n**ACE**\n!\u003carch\u003e\\\\x0A\nMSCF\\\\x00\\\\x00\\\\x00\\\\x00\n\\\\xEF\\\\xBE\\\\xAD\\\\xDENull\nInitializing Wise Installation Wizard\nzlb\\\\x1A\nKGB_arch\nKGB2\\\\x00\nKGB2\\\\x01\nENC\\\\x00\ndisk%i.pak\n\u003e-\\\\x1C\\\\x0BxV4\\\\x12\nISc(\nSmart Install Maker\n\\\\xAE\\\\x01NanoZip\n;!@Install@\nEGGA\nArC\\\\x01\nStuffIt!\n-sqx-\nPK\\\\x09\\\\x0A\n\"\\\\x0B\\\\x01\\\\x0B\n-lh0-\n-lh1-\n-lh2-\n-lh3-\n-lh4-\n-lh5-\n-lh6-\n-lh7-\n-lh8-\n-lh9-\n-lha-\n-lhb-\n-lhc-\n-lhd-\n-lhe-\n-lzs-\n-lz2-\n-lz3-\n-lz4-\n-lz5-\n-lz7-\n-lz8-\n\u003c#$@@$#\u003e\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As expected, this appears to be a list of magic values pertaining to old installers and compressed archive formats. This aligns with the description of \",(0,n.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-098\",rel:\"nofollow\",children:\"MS13-098\"}),\", which hints towards certain installers being affected.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We suspected this was related to self-extracting executables. If an executable reads itself from disk and scans its own data for an embedded archive (e.g., a ZIP file), an attacker could potentially append malicious data to the signature section without invalidating the signature - since signature data cannot hash itself. This could potentially cause the vulnerable executable to locate the malicious data before the original data, especially if it scans backwards from the end of the file.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We later found an old \",(0,n.jsx)(e.a,{href:\"https://recon.cx/2012/schedule/events/246.en.html\",rel:\"nofollow\",children:\"RECon talk from 2012 by Igor Gl\\xFCcksmann\"}),\", which describes this exact scenario and appears to confirm our hypothesis.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Microsoft's fix involved scanning the PE signature block for known byte patterns that could indicate this type of abuse.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"investigating-the-false-positive\",children:\"Investigating the false positive\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Upon further debugging, we discovered that the binary was being flagged due to the signature data containing the \",(0,n.jsx)(e.code,{children:\"EGGA\"}),\" marker from the list above:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/malformed-authenticode-signature/image1.png\",alt:\"EGGA marker\",title:\"EGGA marker\",width:\"610\",height:\"66\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the context of the list of markers above, the \",(0,n.jsx)(e.code,{children:\"EGGA\"}),\" signature appears to relate to a specific header value used by an archive format called \",(0,n.jsx)(e.a,{href:\"http://justsolve.archiveteam.org/wiki/EGG_(ALZip)\",rel:\"nofollow\",children:\"ALZip\"}),\". Our code does not make any use of this file format.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Microsoft\\u2019s heuristic treated the presence of \",(0,n.jsx)(e.code,{children:\"EGGA\"}),\" as evidence that malicious archive data had been embedded in the PE signature. In practice, nothing of the sort was present. The signature block itself happened to include those four bytes as part of the hashed data.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Collisions like this are unusual, but page hashing (\",(0,n.jsx)(e.code,{children:\"/ph\"}),\") made it more likely. By expanding the size of the signature block, page hashing increases the surface area for coincidental matches and increases the likelihood of triggering the heuristic.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary didn\\u2019t contain any self-extracting routines, so the hit on \",(0,n.jsx)(e.code,{children:\"EGGA\"}),\" was a false positive. In that context, the warning had no bearing on the file\\u2019s integrity. This meant it was safe to re-sign the file with \",(0,n.jsx)(e.code,{children:\"/rmc\"}),\" to restore the expected validation.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"It is well known that additional data can be embedded in a PE file without breaking its signature by appending it to the security block. Even some \",(0,n.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/archive/blogs/ieinternals/caveats-for-authenticode-code-signing\",rel:\"nofollow\",children:\"legitimate software products\"}),\" take advantage of this to embed user-specific metadata into signed executables. However, we were not aware that Microsoft had implemented heuristics to detect specific malicious cases of this, even though they were introduced back in 2012.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The original error message was very vague, and we were unable to find any documentation or references online that helped explain the behavior. Even searching for the associated registry value after discovering it (\",(0,n.jsx)(e.code,{children:\"PECertInvalidMarkers\"}),\") yielded zero results.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"What we uncovered is that Microsoft added heuristic scanning of signature blocks more than a decade ago to counter specific abuse cases. Those heuristics reside in a hardcoded list of \\u201Cinvalid markers,\\u201D many of which are tied to outdated installers and archive formats. Our binary happened to collide with one of those markers when signed with page hashing enabled, creating a validation failure with no clear documentation and no public references to the underlying registry key or detection logic.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The absence of online discussions regarding this failure mode, aside from a single unresolved \",(0,n.jsx)(e.a,{href:\"https://developercommunity.visualstudio.com/t/malformed-digital-signature-ms13-098-1/235599\",rel:\"nofollow\",children:\"Visual Studio Developer Community post from 2018\"}),\", made the initial diagnosis difficult. By publishing this analysis, we want to provide a technical reference point for others who may encounter the same problem. In our case, resolving the issue required deep troubleshooting that few outside this space would normally need to exercise. For teams automating code signing, the key lesson is to integrate signature validation checks early and be aware that heuristic marker detection can lead to edge-case failures.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"additional-references\",children:\"Additional references\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The author can be found on X at \",(0,n.jsx)(e.a,{href:\"https://x.com/x86matthew\",rel:\"nofollow\",children:\"@x86matthew.\"})]})]})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(l,{...t})}):l(t)}return E(x);})();\n;return Component;"},"_id":"articles/malformed-authenticode-signature.mdx","_raw":{"sourceFilePath":"articles/malformed-authenticode-signature.mdx","sourceFileName":"malformed-authenticode-signature.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/malformed-authenticode-signature"},"type":"Article","imageUrl":"/assets/images/malformed-authenticode-signature/malformed-authenticode-signature.png","readingTime":"16 min read","series":"","url":"/malformed-authenticode-signature","headings":[{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"Diagnosis","href":"#diagnosis"},{"level":3,"title":"Root cause analysis","href":"#root-cause-analysis"},{"level":3,"title":"Dumping the invalid markers","href":"#dumping-the-invalid-markers"},{"level":3,"title":"Investigating the false positive","href":"#investigating-the-false-positive"},{"level":3,"title":"Conclusion","href":"#conclusion"},{"level":2,"title":"Additional references","href":"#additional-references"}],"author":[{"title":"Elastic Security Labs","slug":"elastic-security-labs","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var j=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),p=(t,e)=\u003e{for(var n in e)o(t,n,{get:e[n],enumerable:!0})},c=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of _(e))!g.call(t,a)\u0026\u0026a!==n\u0026\u0026o(t,a,{get:()=\u003ee[a],enumerable:!(s=f(e,a))||s.enumerable});return t};var y=(t,e,n)=\u003e(n=t!=null?x(d(t)):{},c(e||!t||!t.__esModule?o(n,\"default\",{value:t,enumerable:!0}):n,t)),M=t=\u003ec(o({},\"__esModule\",{value:!0}),t);var u=j((F,i)=\u003e{i.exports=_jsx_runtime});var C={};p(C,{default:()=\u003em,frontmatter:()=\u003eb});var r=y(u()),b={title:\"Elastic Security Labs\",slug:\"elastic-security-labs\"};function l(t){return(0,r.jsx)(r.Fragment,{})}function m(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}return M(C);})();\n;return Component;"},"_id":"authors/elastic-security-labs.mdx","_raw":{"sourceFilePath":"authors/elastic-security-labs.mdx","sourceFileName":"elastic-security-labs.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/elastic-security-labs"},"type":"Author","imageUrl":"","url":"/authors/elastic-security-labs"}],"category":[{"title":"Security operations","slug":"security-operations","body":{"raw":"","code":"var Component=(()=\u003e{var f=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var l=Object.getPrototypeOf,d=Object.prototype.hasOwnProperty;var g=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=\u003e{for(var n in e)a(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,s)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of _(e))!d.call(t,o)\u0026\u0026o!==n\u0026\u0026a(t,o,{get:()=\u003ee[o],enumerable:!(s=p(e,o))||s.enumerable});return t};var y=(t,e,n)=\u003e(n=t!=null?f(l(t)):{},i(e||!t||!t.__esModule?a(n,\"default\",{value:t,enumerable:!0}):n,t)),M=t=\u003ei(a({},\"__esModule\",{value:!0}),t);var c=g((X,u)=\u003e{u.exports=_jsx_runtime});var D={};j(D,{default:()=\u003ex,frontmatter:()=\u003eC});var r=y(c()),C={title:\"Security operations\",slug:\"security-operations\"};function m(t){return(0,r.jsx)(r.Fragment,{})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(m,{...t})}):m(t)}return M(D);})();\n;return Component;"},"_id":"categories/security-operations.mdx","_raw":{"sourceFilePath":"categories/security-operations.mdx","sourceFileName":"security-operations.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-operations"},"type":"Category","url":"/categories/security-operations"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"malformed-authenticode-signature"},"buildId":"mPJGlO3yOEw6E1EzEho9U","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>