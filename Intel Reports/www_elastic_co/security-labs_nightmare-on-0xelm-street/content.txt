<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>NightMARE on 0xelm Street, a guided tour — Elastic Security Labs</title><meta name="description" content="This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators."/><meta property="og:title" content="NightMARE on 0xelm Street, a guided tour — Elastic Security Labs"/><meta property="og:description" content="This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators."/><meta property="og:image" content="https://www.elastic.co/security-labs/assets/images/nightmare-on-0xelm-street/Security Labs Images 31.jpg?2dc63dfa51370699b56414e22f522ce2"/><meta property="og:image:alt" content="This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators."/><meta property="og:site_name"/><meta property="og:url" content="https://www.elastic.co/security-labs/nightmare-on-0xelm-street"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="NightMARE on 0xelm Street, a guided tour — Elastic Security Labs"/><meta name="twitter:description" content="This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators."/><meta name="twitter:image" content="https://www.elastic.co/security-labs/assets/images/nightmare-on-0xelm-street/Security Labs Images 31.jpg?2dc63dfa51370699b56414e22f522ce2"/><meta name="twitter:image:alt" content="This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators."/><link rel="canonical" href="https://www.elastic.co/security-labs/nightmare-on-0xelm-street"/><link rel="preload" href="/security-labs/logo.svg" as="image" fetchpriority="high"/><link rel="preload" as="image" imageSrcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="100vw" fetchpriority="high"/><meta name="next-head-count" content="19"/><script src="https://play.vidyard.com/embed/v4.js" type="text/javascript" async=""></script><link rel="icon" href="/security-labs/favicon.svg"/><link rel="mask-icon" href="/security-labs/favicon.svg" color="#1C1E23"/><link rel="apple-touch-icon" href="/security-labs/favicon.svg"/><meta name="theme-color" content="#1C1E23"/><link rel="preload" href="/security-labs/_next/static/media/8e9860b6e62d6359-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/0ea4f4df910e6120-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/739c2d8941231bb4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/ee71530a747ff30b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/9fac010bc1f02be0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/security-labs/_next/static/media/cbf5fbad4d73afac-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><script id="google-tag-manager" data-nscript="beforeInteractive">
          (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
          new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
          'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-KNJMG2M');
          </script><link rel="preload" href="/security-labs/_next/static/css/f666e49a9abb8918.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/f666e49a9abb8918.css" data-n-g=""/><link rel="preload" href="/security-labs/_next/static/css/fc1dcb1d74b71e18.css" as="style"/><link rel="stylesheet" href="/security-labs/_next/static/css/fc1dcb1d74b71e18.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/security-labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/security-labs/_next/static/chunks/webpack-7987c6fda769d510.js" defer=""></script><script src="/security-labs/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/security-labs/_next/static/chunks/main-ebd33a9f1cae5951.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/_app-7ddc1b0db09f2c64.js" defer=""></script><script src="/security-labs/_next/static/chunks/fec483df-43ee602fabdfe3a4.js" defer=""></script><script src="/security-labs/_next/static/chunks/352-a63885403f676dc6.js" defer=""></script><script src="/security-labs/_next/static/chunks/511-d08fe0fdd6f8a984.js" defer=""></script><script src="/security-labs/_next/static/chunks/848-7728ed7430cf686c.js" defer=""></script><script src="/security-labs/_next/static/chunks/402-15cb752a3319fb2b.js" defer=""></script><script src="/security-labs/_next/static/chunks/765-e68775a5c9f211f6.js" defer=""></script><script src="/security-labs/_next/static/chunks/pages/%5Bslug%5D-740a124ff706010d.js" defer=""></script><script src="/security-labs/_next/static/-h5Wp0_6qpDXqGCvbcL5I/_buildManifest.js" defer=""></script><script src="/security-labs/_next/static/-h5Wp0_6qpDXqGCvbcL5I/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><main class="__variable_0351a5 __variable_a475ec __variable_ead7f7 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><div class="UtilityHeader_utilityHeader__T_Eto"><div class="UtilityHeader_utilityHeader__container__exgwf"><nav class="UtilityHeader_utilityLinks__ogtQ6"><h2 class="UtilityHeader_utilityHeading__0DExG">Explore Elastic: </h2><ul><li><a href="https://www.elastic.co">elastic.co</a></li><li><a href="https://www.elastic.co/search-labs">Search Labs</a></li><li><a href="https://www.elastic.co/observability-labs">Observability Labs</a></li></ul></nav></div></div><nav class="fixed w-full z-40 top-[29px]" data-headlessui-state=""><div class="bg-gradient-to-b from-zinc-900 from-20% h-[200%] to-transparent absolute inset-0 z-0 pointer-events-none"></div><div class="container relative z-10"><div class="flex h-16 items-center justify-between"><div class="flex items-center justify-start w-full"><div><a class="hover:opacity-50 transition" href="/security-labs"><img alt="elastic security labs logo" fetchpriority="high" width="200" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/security-labs/logo.svg"/></a></div><div class="hidden lg:ml-6 lg:block"><div class="flex space-x-4"><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/about"><span>About</span></a><div class="relative" data-headlessui-state=""><div><button class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" id="headlessui-menu-button-:R2kq6:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state="">Topics<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="ml-1 -mr-1 h-4 w-4 text-zinc-400 relative top-[1px]"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd"></path></svg></button></div></div><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/vulnerability-updates"><span>Vulnerability updates</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/reports"><span>Reports</span></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="/security-labs/category/tools"><span>Tools</span></a></div></div><div class="hidden lg:ml-auto lg:block"><div class="flex items-center space-x-4"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/nightmare-on-0xelm-street"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><a class="flex lg:inline-flex font-light my-1 py-1 px-2 font-display font-semibold lg:text-sm xl:text-base items-center transition hover:hover-link hover:text-white focus:accessible-link-focus" href="https://www.elastic.co/security-labs/rss/feed.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-4 w-4 mr-1"><path d="M3.75 3a.75.75 0 00-.75.75v.5c0 .414.336.75.75.75H4c6.075 0 11 4.925 11 11v.25c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75V16C17 8.82 11.18 3 4 3h-.25z"></path><path d="M3 8.75A.75.75 0 013.75 8H4a8 8 0 018 8v.25a.75.75 0 01-.75.75h-.5a.75.75 0 01-.75-.75V16a6 6 0 00-6-6h-.25A.75.75 0 013 9.25v-.5zM7 15a2 2 0 11-4 0 2 2 0 014 0z"></path></svg><span class="hidden xl:block">Subscribe</span></a><a class="font-display inline-flex items-center justify-center rounded font-semibold disabled:!select-none disabled:!bg-gray-400 bg-blue-600 text-white hover:bg-blue-500 enabled:hover:text-white/80 transition-colors px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://cloud.elastic.co/registration?cta=cloud-registration&amp;tech=trial&amp;plcmt=navigation&amp;pg=security-labs">Start free trial</a><a class="font-display inline-flex items-center justify-center rounded font-semibold text-white disabled:!select-none disabled:!bg-gray-400 button px-4 py-2 text-sm flex-1 lg:flex-auto" href="https://www.elastic.co/contact">Contact sales</a></div></div></div><div class="-mr-2 flex lg:hidden"><a class="rounded flex items-center p-4 text-white focus:outline-none focus:ring-0 focus:ring-offset-1 focus:ring-offset-zinc-600 group" href="https://search.elastic.co/?location%5B0%5D=Security%20Labs&amp;referrer=https://www.elastic.co/security-labs/nightmare-on-0xelm-street"><div class="flex items-center relative font-display"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></div></a><button class="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white" id="headlessui-disclosure-button-:R5a6:" type="button" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Open navigation menu</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div></div></div></nav><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[&#x27; &#x27;] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[&#x27; &#x27;] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" dateTime="2025-10-14T00:00:00.000Z">14 October 2025</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="/security-labs/author/cyril-francois">Cyril François</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>NightMARE on 0xelm Street, a guided&nbsp;tour</span></h1><p class="text-zinc-200 text-base md:text-xl">This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>17 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/malware-analysis">Malware analysis</a>, </span><span><a class="hover:text-blue-400 whitespace-nowrap" href="/security-labs/category/security-research">Security research</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="NightMARE on 0xelm Street, a guided tour" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" sizes="100vw" srcSet="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=640&amp;q=75 640w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=750&amp;q=75 750w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=828&amp;q=75 828w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=1080&amp;q=75 1080w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=1200&amp;q=75 1200w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=1920&amp;q=75 1920w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=2048&amp;q=75 2048w, /security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=3840&amp;q=75 3840w" src="/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Fnightmare-on-0xelm-street%2FSecurity%20Labs%20Images%2031.jpg&amp;w=3840&amp;q=75"/><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>Since the creation of Elastic Security Labs, we have focused on developing malware analysis tools to not only aid in our research and analysis, but also to release to the public. We want to give back to the community and give back as much as we get from it. In an effort to make these tools more robust and reduce code duplication, we created the Python library <a href="https://github.com/elastic/nightMARE">nightMARE</a>. This library brings together various useful features for reverse engineering and malware analysis. We primarily use it to create our configuration extractors for different widespread malware families, but nightMARE is a library that can be applied to multiple use cases.</p>
<p>With the release of version 0.16, we want to officially introduce the library and provide details in this article on some interesting features offered by this module, as well as a short tutorial explaining how to use it to implement your own configuration extractor compatible with the latest version of LUMMA (as of the post date).</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="nightmare-features-tour" class="absolute -top-32"></span>nightMARE features tour</h2>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="powered-by-rizin" class="absolute -top-32"></span>Powered by Rizin</h3>
<p>To reproduce the capabilities of popular disassemblers, nightMARE initially used a set of Python modules to perform the various tasks necessary for static analysis. For example, we used <a href="https://github.com/lief-project/LIEF">LIEF</a> for executable parsing (PE, ELF), <a href="https://github.com/capstone-engine/capstone">Capstone</a> to disassemble binaries, and <a href="https://github.com/danielplohmann/smda">SMDA</a> to obtain cross-reference (xref) analysis.</p>
<p>These numerous dependencies made maintaining the library more complex than necessary. That&#x27;s why, in order to reduce the use of third-party modules as much as possible, we decided to use the most comprehensive reverse engineering framework available. Our choice naturally gravitated towards Rizin.</p>
<p><a href="https://github.com/rizinorg/rizin">Rizin</a> is an open-source reverse engineering software, forked from the Radare2 project. Its speed, modular design, and almost infinite set of features based on its Vim-like commands make it an excellent backend choice. We integrated it into the project using the <a href="https://github.com/rizinorg/rz-pipe">rz-pipe</a> module, which makes it very easy to create and instrument a Rizin instance from Python.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="project-structure" class="absolute -top-32"></span>Project structure</h3>
<p></p>
<p>The project is structured along three axes:</p>
<ul>
<li>The &quot;analysis&quot; module contains sub-modules useful for static analysis.</li>
<li>The &quot;core&quot; module contains commonly useful sub-modules: bitwise operations, integer casting, and recurring regexes for configuration extraction.</li>
<li>The &quot;malware&quot; module contains all algorithm implementations (crypto, unpacking, configuration extraction, etc.), grouped by malware family and, when applicable, by version.</li>
</ul>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="analysis-modules" class="absolute -top-32"></span>Analysis modules</h3>
<p>For static binary analysis, this module offers two complementary working techniques: disassembly and instruction analysis with Rizin via the reversing module, and instruction emulation via the emulation module.</p>
<p>For example, when constants are manually moved onto the stack, instead of trying to analyze the instructions one by one to retrieve the immediates, it is possible to emulate the entire piece of code and read the data on the stack once the processing is done.</p>
<p></p>
<p>Another example that we will see later in this article is that, in the case of cryptographic functions, if it is complex, it is often simpler to directly call it in the binary using emulation than to try to implement it manually.</p>
<p></p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="reversing-module" class="absolute -top-32"></span>Reversing module</h4>
<p>This module contains the Rizin class, which is an abstraction of Rizin&#x27;s functionalities that send commands directly to Rizin thanks to <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rz-pipe</code> and offers the user an incredible amount of analysis power for free. Because it’s an abstraction, the functions that the class exposes can be easily used in a script without prior knowledge of the framework.</p>
<p>Although this class exposes a lot of different features, we are not trying to be exhaustive. The goal is to reduce duplicated code for recurring functionalities across all our tools. However, if a user finds that a function is missing, they can directly interact with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">rz-pipe</code> object to send commands to Rizin and achieve their goals.</p>
<p>Here is a short list of the functions we use the most:</p>
<pre><code># Disassembling
def disassemble(self, offset: int, size: int) -&gt; list[dict[str, typing.Any]]
def disassemble_previous_instruction(self, offset: int) -&gt; dict[str, typing.Any]
def disassemble_next_instruction(self, offset: int) -&gt; dict[str, typing.Any]

# Pattern matching
def find_pattern(
    self, 
    pattern: str,
    pattern_type: Rizin.PatternType) -&gt; list[dict[str, typing.Any]]
def find_first_pattern(
    self,
    patterns: list[str],
    pattern_type: Rizin.PatternType) -&gt; int

# Reading bytes
def get_data(self, offset: int, size: int | None = None) -&gt; bytes
def get_string(self, offset: int) -&gt; bytes

# Reading words
def get_u8(self, offset: int) -&gt; int
...
def get_u64(self, offset: int) -&gt; int

# All strings, functions
def get_strings(self) -&gt; list[dict[str, typing.Any]]
def get_functions(self) -&gt; list[dict[str, typing.Any]]

# Xrefs
def get_xrefs_from(self, offset: int) -&gt; list
def get_xrefs_to(self, offset: int) -&gt; list[int]</code></pre>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="emulation-module" class="absolute -top-32"></span>Emulation module</h4>
<p>In version 0.16, we reworked the emulation module to take full advantage of Rizin&#x27;s capabilities to perform its various data-related tasks. Under the hood, it’s using the <a href="https://www.unicorn-engine.org/">Unicorn engine</a> to perform emulation.</p>
<p>For now, this module only offers a &quot;light&quot; PE emulation with the class WindowsEmulator, light in the sense that only the strict minimum is done to load a PE. No relocations, no DLLs, no OS emulation. The goal is not to completely emulate a Windows executable like <a href="https://github.com/qilingframework/qiling">Qiling</a> or <a href="https://github.com/momo5502/sogen">Sogen</a>, but to offer a simple way to execute code snippets or short sequences of functions while knowing its limitations.</p>
<p>The WindowsEmulator class offers several useful abstractions.</p>
<pre><code># Load PE and its stack
def load_pe(self, pe: bytes, stack_size: int) -&gt; None

# Manipulate stack
def push(self, x: int) -&gt; None
def pop(self) -&gt; int

# Simple memory management mechanisms
def allocate_memory(self, size: int) -&gt; int
def free_memory(self, address: int, size: int) -&gt; None

# Direct ip and sp manipulation
@property
def ip(self) -&gt; int
@property
def sp(self) -&gt; int

# Emulate call and ret
def do_call(self, address: int, return_address: int) -&gt; None
def do_return(self, cleaning_size: int = 0) -&gt; None

# Direct unicorn access
@property
def unicorn(self) -&gt; unicorn.Uc</code></pre>
<p>The class allows the registration of two types of hooks: normal unicorn hooks and IAT hooks.</p>
<pre><code># Set unicorn hooks, however the WindowsEmulator instance get passed to the callback instead of unicorn
def set_hook(self, hook_type: int, hook: typing.Callable) -&gt; int:

# Set hook on import call
def enable_iat_hooking(self) -&gt; None:
def set_iat_hook(
        self,
        function_name: bytes,
        hook: typing.Callable[[WindowsEmulator, tuple, dict[str, typing.Any]], None],
) -&gt; None:</code></pre>
<p>As a usage example, we use the Windows binary <a href="https://www.virustotal.com/gui/file/e36bcf02bc11f560761e943d0fad37417078f6cbb473f85c72fcbc89e2600c58"><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">DismHost.exe</code></a> .</p>
<p>The binary uses the Sleep import at address <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x140006404</code>:</p>
<p></p>
<p>We will therefore create a script that registers an IAT hook for the Sleep import, starts the emulation execution at address <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x140006404</code>, and ends at address <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">0x140006412</code>.</p>
<pre><code># coding: utf-8

import pathlib

from nightMARE.analysis import emulation


def sleep_hook(emu: emulation.WindowsEmulator, *args) -&gt; None:
    print(
        &quot;Sleep({} ms)&quot;.format(
            emu.unicorn.reg_read(emulation.unicorn.x86_const.UC_X86_REG_RCX)
        ),
    )
    emu.do_return()


def main() -&gt; None:
    path = pathlib.Path(r&quot;C:\Windows\System32\Dism\DismHost.exe&quot;)
    emu = emulation.WindowsEmulator(False)
    emu.load_pe(path.read_bytes(), 0x10000)
    emu.enable_iat_hooking()
    emu.set_iat_hook(&quot;KERNEL32.dll!Sleep&quot;, sleep_hook)
    emu.unicorn.emu_start(0x140006404, 0x140006412)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p>It is important to note that the hook function must necessarily return with the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">do_return</code> function so that we can reach the address located after the call.</p>
<p>When the emulator starts, our hook is correctly executed.</p>
<p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="malware-module" class="absolute -top-32"></span>Malware module</h3>
<p>The malware module contains all the algorithm implementations for each malware family we cover. These algorithms can cover configuration extraction, cryptographic functions, or sample unpacking, depending on the type of malware. All these algorithms use the functionalities of the analysis module to do their job and provide good examples of how to use the library.</p>
<p>With the release of v0.16, here are the different malware families that we cover.</p>
<pre><code>blister
deprecated
ghostpulse
latrodectus
lobshot
lumma
netwire
redlinestealer
remcos
smokeloader
stealc
strelastealer
xorddos</code></pre>
<p>The complete implementation of the LUMMA algorithms we cover in the next chapter tutorial can be found under the LUMMA sub-module.</p>
<p>Please take note that the rapidly evolving nature of malware makes maintaining these modules difficult, but we welcome any help to the project, direct contribution, or opening issues.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="example-lumma-configuration-extraction" class="absolute -top-32"></span>Example: LUMMA configuration-extraction</h2>
<p>LUMMA STEALER, also known as LUMMAC2, is an information-stealing malware still widely used in infection campaigns despite a recent takedown operation in May 2025. This malware incorporates control flow obfuscation and data encryption, making it more challenging to analyze both statically and dynamically.</p>
<p>In this section, we will use the following unencrypted sample as reference: <a href="https://www.virustotal.com/gui/file/26803ff0e079e43c413e10d9a62d344504a134d20ad37af9fd3eaf5c54848122">26803ff0e079e43c413e10d9a62d344504a134d20ad37af9fd3eaf5c54848122</a></p>
<p>We do a short analysis of how it decrypts its domain names step by step, and then demonstrate along the way how we build the configuration extractor using nightMARE.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="step-1-initializing-the-chacha20-context" class="absolute -top-32"></span>Step 1: Initializing the ChaCha20 context</h3>
<p>In this version, LUMMA performs the initialization of its cryptographic context after loading <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">WinHTTP.dll</code>, with the decryption key and nonce; this context will be reused for each call to the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ChaCha20</code> decryption function without being reinitialized. The nuance here is that an internal counter within the context is updated with each use, so later we’ll need to take into account the value of this counter before the first domain decryption and then decrypt them in the correct order.</p>
<p><br/>
</p>
<p>To reproduce this step in our script, we need to collect the key and nonce. The problem is that we don&#x27;t know their location in advance, but we know where they are used. We pattern match this part of the code, then extract the addresses <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">g_key_0 (key)</code> and <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">g_key_1 (nonce)</code> from the instructions.</p>
<pre><code>CRYPTO_SETUP_PATTERN = &quot;b838?24400b???????00b???0???0096f3a5&quot;

def get_decryption_key_and_nonce(binary: bytes) -&gt; tuple[bytes, bytes]:
    # Load the binary in Rizin
    rz = reversing.Rizin.load(binary)

    # Find the virtual address of the pattern
    if not (
        x := rz.find_pattern(
            CRYPTO_SETUP_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN
        )
    ):
        raise RuntimeError(&quot;Failed to find crypto setup pattern virtual address&quot;)

    # Extract the key and nonce address from the instruction second operand
    crypto_setup_va = x[0][&quot;address&quot;]
    key_and_nonce_address = rz.disassemble(crypto_setup_va, 1)[0][&quot;opex&quot;][&quot;operands&quot;][
        1
    ][&quot;value&quot;]

    # Return the key and nonce data
    return rz.get_data(key_and_nonce_address, CHACHA20_KEY_SIZE), rz.get_data(
        key_and_nonce_address + CHACHA20_KEY_SIZE, CHACHA20_NONCE_SIZE
    )

def build_crypto_context(key: bytes, nonce: bytes, initial_counter: int) -&gt; bytes:
    crypto_context = bytearray(0x40)
    crypto_context[0x10:0x30] = key
    crypto_context[0x30] = initial_counter
    crypto_context[0x38:0x40] = nonce
    return bytes(crypto_context)</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="step-2-locate-the-decryption-function" class="absolute -top-32"></span>Step 2: Locate the decryption function</h3>
<p>In this version, LUMMA&#x27;s decryption function is easily located across samples as it is utilized immediately after loading WinHTTP imports.</p>
<p></p>
<p>We derive the hex pattern from the first bytes of the function to locate it in our script:</p>
<pre><code>DECRYPTION_FUNCTION_PATTERN = &quot;5553575681ec1?0100008b??243?01000085??0f84??080000&quot;

def get_decryption_function_address(binary) -&gt; int:
    # A cache system exist so the binary is only loaded once, then we get the same instance of Rizin :)
    if x := reversing.Rizin.load(binary: bytes).find_pattern(
        DECRYPTION_FUNCTION_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN
    ):
        return x[0][&quot;address&quot;]
    raise RuntimeError(&quot;Failed to find decryption function address&quot;)</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="step-3-locate-the-encrypted-domains-base-address" class="absolute -top-32"></span>Step 3: Locate the encrypted domain&#x27;s base address</h3>
<p>By using xrefs from the decryption function, which is not called with obfuscated indirection like other LUMMA functions, we can easily find where it is called to decrypt the domains.</p>
<p></p>
<p>As with the first step, we will use the instructions to discover the base address of the encrypted domains in the binary:</p>
<p></p>
<pre><code>C2_LIST_MAX_LENGTH = 0xFF
C2_SIZE = 0x80
C2_DECRYPTION_BRANCH_PATTERN = &quot;8d8?e0?244008d7424??ff3?565?68????4500e8????ffff&quot;

def get_encrypted_c2_list(binary: bytes) -&gt; list[bytes]:
    rz = reversing.Rizin.load(binary)
    address = get_encrypted_c2_list_address(binary)
    encrypted_c2 = []
    for ea in range(address, address + (C2_LIST_MAX_LENGTH * C2_SIZE), C2_SIZE):
        encrypted_c2.append(rz.get_data(ea, C2_SIZE))
    return encrypted_c2


def get_encrypted_c2_list_address(binary: bytes) -&gt; int:
    rz = reversing.Rizin.load(binary)
    if not len(
        x := rz.find_pattern(
            C2_DECRYPTION_BRANCH_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN
        )
    ):
        raise RuntimeError(&quot;Failed to find c2 decryption pattern&quot;)

    c2_decryption_va = x[0][&quot;address&quot;]
    return rz.disassemble(c2_decryption_va, 1)[0][&quot;opex&quot;][&quot;operands&quot;][1][&quot;disp&quot;]</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="step-4-decrypt-domains-using-emulation" class="absolute -top-32"></span>Step 4: Decrypt domains using emulation</h3>
<p>A quick analysis of the decryption function shows that this version of LUMMA uses a slightly customized version of <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ChaCha20</code>. We recognize the same small and diverse decryption functions scattered throughout the binaries. Here, they are used to decrypt parts of the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ChaCha20</code> &quot;expand 32-byte k&quot; constant, which are then XOR-ROL derived before being stored in the context structure.</p>
<p></p>
<p>While we could implement the decryption function in our script, we have all the necessary addresses to demonstrate how we can directly call the function already present in the binary to decrypt our domains, using nightMARE&#x27;s emulation module.</p>
<pre><code># We need the right initial value, before decrypting the domain
# the function is already called once so 0 -&gt; 2
CHACHA20_INITIAL_COUNTER = 2

def decrypt_c2_list(
    binary: bytes, encrypted_c2_list: list[bytes], key: bytes, nonce: bytes
) -&gt; list[bytes]:
    # Get the decryption function address (step 2)
    decryption_function_address = get_decryption_function_address(binary)

    # Load the emulator, True = 32bits
    emu = emulation.WindowsEmulator(True)
 
    # Load the PE in the emulator with a stack of 0x10000 bytes
    emu.load_pe(binary, 0x10000)
    
    # Allocate the chacha context
    chacha_ctx_address = emu.allocate_memory(CHACHA20_CTX_SIZE)
    
    # Write at the chacha context address the crypto context
    emu.unicorn.mem_write(
        chacha_ctx_address,
        build_crypto_context(
            key,
            nonce,
            CHACHA20_INITIAL_COUNTER, 
        ),
    )

    decrypted_c2_list = []
    for encrypted_c2 in encrypted_c2_list:
	 # Allocate buffers
        encrypted_buffer_address = emu.allocate_memory(C2_SIZE)
        decrypted_buffer_address = emu.allocate_memory(C2_SIZE)
        
        # Write encrypted c2 to buffer
        emu.unicorn.mem_write(encrypted_buffer_address, encrypted_c2)

        # Push arguments
        emu.push(C2_SIZE)
        emu.push(decrypted_buffer_address)
        emu.push(encrypted_buffer_address)
        emu.push(chacha_ctx_address)
 
        # Emulate a call
        emu.do_call(decryption_function_address, emu.image_base)

        # Fire!
        emu.unicorn.emu_start(decryption_function_address, emu.image_base)

        # Read result from decrypted buffer
        decrypted_c2 = bytes(
            emu.unicorn.mem_read(decrypted_buffer_address, C2_SIZE)
        ).split(b&quot;\x00&quot;)[0]

        # If result isn&#x27;t printable we stop, no more domain
        if not bytes_re.PRINTABLE_STRING_REGEX.match(decrypted_c2):
            break

        # Add result to the list
        decrypted_c2_list.append(b&quot;https://&quot; + decrypted_c2)

        # Clean up the args
        emu.pop()
        emu.pop()
        emu.pop()
        emu.pop()

        # Free buffers
        emu.free_memory(encrypted_buffer_address, C2_SIZE)
        emu.free_memory(decrypted_buffer_address, C2_SIZE)

       # Repeat for the next one ...

    return decrypted_c2_list</code></pre>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="result" class="absolute -top-32"></span>Result</h3>
<p>Finally, we can run our module with <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pytest</code> and view the LUMMA C2 list (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">decrypted_c2_list</code>):</p>
<p></p>
<pre><code>https://mocadia[.]com/iuew  
https://mastwin[.]in/qsaz  
https://ordinarniyvrach[.]ru/xiur  
https://yamakrug[.]ru/lzka  
https://vishneviyjazz[.]ru/neco  
https://yrokistorii[.]ru/uqya  
https://stolevnica[.]ru/xjuf  
https://visokiykaf[.]ru/mntn  
https://kletkamozga[.]ru/iwqq</code></pre>
<p>This example highlights how the nightMARE library can be used for binary analysis, specifically, for extracting the configuration from the LUMMA stealer.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="download-nightmare" class="absolute -top-32"></span>Download nightMARE</h2>
<p>The complete implementation of the code presented in this article is <a href="https://github.com/elastic/nightMARE/blob/main/nightMARE/malware/lumma/configuration.py">available here</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="conclusion" class="absolute -top-32"></span>Conclusion</h2>
<p>nightMARE is a versatile Python module, based on the best tools the open source community has to offer. With the release of version 0.16 and this short article, we hope to have demonstrated its capabilities and potential.</p>
<p>Internally, the project is at the heart of various even more ambitious projects, and we will continue to maintain nightMARE to the best of our abilities.</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/nightmare-on-0xelm-street#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/nightmare-on-0xelm-street#nightmare-features-tour"><span>nightMARE features&nbsp;tour</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/nightmare-on-0xelm-street#powered-by-rizin"><span>Powered by&nbsp;Rizin</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/nightmare-on-0xelm-street#project-structure"><span>Project&nbsp;structure</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/nightmare-on-0xelm-street#analysis-modules"><span>Analysis&nbsp;modules</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/nightmare-on-0xelm-street#reversing-module"><span>Reversing&nbsp;module</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-8" href="/security-labs/nightmare-on-0xelm-street#emulation-module"><span>Emulation&nbsp;module</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/nightmare-on-0xelm-street#malware-module"><span>Malware&nbsp;module</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="/security-labs/nightmare-on-0xelm-street#example-lumma-configuration-extraction"><span>Example: LUMMA&nbsp;configuration-&nbsp;extraction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="/security-labs/nightmare-on-0xelm-street#step-1-initializing-the-chacha20-context"><span>Step 1: Initializing the ChaCha20&nbsp;context</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=NightMARE on 0xelm Street, a guided tour&amp;url=https://www.elastic.co/security-labs/nightmare-on-0xelm-street" target="_blank" rel="noopener noreferrer" aria-label="Share this article on X" title="Share this article on X"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>X</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/nightmare-on-0xelm-street" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/nightmare-on-0xelm-street&amp;title=NightMARE on 0xelm Street, a guided tour" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/nightmare-on-0xelm-street&amp;title=NightMARE on 0xelm Street, a guided tour" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main><footer class="mt-auto text-xs md:text-sm"><div class="container py-6 flex flex-col md:flex-row gap-2 md:gap-0 justify-between items-center"><div class="text-zinc-300"><nav><ul class="flex space-x-4"><li><a class="hover:text-white font-medium" href="/security-labs/sitemap.xml">Sitemap</a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://elastic.co?utm_source=elastic-search-labs&amp;utm_medium=referral&amp;utm_campaign=search-labs&amp;utm_content=footer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="inline-block w-3 h-3"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg><span>Elastic.co</span></a></li><li><a class="hover:text-white font-medium flex items-center space-x-1" href="https://twitter.com/elasticseclabs"><svg class="w-4 h-4 inline-block w-3 h-3" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>@elasticseclabs</span></a></li></ul></nav></div><div class="flex flex-col space-y-1 text-zinc-300"><p>© <!-- -->2025<!-- -->. Elasticsearch B.V. All Rights Reserved.</p></div></div></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"NightMARE on 0xelm Street, a guided tour","slug":"nightmare-on-0xelm-street","date":"2025-10-14","description":"This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators.","image":"Security Labs Images 31.jpg","body":{"raw":"\n## Introduction\n\nSince the creation of Elastic Security Labs, we have focused on developing malware analysis tools to not only aid in our research and analysis, but also to release to the public. We want to give back to the community and give back as much as we get from it. In an effort to make these tools more robust and reduce code duplication, we created the Python library [nightMARE](https://github.com/elastic/nightMARE). This library brings together various useful features for reverse engineering and malware analysis. We primarily use it to create our configuration extractors for different widespread malware families, but nightMARE is a library that can be applied to multiple use cases.\n\nWith the release of version 0.16, we want to officially introduce the library and provide details in this article on some interesting features offered by this module, as well as a short tutorial explaining how to use it to implement your own configuration extractor compatible with the latest version of LUMMA (as of the post date).\n\n## nightMARE features tour\n\n### Powered by Rizin\n\nTo reproduce the capabilities of popular disassemblers, nightMARE initially used a set of Python modules to perform the various tasks necessary for static analysis. For example, we used [LIEF](https://github.com/lief-project/LIEF) for executable parsing (PE, ELF), [Capstone](https://github.com/capstone-engine/capstone) to disassemble binaries, and [SMDA](https://github.com/danielplohmann/smda) to obtain cross-reference (xref) analysis.\n\nThese numerous dependencies made maintaining the library more complex than necessary. That's why, in order to reduce the use of third-party modules as much as possible, we decided to use the most comprehensive reverse engineering framework available. Our choice naturally gravitated towards Rizin.\n\n[Rizin](https://github.com/rizinorg/rizin) is an open-source reverse engineering software, forked from the Radare2 project. Its speed, modular design, and almost infinite set of features based on its Vim-like commands make it an excellent backend choice. We integrated it into the project using the [rz-pipe](https://github.com/rizinorg/rz-pipe) module, which makes it very easy to create and instrument a Rizin instance from Python.\n\n### Project structure\n\n![Project structure](/assets/images/nightmare-on-0xelm-street/image12.png)\n\nThe project is structured along three axes:\n\n* The \"analysis\" module contains sub-modules useful for static analysis.  \n* The \"core\" module contains commonly useful sub-modules: bitwise operations, integer casting, and recurring regexes for configuration extraction.  \n* The \"malware\" module contains all algorithm implementations (crypto, unpacking, configuration extraction, etc.), grouped by malware family and, when applicable, by version.\n\n### Analysis modules\n\nFor static binary analysis, this module offers two complementary working techniques: disassembly and instruction analysis with Rizin via the reversing module, and instruction emulation via the emulation module.\n\nFor example, when constants are manually moved onto the stack, instead of trying to analyze the instructions one by one to retrieve the immediates, it is possible to emulate the entire piece of code and read the data on the stack once the processing is done.\n\n![LUMMA manually pushes Steam profile data for decryption](/assets/images/nightmare-on-0xelm-street/image6.png)\n\nAnother example that we will see later in this article is that, in the case of cryptographic functions, if it is complex, it is often simpler to directly call it in the binary using emulation than to try to implement it manually.\n\n![Calling LUMMA C2 decryption function](/assets/images/nightmare-on-0xelm-street/image10.png)\n\n#### Reversing module\n\nThis module contains the Rizin class, which is an abstraction of Rizin's functionalities that send commands directly to Rizin thanks to `rz-pipe` and offers the user an incredible amount of analysis power for free. Because it’s an abstraction, the functions that the class exposes can be easily used in a script without prior knowledge of the framework. \n\nAlthough this class exposes a lot of different features, we are not trying to be exhaustive. The goal is to reduce duplicated code for recurring functionalities across all our tools. However, if a user finds that a function is missing, they can directly interact with the `rz-pipe` object to send commands to Rizin and achieve their goals.\n\nHere is a short list of the functions we use the most:\n\n```py\n# Disassembling\ndef disassemble(self, offset: int, size: int) -\u003e list[dict[str, typing.Any]]\ndef disassemble_previous_instruction(self, offset: int) -\u003e dict[str, typing.Any]\ndef disassemble_next_instruction(self, offset: int) -\u003e dict[str, typing.Any]\n\n# Pattern matching\ndef find_pattern(\n    self, \n    pattern: str,\n    pattern_type: Rizin.PatternType) -\u003e list[dict[str, typing.Any]]\ndef find_first_pattern(\n    self,\n    patterns: list[str],\n    pattern_type: Rizin.PatternType) -\u003e int\n\n# Reading bytes\ndef get_data(self, offset: int, size: int | None = None) -\u003e bytes\ndef get_string(self, offset: int) -\u003e bytes\n\n# Reading words\ndef get_u8(self, offset: int) -\u003e int\n...\ndef get_u64(self, offset: int) -\u003e int\n\n# All strings, functions\ndef get_strings(self) -\u003e list[dict[str, typing.Any]]\ndef get_functions(self) -\u003e list[dict[str, typing.Any]]\n\n# Xrefs\ndef get_xrefs_from(self, offset: int) -\u003e list\ndef get_xrefs_to(self, offset: int) -\u003e list[int]\n```\n\n#### Emulation module\n\nIn version 0.16, we reworked the emulation module to take full advantage of Rizin's capabilities to perform its various data-related tasks. Under the hood, it’s using the [Unicorn engine](https://www.unicorn-engine.org/) to perform emulation.\n\nFor now, this module only offers a \"light\" PE emulation with the class WindowsEmulator, light in the sense that only the strict minimum is done to load a PE. No relocations, no DLLs, no OS emulation. The goal is not to completely emulate a Windows executable like [Qiling](https://github.com/qilingframework/qiling) or [Sogen](https://github.com/momo5502/sogen), but to offer a simple way to execute code snippets or short sequences of functions while knowing its limitations.\n\nThe WindowsEmulator class offers several useful abstractions.\n\n```py\n# Load PE and its stack\ndef load_pe(self, pe: bytes, stack_size: int) -\u003e None\n\n# Manipulate stack\ndef push(self, x: int) -\u003e None\ndef pop(self) -\u003e int\n\n# Simple memory management mechanisms\ndef allocate_memory(self, size: int) -\u003e int\ndef free_memory(self, address: int, size: int) -\u003e None\n\n# Direct ip and sp manipulation\n@property\ndef ip(self) -\u003e int\n@property\ndef sp(self) -\u003e int\n\n# Emulate call and ret\ndef do_call(self, address: int, return_address: int) -\u003e None\ndef do_return(self, cleaning_size: int = 0) -\u003e None\n\n# Direct unicorn access\n@property\ndef unicorn(self) -\u003e unicorn.Uc\n```\n\nThe class allows the registration of two types of hooks: normal unicorn hooks and IAT hooks.\n\n```py\n# Set unicorn hooks, however the WindowsEmulator instance get passed to the callback instead of unicorn\ndef set_hook(self, hook_type: int, hook: typing.Callable) -\u003e int:\n\n# Set hook on import call\ndef enable_iat_hooking(self) -\u003e None:\ndef set_iat_hook(\n        self,\n        function_name: bytes,\n        hook: typing.Callable[[WindowsEmulator, tuple, dict[str, typing.Any]], None],\n) -\u003e None:\n```\n\nAs a usage example, we use the Windows binary [`DismHost.exe`](https://www.virustotal.com/gui/file/e36bcf02bc11f560761e943d0fad37417078f6cbb473f85c72fcbc89e2600c58) .\n\nThe binary uses the Sleep import at address `0x140006404`:\n\n![DimHost.exe calls Kernel32 Sleep +0x6404](/assets/images/nightmare-on-0xelm-street/image3.png)\n\nWe will therefore create a script that registers an IAT hook for the Sleep import, starts the emulation execution at address `0x140006404`, and ends at address `0x140006412`.\n\n```py\n# coding: utf-8\n\nimport pathlib\n\nfrom nightMARE.analysis import emulation\n\n\ndef sleep_hook(emu: emulation.WindowsEmulator, *args) -\u003e None:\n    print(\n        \"Sleep({} ms)\".format(\n            emu.unicorn.reg_read(emulation.unicorn.x86_const.UC_X86_REG_RCX)\n        ),\n    )\n    emu.do_return()\n\n\ndef main() -\u003e None:\n    path = pathlib.Path(r\"C:\\Windows\\System32\\Dism\\DismHost.exe\")\n    emu = emulation.WindowsEmulator(False)\n    emu.load_pe(path.read_bytes(), 0x10000)\n    emu.enable_iat_hooking()\n    emu.set_iat_hook(\"KERNEL32.dll!Sleep\", sleep_hook)\n    emu.unicorn.emu_start(0x140006404, 0x140006412)\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\nIt is important to note that the hook function must necessarily return with the `do_return` function so that we can reach the address located after the call.\n\nWhen the emulator starts, our hook is correctly executed.\n\n![Sleep hook execution](/assets/images/nightmare-on-0xelm-street/image1.png)\n\n### Malware module\n\nThe malware module contains all the algorithm implementations for each malware family we cover. These algorithms can cover configuration extraction, cryptographic functions, or sample unpacking, depending on the type of malware. All these algorithms use the functionalities of the analysis module to do their job and provide good examples of how to use the library.\n\nWith the release of v0.16, here are the different malware families that we cover.\n\n```\nblister\ndeprecated\nghostpulse\nlatrodectus\nlobshot\nlumma\nnetwire\nredlinestealer\nremcos\nsmokeloader\nstealc\nstrelastealer\nxorddos\n```\n\nThe complete implementation of the LUMMA algorithms we cover in the next chapter tutorial can be found under the LUMMA sub-module.\n\nPlease take note that the rapidly evolving nature of malware makes maintaining these modules difficult, but we welcome any help to the project, direct contribution, or opening issues.\n\n## Example: LUMMA configuration-extraction\n\nLUMMA STEALER, also known as LUMMAC2, is an information-stealing malware still widely used in infection campaigns despite a recent takedown operation in May 2025\\. This malware incorporates control flow obfuscation and data encryption, making it more challenging to analyze both statically and dynamically.\n\nIn this section, we will use the following unencrypted sample as reference: [26803ff0e079e43c413e10d9a62d344504a134d20ad37af9fd3eaf5c54848122](https://www.virustotal.com/gui/file/26803ff0e079e43c413e10d9a62d344504a134d20ad37af9fd3eaf5c54848122)\n\nWe do a short analysis of how it decrypts its domain names step by step, and then demonstrate along the way how we build the configuration extractor using nightMARE.\n\n### Step 1: Initializing the ChaCha20 context\n\nIn this version, LUMMA performs the initialization of its cryptographic context after loading `WinHTTP.dll`, with the decryption key and nonce; this context will be reused for each call to the `ChaCha20` decryption function without being reinitialized. The nuance here is that an internal counter within the context is updated with each use, so later we’ll need to take into account the value of this counter before the first domain decryption and then decrypt them in the correct order.\n\n![](/assets/images/nightmare-on-0xelm-street/image2.png)  \n![LUMMA initialize its ChaCha20 context with key and nonce +0xDC0D](/assets/images/nightmare-on-0xelm-street/image8.png)\n\nTo reproduce this step in our script, we need to collect the key and nonce. The problem is that we don't know their location in advance, but we know where they are used. We pattern match this part of the code, then extract the addresses `g_key_0 (key)` and `g_key_1 (nonce)` from the instructions.\n\n```py\nCRYPTO_SETUP_PATTERN = \"b838?24400b???????00b???0???0096f3a5\"\n\ndef get_decryption_key_and_nonce(binary: bytes) -\u003e tuple[bytes, bytes]:\n    # Load the binary in Rizin\n    rz = reversing.Rizin.load(binary)\n\n    # Find the virtual address of the pattern\n    if not (\n        x := rz.find_pattern(\n            CRYPTO_SETUP_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN\n        )\n    ):\n        raise RuntimeError(\"Failed to find crypto setup pattern virtual address\")\n\n    # Extract the key and nonce address from the instruction second operand\n    crypto_setup_va = x[0][\"address\"]\n    key_and_nonce_address = rz.disassemble(crypto_setup_va, 1)[0][\"opex\"][\"operands\"][\n        1\n    ][\"value\"]\n\n    # Return the key and nonce data\n    return rz.get_data(key_and_nonce_address, CHACHA20_KEY_SIZE), rz.get_data(\n        key_and_nonce_address + CHACHA20_KEY_SIZE, CHACHA20_NONCE_SIZE\n    )\n\ndef build_crypto_context(key: bytes, nonce: bytes, initial_counter: int) -\u003e bytes:\n    crypto_context = bytearray(0x40)\n    crypto_context[0x10:0x30] = key\n    crypto_context[0x30] = initial_counter\n    crypto_context[0x38:0x40] = nonce\n    return bytes(crypto_context)\n```\n\n### Step 2: Locate the decryption function\n\nIn this version, LUMMA's decryption function is easily located across samples as it is utilized immediately after loading WinHTTP imports.\n\n![LUMMA calls for the first time the decryption function +0xdd82](/assets/images/nightmare-on-0xelm-street/image5.png)\n\nWe derive the hex pattern from the first bytes of the function to locate it in our script:\n\n```py\nDECRYPTION_FUNCTION_PATTERN = \"5553575681ec1?0100008b??243?01000085??0f84??080000\"\n\ndef get_decryption_function_address(binary) -\u003e int:\n    # A cache system exist so the binary is only loaded once, then we get the same instance of Rizin :)\n    if x := reversing.Rizin.load(binary: bytes).find_pattern(\n        DECRYPTION_FUNCTION_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN\n    ):\n        return x[0][\"address\"]\n    raise RuntimeError(\"Failed to find decryption function address\")\n```\n\n### Step 3: Locate the encrypted domain's base address\n\nBy using xrefs from the decryption function, which is not called with obfuscated indirection like other LUMMA functions, we can easily find where it is called to decrypt the domains.\n\n![LUMMA domain decryption location +0xF468](/assets/images/nightmare-on-0xelm-street/image7.png)\n\nAs with the first step, we will use the instructions to discover the base address of the encrypted domains in the binary:\n\n![LUMMA loads domain base address in the eax register +0xF476](/assets/images/nightmare-on-0xelm-street/image11.png)\n\n```py\nC2_LIST_MAX_LENGTH = 0xFF\nC2_SIZE = 0x80\nC2_DECRYPTION_BRANCH_PATTERN = \"8d8?e0?244008d7424??ff3?565?68????4500e8????ffff\"\n\ndef get_encrypted_c2_list(binary: bytes) -\u003e list[bytes]:\n    rz = reversing.Rizin.load(binary)\n    address = get_encrypted_c2_list_address(binary)\n    encrypted_c2 = []\n    for ea in range(address, address + (C2_LIST_MAX_LENGTH * C2_SIZE), C2_SIZE):\n        encrypted_c2.append(rz.get_data(ea, C2_SIZE))\n    return encrypted_c2\n\n\ndef get_encrypted_c2_list_address(binary: bytes) -\u003e int:\n    rz = reversing.Rizin.load(binary)\n    if not len(\n        x := rz.find_pattern(\n            C2_DECRYPTION_BRANCH_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN\n        )\n    ):\n        raise RuntimeError(\"Failed to find c2 decryption pattern\")\n\n    c2_decryption_va = x[0][\"address\"]\n    return rz.disassemble(c2_decryption_va, 1)[0][\"opex\"][\"operands\"][1][\"disp\"]\n```\n\n### Step 4: Decrypt domains using emulation\n\nA quick analysis of the decryption function shows that this version of LUMMA uses a slightly customized version of `ChaCha20`. We recognize the same small and diverse decryption functions scattered throughout the binaries. Here, they are used to decrypt parts of the `ChaCha20` \"expand 32-byte k\" constant, which are then XOR-ROL derived before being stored in the context structure.\n\n![LUMMA decrypting/reencrypting the “expand 32-byte k” constant +0xC6CE](/assets/images/nightmare-on-0xelm-street/image4.png)\n\nWhile we could implement the decryption function in our script, we have all the necessary addresses to demonstrate how we can directly call the function already present in the binary to decrypt our domains, using nightMARE's emulation module.\n\n```py\n# We need the right initial value, before decrypting the domain\n# the function is already called once so 0 -\u003e 2\nCHACHA20_INITIAL_COUNTER = 2\n\ndef decrypt_c2_list(\n    binary: bytes, encrypted_c2_list: list[bytes], key: bytes, nonce: bytes\n) -\u003e list[bytes]:\n    # Get the decryption function address (step 2)\n    decryption_function_address = get_decryption_function_address(binary)\n\n    # Load the emulator, True = 32bits\n    emu = emulation.WindowsEmulator(True)\n \n    # Load the PE in the emulator with a stack of 0x10000 bytes\n    emu.load_pe(binary, 0x10000)\n    \n    # Allocate the chacha context\n    chacha_ctx_address = emu.allocate_memory(CHACHA20_CTX_SIZE)\n    \n    # Write at the chacha context address the crypto context\n    emu.unicorn.mem_write(\n        chacha_ctx_address,\n        build_crypto_context(\n            key,\n            nonce,\n            CHACHA20_INITIAL_COUNTER, \n        ),\n    )\n\n    decrypted_c2_list = []\n    for encrypted_c2 in encrypted_c2_list:\n\t # Allocate buffers\n        encrypted_buffer_address = emu.allocate_memory(C2_SIZE)\n        decrypted_buffer_address = emu.allocate_memory(C2_SIZE)\n        \n        # Write encrypted c2 to buffer\n        emu.unicorn.mem_write(encrypted_buffer_address, encrypted_c2)\n\n        # Push arguments\n        emu.push(C2_SIZE)\n        emu.push(decrypted_buffer_address)\n        emu.push(encrypted_buffer_address)\n        emu.push(chacha_ctx_address)\n \n        # Emulate a call\n        emu.do_call(decryption_function_address, emu.image_base)\n\n        # Fire!\n        emu.unicorn.emu_start(decryption_function_address, emu.image_base)\n\n        # Read result from decrypted buffer\n        decrypted_c2 = bytes(\n            emu.unicorn.mem_read(decrypted_buffer_address, C2_SIZE)\n        ).split(b\"\\x00\")[0]\n\n        # If result isn't printable we stop, no more domain\n        if not bytes_re.PRINTABLE_STRING_REGEX.match(decrypted_c2):\n            break\n\n        # Add result to the list\n        decrypted_c2_list.append(b\"https://\" + decrypted_c2)\n\n        # Clean up the args\n        emu.pop()\n        emu.pop()\n        emu.pop()\n        emu.pop()\n\n        # Free buffers\n        emu.free_memory(encrypted_buffer_address, C2_SIZE)\n        emu.free_memory(decrypted_buffer_address, C2_SIZE)\n\n       # Repeat for the next one ...\n\n    return decrypted_c2_list\n```\n\n### Result\n\nFinally, we can run our module with `pytest` and view the LUMMA C2 list (`decrypted_c2_list`):\n\n![Pytest execution result](/assets/images/nightmare-on-0xelm-street/image9.png)\n\n```\nhttps://mocadia[.]com/iuew  \nhttps://mastwin[.]in/qsaz  \nhttps://ordinarniyvrach[.]ru/xiur  \nhttps://yamakrug[.]ru/lzka  \nhttps://vishneviyjazz[.]ru/neco  \nhttps://yrokistorii[.]ru/uqya  \nhttps://stolevnica[.]ru/xjuf  \nhttps://visokiykaf[.]ru/mntn  \nhttps://kletkamozga[.]ru/iwqq \n```\n\nThis example highlights how the nightMARE library can be used for binary analysis, specifically, for extracting the configuration from the LUMMA stealer.\n\n## Download nightMARE\n\nThe complete implementation of the code presented in this article is [available here](https://github.com/elastic/nightMARE/blob/main/nightMARE/malware/lumma/configuration.py).\n\n## Conclusion\n\nnightMARE is a versatile Python module, based on the best tools the open source community has to offer. With the release of version 0.16 and this short article, we hope to have demonstrated its capabilities and potential.\n\nInternally, the project is at the heart of various even more ambitious projects, and we will continue to maintain nightMARE to the best of our abilities.\n","code":"var Component=(()=\u003e{var u=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),_=(t,e)=\u003e{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,o)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!y.call(t,r)\u0026\u0026r!==i\u0026\u0026a(t,r,{get:()=\u003ee[r],enumerable:!(o=p(e,r))||o.enumerable});return t};var b=(t,e,i)=\u003e(i=t!=null?u(f(t)):{},s(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=\u003es(a({},\"__esModule\",{value:!0}),t);var c=g((k,l)=\u003e{l.exports=_jsx_runtime});var E={};_(E,{default:()=\u003eh,frontmatter:()=\u003ex});var n=b(c()),x={title:\"NightMARE on 0xelm Street, a guided tour\",slug:\"nightmare-on-0xelm-street\",date:\"2025-10-14\",description:\"This article describes nightMARE, a python-based library for malware researchers that was developed by Elastic Security Labs to help scale analysis. It describes how we use nightMARE to develop malware configuration extractors and carve out intelligence indicators.\",author:[{slug:\"cyril-francois\"}],image:\"Security Labs Images 31.jpg\",category:[{slug:\"malware-analysis\"},{slug:\"security-research\"}]};function d(t){let e={a:\"a\",br:\"br\",code:\"code\",h2:\"h2\",h3:\"h3\",h4:\"h4\",img:\"img\",li:\"li\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{id:\"introduction\",children:\"Introduction\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since the creation of Elastic Security Labs, we have focused on developing malware analysis tools to not only aid in our research and analysis, but also to release to the public. We want to give back to the community and give back as much as we get from it. In an effort to make these tools more robust and reduce code duplication, we created the Python library \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/nightMARE\",rel:\"nofollow\",children:\"nightMARE\"}),\". This library brings together various useful features for reverse engineering and malware analysis. We primarily use it to create our configuration extractors for different widespread malware families, but nightMARE is a library that can be applied to multiple use cases.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"With the release of version 0.16, we want to officially introduce the library and provide details in this article on some interesting features offered by this module, as well as a short tutorial explaining how to use it to implement your own configuration extractor compatible with the latest version of LUMMA (as of the post date).\"}),`\n`,(0,n.jsx)(e.h2,{id:\"nightmare-features-tour\",children:\"nightMARE features tour\"}),`\n`,(0,n.jsx)(e.h3,{id:\"powered-by-rizin\",children:\"Powered by Rizin\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To reproduce the capabilities of popular disassemblers, nightMARE initially used a set of Python modules to perform the various tasks necessary for static analysis. For example, we used \",(0,n.jsx)(e.a,{href:\"https://github.com/lief-project/LIEF\",rel:\"nofollow\",children:\"LIEF\"}),\" for executable parsing (PE, ELF), \",(0,n.jsx)(e.a,{href:\"https://github.com/capstone-engine/capstone\",rel:\"nofollow\",children:\"Capstone\"}),\" to disassemble binaries, and \",(0,n.jsx)(e.a,{href:\"https://github.com/danielplohmann/smda\",rel:\"nofollow\",children:\"SMDA\"}),\" to obtain cross-reference (xref) analysis.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"These numerous dependencies made maintaining the library more complex than necessary. That's why, in order to reduce the use of third-party modules as much as possible, we decided to use the most comprehensive reverse engineering framework available. Our choice naturally gravitated towards Rizin.\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://github.com/rizinorg/rizin\",rel:\"nofollow\",children:\"Rizin\"}),\" is an open-source reverse engineering software, forked from the Radare2 project. Its speed, modular design, and almost infinite set of features based on its Vim-like commands make it an excellent backend choice. We integrated it into the project using the \",(0,n.jsx)(e.a,{href:\"https://github.com/rizinorg/rz-pipe\",rel:\"nofollow\",children:\"rz-pipe\"}),\" module, which makes it very easy to create and instrument a Rizin instance from Python.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"project-structure\",children:\"Project structure\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image12.png\",alt:\"Project structure\",width:\"500\",height:\"530\"})}),`\n`,(0,n.jsx)(e.p,{children:\"The project is structured along three axes:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:'The \"analysis\" module contains sub-modules useful for static analysis.'}),`\n`,(0,n.jsx)(e.li,{children:'The \"core\" module contains commonly useful sub-modules: bitwise operations, integer casting, and recurring regexes for configuration extraction.'}),`\n`,(0,n.jsx)(e.li,{children:'The \"malware\" module contains all algorithm implementations (crypto, unpacking, configuration extraction, etc.), grouped by malware family and, when applicable, by version.'}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"analysis-modules\",children:\"Analysis modules\"}),`\n`,(0,n.jsx)(e.p,{children:\"For static binary analysis, this module offers two complementary working techniques: disassembly and instruction analysis with Rizin via the reversing module, and instruction emulation via the emulation module.\"}),`\n`,(0,n.jsx)(e.p,{children:\"For example, when constants are manually moved onto the stack, instead of trying to analyze the instructions one by one to retrieve the immediates, it is possible to emulate the entire piece of code and read the data on the stack once the processing is done.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image6.png\",alt:\"LUMMA manually pushes Steam profile data for decryption\",width:\"786\",height:\"157\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Another example that we will see later in this article is that, in the case of cryptographic functions, if it is complex, it is often simpler to directly call it in the binary using emulation than to try to implement it manually.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image10.png\",alt:\"Calling LUMMA C2 decryption function\",width:\"616\",height:\"135\"})}),`\n`,(0,n.jsx)(e.h4,{id:\"reversing-module\",children:\"Reversing module\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This module contains the Rizin class, which is an abstraction of Rizin's functionalities that send commands directly to Rizin thanks to \",(0,n.jsx)(e.code,{children:\"rz-pipe\"}),\" and offers the user an incredible amount of analysis power for free. Because it\\u2019s an abstraction, the functions that the class exposes can be easily used in a script without prior knowledge of the framework.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Although this class exposes a lot of different features, we are not trying to be exhaustive. The goal is to reduce duplicated code for recurring functionalities across all our tools. However, if a user finds that a function is missing, they can directly interact with the \",(0,n.jsx)(e.code,{children:\"rz-pipe\"}),\" object to send commands to Rizin and achieve their goals.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Here is a short list of the functions we use the most:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`# Disassembling\ndef disassemble(self, offset: int, size: int) -\u003e list[dict[str, typing.Any]]\ndef disassemble_previous_instruction(self, offset: int) -\u003e dict[str, typing.Any]\ndef disassemble_next_instruction(self, offset: int) -\u003e dict[str, typing.Any]\n\n# Pattern matching\ndef find_pattern(\n    self, \n    pattern: str,\n    pattern_type: Rizin.PatternType) -\u003e list[dict[str, typing.Any]]\ndef find_first_pattern(\n    self,\n    patterns: list[str],\n    pattern_type: Rizin.PatternType) -\u003e int\n\n# Reading bytes\ndef get_data(self, offset: int, size: int | None = None) -\u003e bytes\ndef get_string(self, offset: int) -\u003e bytes\n\n# Reading words\ndef get_u8(self, offset: int) -\u003e int\n...\ndef get_u64(self, offset: int) -\u003e int\n\n# All strings, functions\ndef get_strings(self) -\u003e list[dict[str, typing.Any]]\ndef get_functions(self) -\u003e list[dict[str, typing.Any]]\n\n# Xrefs\ndef get_xrefs_from(self, offset: int) -\u003e list\ndef get_xrefs_to(self, offset: int) -\u003e list[int]\n`})}),`\n`,(0,n.jsx)(e.h4,{id:\"emulation-module\",children:\"Emulation module\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In version 0.16, we reworked the emulation module to take full advantage of Rizin's capabilities to perform its various data-related tasks. Under the hood, it\\u2019s using the \",(0,n.jsx)(e.a,{href:\"https://www.unicorn-engine.org/\",rel:\"nofollow\",children:\"Unicorn engine\"}),\" to perform emulation.\"]}),`\n`,(0,n.jsxs)(e.p,{children:['For now, this module only offers a \"light\" PE emulation with the class WindowsEmulator, light in the sense that only the strict minimum is done to load a PE. No relocations, no DLLs, no OS emulation. The goal is not to completely emulate a Windows executable like ',(0,n.jsx)(e.a,{href:\"https://github.com/qilingframework/qiling\",rel:\"nofollow\",children:\"Qiling\"}),\" or \",(0,n.jsx)(e.a,{href:\"https://github.com/momo5502/sogen\",rel:\"nofollow\",children:\"Sogen\"}),\", but to offer a simple way to execute code snippets or short sequences of functions while knowing its limitations.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The WindowsEmulator class offers several useful abstractions.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`# Load PE and its stack\ndef load_pe(self, pe: bytes, stack_size: int) -\u003e None\n\n# Manipulate stack\ndef push(self, x: int) -\u003e None\ndef pop(self) -\u003e int\n\n# Simple memory management mechanisms\ndef allocate_memory(self, size: int) -\u003e int\ndef free_memory(self, address: int, size: int) -\u003e None\n\n# Direct ip and sp manipulation\n@property\ndef ip(self) -\u003e int\n@property\ndef sp(self) -\u003e int\n\n# Emulate call and ret\ndef do_call(self, address: int, return_address: int) -\u003e None\ndef do_return(self, cleaning_size: int = 0) -\u003e None\n\n# Direct unicorn access\n@property\ndef unicorn(self) -\u003e unicorn.Uc\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The class allows the registration of two types of hooks: normal unicorn hooks and IAT hooks.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`# Set unicorn hooks, however the WindowsEmulator instance get passed to the callback instead of unicorn\ndef set_hook(self, hook_type: int, hook: typing.Callable) -\u003e int:\n\n# Set hook on import call\ndef enable_iat_hooking(self) -\u003e None:\ndef set_iat_hook(\n        self,\n        function_name: bytes,\n        hook: typing.Callable[[WindowsEmulator, tuple, dict[str, typing.Any]], None],\n) -\u003e None:\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As a usage example, we use the Windows binary \",(0,n.jsx)(e.a,{href:\"https://www.virustotal.com/gui/file/e36bcf02bc11f560761e943d0fad37417078f6cbb473f85c72fcbc89e2600c58\",rel:\"nofollow\",children:(0,n.jsx)(e.code,{children:\"DismHost.exe\"})}),\" .\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary uses the Sleep import at address \",(0,n.jsx)(e.code,{children:\"0x140006404\"}),\":\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image3.png\",alt:\"DimHost.exe calls Kernel32 Sleep +0x6404\",width:\"443\",height:\"74\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will therefore create a script that registers an IAT hook for the Sleep import, starts the emulation execution at address \",(0,n.jsx)(e.code,{children:\"0x140006404\"}),\", and ends at address \",(0,n.jsx)(e.code,{children:\"0x140006412\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`# coding: utf-8\n\nimport pathlib\n\nfrom nightMARE.analysis import emulation\n\n\ndef sleep_hook(emu: emulation.WindowsEmulator, *args) -\u003e None:\n    print(\n        \"Sleep({} ms)\".format(\n            emu.unicorn.reg_read(emulation.unicorn.x86_const.UC_X86_REG_RCX)\n        ),\n    )\n    emu.do_return()\n\n\ndef main() -\u003e None:\n    path = pathlib.Path(r\"C:\\\\Windows\\\\System32\\\\Dism\\\\DismHost.exe\")\n    emu = emulation.WindowsEmulator(False)\n    emu.load_pe(path.read_bytes(), 0x10000)\n    emu.enable_iat_hooking()\n    emu.set_iat_hook(\"KERNEL32.dll!Sleep\", sleep_hook)\n    emu.unicorn.emu_start(0x140006404, 0x140006412)\n\n\nif __name__ == \"__main__\":\n    main()\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It is important to note that the hook function must necessarily return with the \",(0,n.jsx)(e.code,{children:\"do_return\"}),\" function so that we can reach the address located after the call.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"When the emulator starts, our hook is correctly executed.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image1.png\",alt:\"Sleep hook execution\",width:\"564\",height:\"112\"})}),`\n`,(0,n.jsx)(e.h3,{id:\"malware-module\",children:\"Malware module\"}),`\n`,(0,n.jsx)(e.p,{children:\"The malware module contains all the algorithm implementations for each malware family we cover. These algorithms can cover configuration extraction, cryptographic functions, or sample unpacking, depending on the type of malware. All these algorithms use the functionalities of the analysis module to do their job and provide good examples of how to use the library.\"}),`\n`,(0,n.jsx)(e.p,{children:\"With the release of v0.16, here are the different malware families that we cover.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`blister\ndeprecated\nghostpulse\nlatrodectus\nlobshot\nlumma\nnetwire\nredlinestealer\nremcos\nsmokeloader\nstealc\nstrelastealer\nxorddos\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The complete implementation of the LUMMA algorithms we cover in the next chapter tutorial can be found under the LUMMA sub-module.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Please take note that the rapidly evolving nature of malware makes maintaining these modules difficult, but we welcome any help to the project, direct contribution, or opening issues.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"example-lumma-configuration-extraction\",children:\"Example: LUMMA configuration-extraction\"}),`\n`,(0,n.jsx)(e.p,{children:\"LUMMA STEALER, also known as LUMMAC2, is an information-stealing malware still widely used in infection campaigns despite a recent takedown operation in May 2025. This malware incorporates control flow obfuscation and data encryption, making it more challenging to analyze both statically and dynamically.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this section, we will use the following unencrypted sample as reference: \",(0,n.jsx)(e.a,{href:\"https://www.virustotal.com/gui/file/26803ff0e079e43c413e10d9a62d344504a134d20ad37af9fd3eaf5c54848122\",rel:\"nofollow\",children:\"26803ff0e079e43c413e10d9a62d344504a134d20ad37af9fd3eaf5c54848122\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"We do a short analysis of how it decrypts its domain names step by step, and then demonstrate along the way how we build the configuration extractor using nightMARE.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"step-1-initializing-the-chacha20-context\",children:\"Step 1: Initializing the ChaCha20 context\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this version, LUMMA performs the initialization of its cryptographic context after loading \",(0,n.jsx)(e.code,{children:\"WinHTTP.dll\"}),\", with the decryption key and nonce; this context will be reused for each call to the \",(0,n.jsx)(e.code,{children:\"ChaCha20\"}),\" decryption function without being reinitialized. The nuance here is that an internal counter within the context is updated with each use, so later we\\u2019ll need to take into account the value of this counter before the first domain decryption and then decrypt them in the correct order.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image2.png\",alt:\"\",width:\"703\",height:\"105\"}),(0,n.jsx)(e.br,{}),`\n`,(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image8.png\",alt:\"LUMMA initialize its ChaCha20 context with key and nonce +0xDC0D\",width:\"813\",height:\"304\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To reproduce this step in our script, we need to collect the key and nonce. The problem is that we don't know their location in advance, but we know where they are used. We pattern match this part of the code, then extract the addresses \",(0,n.jsx)(e.code,{children:\"g_key_0 (key)\"}),\" and \",(0,n.jsx)(e.code,{children:\"g_key_1 (nonce)\"}),\" from the instructions.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`CRYPTO_SETUP_PATTERN = \"b838?24400b???????00b???0???0096f3a5\"\n\ndef get_decryption_key_and_nonce(binary: bytes) -\u003e tuple[bytes, bytes]:\n    # Load the binary in Rizin\n    rz = reversing.Rizin.load(binary)\n\n    # Find the virtual address of the pattern\n    if not (\n        x := rz.find_pattern(\n            CRYPTO_SETUP_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN\n        )\n    ):\n        raise RuntimeError(\"Failed to find crypto setup pattern virtual address\")\n\n    # Extract the key and nonce address from the instruction second operand\n    crypto_setup_va = x[0][\"address\"]\n    key_and_nonce_address = rz.disassemble(crypto_setup_va, 1)[0][\"opex\"][\"operands\"][\n        1\n    ][\"value\"]\n\n    # Return the key and nonce data\n    return rz.get_data(key_and_nonce_address, CHACHA20_KEY_SIZE), rz.get_data(\n        key_and_nonce_address + CHACHA20_KEY_SIZE, CHACHA20_NONCE_SIZE\n    )\n\ndef build_crypto_context(key: bytes, nonce: bytes, initial_counter: int) -\u003e bytes:\n    crypto_context = bytearray(0x40)\n    crypto_context[0x10:0x30] = key\n    crypto_context[0x30] = initial_counter\n    crypto_context[0x38:0x40] = nonce\n    return bytes(crypto_context)\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"step-2-locate-the-decryption-function\",children:\"Step 2: Locate the decryption function\"}),`\n`,(0,n.jsx)(e.p,{children:\"In this version, LUMMA's decryption function is easily located across samples as it is utilized immediately after loading WinHTTP imports.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image5.png\",alt:\"LUMMA calls for the first time the decryption function +0xdd82\",width:\"786\",height:\"103\"})}),`\n`,(0,n.jsx)(e.p,{children:\"We derive the hex pattern from the first bytes of the function to locate it in our script:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`DECRYPTION_FUNCTION_PATTERN = \"5553575681ec1?0100008b??243?01000085??0f84??080000\"\n\ndef get_decryption_function_address(binary) -\u003e int:\n    # A cache system exist so the binary is only loaded once, then we get the same instance of Rizin :)\n    if x := reversing.Rizin.load(binary: bytes).find_pattern(\n        DECRYPTION_FUNCTION_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN\n    ):\n        return x[0][\"address\"]\n    raise RuntimeError(\"Failed to find decryption function address\")\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"step-3-locate-the-encrypted-domains-base-address\",children:\"Step 3: Locate the encrypted domain's base address\"}),`\n`,(0,n.jsx)(e.p,{children:\"By using xrefs from the decryption function, which is not called with obfuscated indirection like other LUMMA functions, we can easily find where it is called to decrypt the domains.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image7.png\",alt:\"LUMMA domain decryption location +0xF468\",width:\"702\",height:\"118\"})}),`\n`,(0,n.jsx)(e.p,{children:\"As with the first step, we will use the instructions to discover the base address of the encrypted domains in the binary:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image11.png\",alt:\"LUMMA loads domain base address in the eax register +0xF476\",width:\"584\",height:\"117\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`C2_LIST_MAX_LENGTH = 0xFF\nC2_SIZE = 0x80\nC2_DECRYPTION_BRANCH_PATTERN = \"8d8?e0?244008d7424??ff3?565?68????4500e8????ffff\"\n\ndef get_encrypted_c2_list(binary: bytes) -\u003e list[bytes]:\n    rz = reversing.Rizin.load(binary)\n    address = get_encrypted_c2_list_address(binary)\n    encrypted_c2 = []\n    for ea in range(address, address + (C2_LIST_MAX_LENGTH * C2_SIZE), C2_SIZE):\n        encrypted_c2.append(rz.get_data(ea, C2_SIZE))\n    return encrypted_c2\n\n\ndef get_encrypted_c2_list_address(binary: bytes) -\u003e int:\n    rz = reversing.Rizin.load(binary)\n    if not len(\n        x := rz.find_pattern(\n            C2_DECRYPTION_BRANCH_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN\n        )\n    ):\n        raise RuntimeError(\"Failed to find c2 decryption pattern\")\n\n    c2_decryption_va = x[0][\"address\"]\n    return rz.disassemble(c2_decryption_va, 1)[0][\"opex\"][\"operands\"][1][\"disp\"]\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"step-4-decrypt-domains-using-emulation\",children:\"Step 4: Decrypt domains using emulation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A quick analysis of the decryption function shows that this version of LUMMA uses a slightly customized version of \",(0,n.jsx)(e.code,{children:\"ChaCha20\"}),\". We recognize the same small and diverse decryption functions scattered throughout the binaries. Here, they are used to decrypt parts of the \",(0,n.jsx)(e.code,{children:\"ChaCha20\"}),' \"expand 32-byte k\" constant, which are then XOR-ROL derived before being stored in the context structure.']}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image4.png\",alt:\"LUMMA decrypting/reencrypting the \\u201Cexpand 32-byte k\\u201D constant +0xC6CE\",width:\"706\",height:\"458\"})}),`\n`,(0,n.jsx)(e.p,{children:\"While we could implement the decryption function in our script, we have all the necessary addresses to demonstrate how we can directly call the function already present in the binary to decrypt our domains, using nightMARE's emulation module.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-py\",children:`# We need the right initial value, before decrypting the domain\n# the function is already called once so 0 -\u003e 2\nCHACHA20_INITIAL_COUNTER = 2\n\ndef decrypt_c2_list(\n    binary: bytes, encrypted_c2_list: list[bytes], key: bytes, nonce: bytes\n) -\u003e list[bytes]:\n    # Get the decryption function address (step 2)\n    decryption_function_address = get_decryption_function_address(binary)\n\n    # Load the emulator, True = 32bits\n    emu = emulation.WindowsEmulator(True)\n \n    # Load the PE in the emulator with a stack of 0x10000 bytes\n    emu.load_pe(binary, 0x10000)\n    \n    # Allocate the chacha context\n    chacha_ctx_address = emu.allocate_memory(CHACHA20_CTX_SIZE)\n    \n    # Write at the chacha context address the crypto context\n    emu.unicorn.mem_write(\n        chacha_ctx_address,\n        build_crypto_context(\n            key,\n            nonce,\n            CHACHA20_INITIAL_COUNTER, \n        ),\n    )\n\n    decrypted_c2_list = []\n    for encrypted_c2 in encrypted_c2_list:\n\t # Allocate buffers\n        encrypted_buffer_address = emu.allocate_memory(C2_SIZE)\n        decrypted_buffer_address = emu.allocate_memory(C2_SIZE)\n        \n        # Write encrypted c2 to buffer\n        emu.unicorn.mem_write(encrypted_buffer_address, encrypted_c2)\n\n        # Push arguments\n        emu.push(C2_SIZE)\n        emu.push(decrypted_buffer_address)\n        emu.push(encrypted_buffer_address)\n        emu.push(chacha_ctx_address)\n \n        # Emulate a call\n        emu.do_call(decryption_function_address, emu.image_base)\n\n        # Fire!\n        emu.unicorn.emu_start(decryption_function_address, emu.image_base)\n\n        # Read result from decrypted buffer\n        decrypted_c2 = bytes(\n            emu.unicorn.mem_read(decrypted_buffer_address, C2_SIZE)\n        ).split(b\"\\\\x00\")[0]\n\n        # If result isn't printable we stop, no more domain\n        if not bytes_re.PRINTABLE_STRING_REGEX.match(decrypted_c2):\n            break\n\n        # Add result to the list\n        decrypted_c2_list.append(b\"https://\" + decrypted_c2)\n\n        # Clean up the args\n        emu.pop()\n        emu.pop()\n        emu.pop()\n        emu.pop()\n\n        # Free buffers\n        emu.free_memory(encrypted_buffer_address, C2_SIZE)\n        emu.free_memory(decrypted_buffer_address, C2_SIZE)\n\n       # Repeat for the next one ...\n\n    return decrypted_c2_list\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"result\",children:\"Result\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Finally, we can run our module with \",(0,n.jsx)(e.code,{children:\"pytest\"}),\" and view the LUMMA C2 list (\",(0,n.jsx)(e.code,{children:\"decrypted_c2_list\"}),\"):\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/assets/images/nightmare-on-0xelm-street/image9.png\",alt:\"Pytest execution result\",width:\"1247\",height:\"175\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`https://mocadia[.]com/iuew  \nhttps://mastwin[.]in/qsaz  \nhttps://ordinarniyvrach[.]ru/xiur  \nhttps://yamakrug[.]ru/lzka  \nhttps://vishneviyjazz[.]ru/neco  \nhttps://yrokistorii[.]ru/uqya  \nhttps://stolevnica[.]ru/xjuf  \nhttps://visokiykaf[.]ru/mntn  \nhttps://kletkamozga[.]ru/iwqq \n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This example highlights how the nightMARE library can be used for binary analysis, specifically, for extracting the configuration from the LUMMA stealer.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"download-nightmare\",children:\"Download nightMARE\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The complete implementation of the code presented in this article is \",(0,n.jsx)(e.a,{href:\"https://github.com/elastic/nightMARE/blob/main/nightMARE/malware/lumma/configuration.py\",rel:\"nofollow\",children:\"available here\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"nightMARE is a versatile Python module, based on the best tools the open source community has to offer. With the release of version 0.16 and this short article, we hope to have demonstrated its capabilities and potential.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Internally, the project is at the heart of various even more ambitious projects, and we will continue to maintain nightMARE to the best of our abilities.\"})]})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(d,{...t})}):d(t)}return w(E);})();\n;return Component;"},"_id":"articles/nightmare-on-0xelm-street.mdx","_raw":{"sourceFilePath":"articles/nightmare-on-0xelm-street.mdx","sourceFileName":"nightmare-on-0xelm-street.mdx","sourceFileDir":"articles","contentType":"mdx","flattenedPath":"articles/nightmare-on-0xelm-street"},"type":"Article","imageUrl":"/assets/images/nightmare-on-0xelm-street/Security Labs Images 31.jpg","readingTime":"17 min read","series":"","url":"/nightmare-on-0xelm-street","headings":[{"level":2,"title":"Introduction","href":"#introduction"},{"level":2,"title":"nightMARE features tour","href":"#nightmare-features-tour"},{"level":3,"title":"Powered by Rizin","href":"#powered-by-rizin"},{"level":3,"title":"Project structure","href":"#project-structure"},{"level":3,"title":"Analysis modules","href":"#analysis-modules"},{"level":4,"title":"Reversing module","href":"#reversing-module"},{"level":4,"title":"Emulation module","href":"#emulation-module"},{"level":3,"title":"Malware module","href":"#malware-module"},{"level":2,"title":"Example: LUMMA configuration-extraction","href":"#example-lumma-configuration-extraction"},{"level":3,"title":"Step 1: Initializing the ChaCha20 context","href":"#step-1-initializing-the-chacha20-context"},{"level":3,"title":"Step 2: Locate the decryption function","href":"#step-2-locate-the-decryption-function"},{"level":3,"title":"Step 3: Locate the encrypted domain's base address","href":"#step-3-locate-the-encrypted-domains-base-address"},{"level":3,"title":"Step 4: Decrypt domains using emulation","href":"#step-4-decrypt-domains-using-emulation"},{"level":3,"title":"Result","href":"#result"},{"level":2,"title":"Download nightMARE","href":"#download-nightmare"},{"level":2,"title":"Conclusion","href":"#conclusion"}],"author":[{"title":"Cyril François","slug":"cyril-francois","description":"Elastic Security Labs Team Senior Research Engineer, Malware","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var p=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=\u003e{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,i)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let a of _(e))!g.call(t,a)\u0026\u0026a!==r\u0026\u0026o(t,a,{get:()=\u003ee[a],enumerable:!(i=f(e,a))||i.enumerable});return t};var M=(t,e,r)=\u003e(r=t!=null?x(d(t)):{},s(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),j=t=\u003es(o({},\"__esModule\",{value:!0}),t);var u=p((w,c)=\u003e{c.exports=_jsx_runtime});var F={};y(F,{default:()=\u003em,frontmatter:()=\u003eC});var n=M(u()),C={title:\"Cyril Fran\\xE7ois\",description:\"Elastic Security Labs Team Senior Research Engineer, Malware\",slug:\"cyril-francois\"};function l(t){return(0,n.jsx)(n.Fragment,{})}function m(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(l,{...t})}):l(t)}return j(F);})();\n;return Component;"},"_id":"authors/cyril-francois.mdx","_raw":{"sourceFilePath":"authors/cyril-francois.mdx","sourceFileName":"cyril-francois.mdx","sourceFileDir":"authors","contentType":"mdx","flattenedPath":"authors/cyril-francois"},"type":"Author","imageUrl":"","url":"/authors/cyril-francois"}],"category":[{"title":"Malware analysis","slug":"malware-analysis","body":{"raw":"","code":"var Component=(()=\u003e{var x=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var M=Object.getPrototypeOf,d=Object.prototype.hasOwnProperty;var g=(t,n)=\u003e()=\u003e(n||t((n={exports:{}}).exports,n),n.exports),j=(t,n)=\u003e{for(var e in n)o(t,e,{get:n[e],enumerable:!0})},i=(t,n,e,s)=\u003e{if(n\u0026\u0026typeof n==\"object\"||typeof n==\"function\")for(let a of _(n))!d.call(t,a)\u0026\u0026a!==e\u0026\u0026o(t,a,{get:()=\u003en[a],enumerable:!(s=f(n,a))||s.enumerable});return t};var p=(t,n,e)=\u003e(e=t!=null?x(M(t)):{},i(n||!t||!t.__esModule?o(e,\"default\",{value:t,enumerable:!0}):e,t)),w=t=\u003ei(o({},\"__esModule\",{value:!0}),t);var m=g((F,l)=\u003e{l.exports=_jsx_runtime});var C={};j(C,{default:()=\u003ec,frontmatter:()=\u003ey});var r=p(m()),y={title:\"Malware analysis\",slug:\"malware-analysis\"};function u(t){return(0,r.jsx)(r.Fragment,{})}function c(t={}){let{wrapper:n}=t.components||{};return n?(0,r.jsx)(n,{...t,children:(0,r.jsx)(u,{...t})}):u(t)}return w(C);})();\n;return Component;"},"_id":"categories/malware-analysis.mdx","_raw":{"sourceFilePath":"categories/malware-analysis.mdx","sourceFileName":"malware-analysis.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/malware-analysis"},"type":"Category","url":"/categories/malware-analysis"},{"title":"Security research","slug":"security-research","body":{"raw":"","code":"var Component=(()=\u003e{var f=Object.create;var a=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var l=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var h=(t,e)=\u003e()=\u003e(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=\u003e{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,c)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let o of l(e))!g.call(t,o)\u0026\u0026o!==r\u0026\u0026a(t,o,{get:()=\u003ee[o],enumerable:!(c=_(e,o))||c.enumerable});return t};var p=(t,e,r)=\u003e(r=t!=null?f(d(t)):{},s(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),y=t=\u003es(a({},\"__esModule\",{value:!0}),t);var i=h((F,u)=\u003e{u.exports=_jsx_runtime});var C={};j(C,{default:()=\u003ex,frontmatter:()=\u003eM});var n=p(i()),M={title:\"Security research\",slug:\"security-research\"};function m(t){return(0,n.jsx)(n.Fragment,{})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(m,{...t})}):m(t)}return y(C);})();\n;return Component;"},"_id":"categories/security-research.mdx","_raw":{"sourceFilePath":"categories/security-research.mdx","sourceFileName":"security-research.mdx","sourceFileDir":"categories","contentType":"mdx","flattenedPath":"categories/security-research"},"type":"Category","url":"/categories/security-research"}]},"seriesArticles":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"nightmare-on-0xelm-street"},"buildId":"-h5Wp0_6qpDXqGCvbcL5I","assetPrefix":"/security-labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>